{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst ethers = require('ethers');\n\nconst domainSchema = [{\n  name: \"name\",\n  type: \"string\"\n}, {\n  name: \"version\",\n  type: \"string\"\n}, {\n  name: \"chainId\",\n  type: \"uint256\"\n}, {\n  name: \"verifyingContract\",\n  type: \"address\"\n}];\nconst permitSchema = [{\n  name: \"holder\",\n  type: \"address\"\n}, {\n  name: \"spender\",\n  type: \"address\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"expiry\",\n  type: \"uint256\"\n}, {\n  name: \"allowed\",\n  type: \"bool\"\n}];\n\nasync function signPermit(signer, domain, message) {\n  let myAddr = await signer.getAddress();\n\n  if (myAddr.toLowerCase() !== message.holder.toLowerCase()) {\n    throw `signPermit: address of signer does not match holder address in message`;\n  }\n\n  if (message.nonce === undefined) {\n    let tokenAbi = ['function nonces(address holder) view returns (uint)'];\n    let tokenContract = new ethers.Contract(domain.verifyingContract, tokenAbi, signer);\n    let nonce = await tokenContract.nonces(myAddr);\n    message = _objectSpread(_objectSpread({}, message), {}, {\n      nonce: nonce.toString()\n    });\n  }\n\n  let typedData = {\n    types: {\n      EIP712Domain: domainSchema,\n      Permit: permitSchema\n    },\n    primaryType: \"Permit\",\n    domain,\n    message\n  };\n  const sig = await signer.provider.send(\"eth_signTypedData_v3\", [myAddr, JSON.stringify(typedData)]);\n  return {\n    domain,\n    message,\n    sig\n  };\n}\n\nmodule.exports = {\n  signPermit\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/signPermit.js"],"names":["ethers","require","domainSchema","name","type","permitSchema","signPermit","signer","domain","message","myAddr","getAddress","toLowerCase","holder","nonce","undefined","tokenAbi","tokenContract","Contract","verifyingContract","nonces","toString","typedData","types","EIP712Domain","Permit","primaryType","sig","provider","send","JSON","stringify","module","exports"],"mappings":";;;;;;AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMC,YAAY,GAAG,CACnB;AAAEC,EAAAA,IAAI,EAAE,MAAR;AAAgBC,EAAAA,IAAI,EAAE;AAAtB,CADmB,EAEnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAFmB,EAGnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAHmB,EAInB;AAAED,EAAAA,IAAI,EAAE,mBAAR;AAA6BC,EAAAA,IAAI,EAAE;AAAnC,CAJmB,CAArB;AAOA,MAAMC,YAAY,GAAG,CACnB;AAAEF,EAAAA,IAAI,EAAE,QAAR;AAAkBC,EAAAA,IAAI,EAAE;AAAxB,CADmB,EAEnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAFmB,EAGnB;AAAED,EAAAA,IAAI,EAAE,OAAR;AAAiBC,EAAAA,IAAI,EAAE;AAAvB,CAHmB,EAInB;AAAED,EAAAA,IAAI,EAAE,QAAR;AAAkBC,EAAAA,IAAI,EAAE;AAAxB,CAJmB,EAKnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CALmB,CAArB;;AAQA,eAAeE,UAAf,CAA0BC,MAA1B,EAAkCC,MAAlC,EAA0CC,OAA1C,EAAmD;AACjD,MAAIC,MAAM,GAAG,MAAMH,MAAM,CAACI,UAAP,EAAnB;;AAEA,MAAID,MAAM,CAACE,WAAP,OAAyBH,OAAO,CAACI,MAAR,CAAeD,WAAf,EAA7B,EAA2D;AACzD,UAAQ,wEAAR;AACD;;AAED,MAAIH,OAAO,CAACK,KAAR,KAAkBC,SAAtB,EAAiC;AAC/B,QAAIC,QAAQ,GAAG,CAAC,qDAAD,CAAf;AAEA,QAAIC,aAAa,GAAG,IAAIjB,MAAM,CAACkB,QAAX,CAAoBV,MAAM,CAACW,iBAA3B,EAA8CH,QAA9C,EAAwDT,MAAxD,CAApB;AAEA,QAAIO,KAAK,GAAG,MAAMG,aAAa,CAACG,MAAd,CAAqBV,MAArB,CAAlB;AAEAD,IAAAA,OAAO,mCAAQA,OAAR;AAAiBK,MAAAA,KAAK,EAAEA,KAAK,CAACO,QAAN;AAAxB,MAAP;AACD;;AAED,MAAIC,SAAS,GAAG;AACdC,IAAAA,KAAK,EAAE;AACLC,MAAAA,YAAY,EAAEtB,YADT;AAELuB,MAAAA,MAAM,EAAEpB;AAFH,KADO;AAKdqB,IAAAA,WAAW,EAAE,QALC;AAMdlB,IAAAA,MANc;AAOdC,IAAAA;AAPc,GAAhB;AAUA,QAAMkB,GAAG,GAAG,MAAMpB,MAAM,CAACqB,QAAP,CAAgBC,IAAhB,CAAqB,sBAArB,EAA6C,CAACnB,MAAD,EAASoB,IAAI,CAACC,SAAL,CAAeT,SAAf,CAAT,CAA7C,CAAlB;AAEA,SAAO;AAAEd,IAAAA,MAAF;AAAUC,IAAAA,OAAV;AAAmBkB,IAAAA;AAAnB,GAAP;AACD;;AAEDK,MAAM,CAACC,OAAP,GAAiB;AACf3B,EAAAA;AADe,CAAjB","sourcesContent":["const ethers = require('ethers')\n\nconst domainSchema = [\n  { name: \"name\", type: \"string\" },\n  { name: \"version\", type: \"string\" },\n  { name: \"chainId\", type: \"uint256\" },\n  { name: \"verifyingContract\", type: \"address\" },\n];\n\nconst permitSchema = [\n  { name: \"holder\", type: \"address\" },\n  { name: \"spender\", type: \"address\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"expiry\", type: \"uint256\" },\n  { name: \"allowed\", type: \"bool\" },\n];\n\nasync function signPermit(signer, domain, message) {\n  let myAddr = await signer.getAddress();\n\n  if (myAddr.toLowerCase() !== message.holder.toLowerCase()) {\n    throw (`signPermit: address of signer does not match holder address in message`);\n  }\n\n  if (message.nonce === undefined) {\n    let tokenAbi = ['function nonces(address holder) view returns (uint)',];\n\n    let tokenContract = new ethers.Contract(domain.verifyingContract, tokenAbi, signer);\n\n    let nonce = await tokenContract.nonces(myAddr);\n\n    message = { ...message, nonce: nonce.toString(), };\n  }\n\n  let typedData = {\n    types: {\n      EIP712Domain: domainSchema,\n      Permit: permitSchema,\n    },\n    primaryType: \"Permit\",\n    domain,\n    message,\n  };\n\n  const sig = await signer.provider.send(\"eth_signTypedData_v3\", [myAddr, JSON.stringify(typedData)])\n\n  return { domain, message, sig, };\n}\n\nmodule.exports = {\n  signPermit\n}\n"]},"metadata":{},"sourceType":"script"}