{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport { ethers } from 'ethers';\nimport { V2_CONTRACT_ADDRESSES } from 'lib/constants';\nimport { updateTransaction } from 'lib/services/updateTransaction';\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName';\nimport { poolToast } from 'lib/utils/poolToast';\n\nvar debug = require('debug')('pool-app:callTransaction');\n\nvar getRevertReason = require('eth-revert-reason');\n\nvar bn = ethers.utils.bigNumberify; // this could be smart enough to know which ABI to use based on \n// the contract address\n\nexport var callTransaction = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(t, transactions, setTransactions, tx, provider, usersAddress, contractAbi, contractAddress, method) {\n    var params,\n        ethersTx,\n        signer,\n        contract,\n        nextNonce,\n        fxn,\n        data,\n        chainId,\n        transactionRequest,\n        gasEstimate,\n        _contract$estimate,\n        gasLimit,\n        lastParam,\n        isV2Method,\n        gasMultiplier,\n        _ethersTx,\n        _reason,\n        reason,\n        errorMsg,\n        networkName,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            params = _args.length > 9 && _args[9] !== undefined ? _args[9] : [];\n            signer = provider.getSigner();\n            contract = new ethers.Contract(contractAddress, contractAbi, signer);\n            _context.next = 5;\n            return provider.getTransactionCount(usersAddress, 'pending');\n\n          case 5:\n            nextNonce = _context.sent;\n            fxn = contract[\"interface\"].functions[method];\n            data = fxn.encode(params);\n            chainId = provider.network.chainId;\n            transactionRequest = {\n              to: contractAddress,\n              nonce: nextNonce,\n              data: data,\n              chainId: chainId // gasLimit: bn(50000) // false number, could be a red herring, ignore this!\n\n            };\n            _context.prev = 10;\n            _context.next = 13;\n            return (_contract$estimate = contract.estimate)[method].apply(_contract$estimate, _toConsumableArray(params));\n\n          case 13:\n            gasEstimate = _context.sent;\n            _context.next = 19;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](10);\n            console.log(\"error while estimating gas: \", _context.t0);\n\n          case 19:\n            lastParam = params[params.length - 1];\n\n            if (typeof lastParam === 'object' && lastParam.hasOwnProperty('gasLimit')) {\n              transactionRequest.gasLimit = params.pop().gasLimit;\n            } else if (gasEstimate) {\n              isV2Method = V2_CONTRACT_ADDRESSES.includes(contractAddress);\n              gasMultiplier = isV2Method ? 1.2 : 1.1;\n              transactionRequest.gasLimit = parseInt(gasEstimate.toNumber() * gasMultiplier, 10);\n            }\n\n            _context.prev = 21;\n            // using the lower level `Signer#sendTransaction` API here\n            // since the basic 'contract.method()' (ie.\n            // const ethersTx = await contract[method].apply(null, params))\n            // one was intermittently\n            // failing to get the nonce on Kovan w/ MetaMask\n            debug('sending tx', transactionRequest);\n            _context.next = 25;\n            return signer.sendTransaction(transactionRequest);\n\n          case 25:\n            ethersTx = _context.sent;\n            updateTransaction(tx.id, {\n              ethersTx: ethersTx,\n              sent: true,\n              inWallet: false,\n              hash: ethersTx.hash\n            }, transactions, setTransactions); // debug(tx)\n\n            poolToast.success(__jsx(React.Fragment, null, tx.name, __jsx(\"br\", null), \" \", t('transactionSentConfirming'))); // Transaction sent! Confirming...\n\n            _context.next = 30;\n            return ethersTx.wait();\n\n          case 30:\n            updateTransaction(tx.id, {\n              ethersTx: ethersTx,\n              completed: true\n            }, transactions, setTransactions);\n            poolToast.rainbow(__jsx(React.Fragment, null, tx.name, __jsx(\"br\", null), \" \", t('transactionSuccessful')));\n            _context.next = 52;\n            break;\n\n          case 34:\n            _context.prev = 34;\n            _context.t1 = _context[\"catch\"](21);\n            console.error(_context.t1.message);\n\n            if (!_context.t1.message.match('User denied transaction signature')) {\n              _context.next = 42;\n              break;\n            }\n\n            updateTransaction(tx.id, {\n              cancelled: true,\n              completed: true\n            }, transactions, setTransactions);\n            poolToast.warn(t('youCancelledTheTransaction')); // You cancelled the transaction\n\n            _context.next = 52;\n            break;\n\n          case 42:\n            if (!((_ethersTx = ethersTx) === null || _ethersTx === void 0 ? void 0 : _ethersTx.hash)) {\n              _context.next = 47;\n              break;\n            }\n\n            networkName = chainIdToNetworkName(ethersTx.chainId);\n            _context.next = 46;\n            return getRevertReason(ethersTx.hash, networkName);\n\n          case 46:\n            reason = _context.sent;\n\n          case 47:\n            if ((_reason = reason) === null || _reason === void 0 ? void 0 : _reason.match('rng-in-flight')) {\n              reason = t('prizeBeingAwardedPleaseTryAgainSoon'); // 'Prize being awarded! Please try again soon'\n            }\n\n            errorMsg = reason ? reason : _context.t1.message;\n\n            if (!reason && _context.t1.message.match('transaction failed')) {\n              errorMsg = t('transactionFailedUnknownError'); // 'Transaction failed: unknown error'\n            }\n\n            updateTransaction(tx.id, {\n              error: true,\n              completed: true,\n              reason: errorMsg\n            }, transactions, setTransactions); // Failed to complete. Reason:\n\n            poolToast.error(\"\".concat(tx.name, \" - \").concat(t('txFailedToCompleteWithReason'), \" \").concat(errorMsg));\n\n          case 52:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[10, 16], [21, 34]]);\n  }));\n\n  return function callTransaction(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/callTransaction.js"],"names":["ethers","V2_CONTRACT_ADDRESSES","updateTransaction","chainIdToNetworkName","poolToast","debug","require","getRevertReason","bn","utils","bigNumberify","callTransaction","t","transactions","setTransactions","tx","provider","usersAddress","contractAbi","contractAddress","method","params","signer","getSigner","contract","Contract","getTransactionCount","nextNonce","fxn","functions","data","encode","chainId","network","transactionRequest","to","nonce","estimate","gasEstimate","console","log","lastParam","length","hasOwnProperty","gasLimit","pop","isV2Method","includes","gasMultiplier","parseInt","toNumber","sendTransaction","ethersTx","id","sent","inWallet","hash","success","name","wait","completed","rainbow","error","message","match","cancelled","warn","networkName","reason","errorMsg"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\n\nimport { V2_CONTRACT_ADDRESSES } from 'lib/constants'\nimport { updateTransaction } from 'lib/services/updateTransaction'\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'\nimport { poolToast } from 'lib/utils/poolToast'\n\nconst debug = require('debug')('pool-app:callTransaction')\n\nconst getRevertReason = require('eth-revert-reason')\nconst bn = ethers.utils.bigNumberify\n\n// this could be smart enough to know which ABI to use based on \n// the contract address\nexport const callTransaction = async (\n  t,\n  transactions,\n  setTransactions,\n  tx,\n  provider,\n  usersAddress,\n  contractAbi,\n  contractAddress,\n  method,\n  params = [],\n) => {\n  let ethersTx\n\n  const signer = provider.getSigner()\n\n  const contract = new ethers.Contract(\n    contractAddress,\n    contractAbi,\n    signer\n  )\n\n  const nextNonce = await provider.getTransactionCount(\n    usersAddress,\n    'pending'\n  )\n\n  const fxn = contract.interface.functions[method]\n\n  const data = fxn.encode(params)\n\n  const chainId = provider.network.chainId\n  let transactionRequest = {\n    to: contractAddress,\n    nonce: nextNonce,\n    data,\n    chainId,\n    // gasLimit: bn(50000) // false number, could be a red herring, ignore this!\n  }\n  \n  let gasEstimate\n  try {\n    gasEstimate = await contract.estimate[method](...params)\n  } catch (e) {\n    console.log(`error while estimating gas: `, e)\n  }\n\n  let gasLimit\n  const lastParam = params[params.length - 1]\n  if (typeof lastParam === 'object' && lastParam.hasOwnProperty('gasLimit')) {\n    transactionRequest.gasLimit = params.pop().gasLimit\n  } else if (gasEstimate) {\n    const isV2Method = V2_CONTRACT_ADDRESSES.includes(contractAddress)\n    const gasMultiplier = isV2Method ? 1.2 : 1.1\n    \n    transactionRequest.gasLimit = parseInt(gasEstimate.toNumber() * gasMultiplier, 10)\n  }\n\n\n\n  try {\n    // using the lower level `Signer#sendTransaction` API here\n    // since the basic 'contract.method()' (ie.\n    // const ethersTx = await contract[method].apply(null, params))\n    // one was intermittently\n    // failing to get the nonce on Kovan w/ MetaMask\n    debug('sending tx', transactionRequest)\n    ethersTx = await signer.sendTransaction(transactionRequest)\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        sent: true,\n        inWallet: false,\n        hash: ethersTx.hash\n      },\n      transactions,\n      setTransactions\n    )\n    // debug(tx)\n\n    poolToast.success(<>{tx.name}<br /> {t('transactionSentConfirming')}</>)\n    // Transaction sent! Confirming...\n\n    await ethersTx.wait()\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        completed: true,\n      },\n      transactions,\n      setTransactions\n    )\n\n    poolToast.rainbow(<>{tx.name}<br /> {t('transactionSuccessful')}</>)\n  } catch (e) {\n    console.error(e.message)\n\n    if (e.message.match('User denied transaction signature')) {\n      updateTransaction(\n        tx.id,\n        {\n          cancelled: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n      \n      poolToast.warn(t('youCancelledTheTransaction'))\n      // You cancelled the transaction\n    } else {\n      let reason,\n        errorMsg\n        \n      if (ethersTx?.hash) {\n        const networkName = chainIdToNetworkName(ethersTx.chainId)\n        reason = await getRevertReason(ethersTx.hash, networkName)\n      }\n\n      if (reason?.match('rng-in-flight')) {\n        reason = t('prizeBeingAwardedPleaseTryAgainSoon')\n        // 'Prize being awarded! Please try again soon'\n      }\n\n      errorMsg = reason ? reason : e.message\n\n      if (!reason && e.message.match('transaction failed')) {\n        errorMsg = t('transactionFailedUnknownError')\n        // 'Transaction failed: unknown error'\n      }\n\n      updateTransaction(\n        tx.id,\n        {\n          error: true,\n          completed: true,\n          reason: errorMsg\n        },\n        transactions,\n        setTransactions\n      )\n\n      // Failed to complete. Reason:\n      poolToast.error(`${tx.name} - ${t('txFailedToCompleteWithReason')} ${errorMsg}`)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}