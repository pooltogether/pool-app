{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { poolTokenSupportsPermitSign } from 'lib/utils/poolTokenSupportsPermitSign';\nimport { ethers } from 'ethers';\nimport DaiAbi from '@pooltogether/pooltogether-contracts/abis/Dai'; // import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\n\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool';\nimport { CONTRACT_ADDRESSES } from 'lib/constants';\nimport { signPermit } from 'lib/utils/signPermit';\nexport var permitSignOrRegularDeposit = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(t, provider, chainId, usersAddress, poolAddress, tokenAddress, sendTx, sharedParams // needsPermit\n  ) {\n    var contractAbi, contractAddress, method, params, id;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // let permitAddress\n            // const supportsPermit = false\n            // const supportsPermit = poolTokenSupportsPermitSign(chainId, tokenAddress)// && provider.isMetaMask\n            // if (supportsPermit) {\n            //   permitAddress = CONTRACT_ADDRESSES[chainId].PermitAndDepositDai\n            // }\n            contractAbi = PrizePoolAbi; // let contractAbi = supportsPermit ? PermitAndDepositDaiAbi : PrizePoolAbi\n\n            contractAddress = poolAddress; // let contractAddress = supportsPermit ? permitAddress : poolAddress\n\n            method = 'depositTo'; // let permitParams = []\n            // let additionalSubsequentParams = []\n            // if (supportsPermit && needsPermit) {\n            //   const signer = await provider.getSigner()\n            //   const daiContract = new ethers.Contract(tokenAddress, DaiAbi, provider)\n            //   const nonce = await daiContract.nonces(usersAddress)\n            //   const expiry = (new Date()).getTime() + 1200000 // 20 minutes into future\n            //   const holder = await signer.getAddress()\n            //   let permit = await signPermit(\n            //     signer,\n            //     {\n            //       name: \"Dai Stablecoin\",\n            //       version: \"1\",\n            //       chainId,\n            //       verifyingContract: tokenAddress,\n            //     },\n            //     {\n            //       holder,\n            //       spender: permitAddress,\n            //       nonce: nonce.toString(),\n            //       expiry,\n            //       allowed: true\n            //     }\n            //   )\n            //   let { v, r, s } = ethers.utils.splitSignature(permit.sig)\n            //   permitParams = [\n            //     tokenAddress,\n            //     usersAddress,\n            //     nonce,\n            //     expiry,\n            //     true,\n            //     v,\n            //     r,\n            //     s,\n            //     poolAddress,\n            //   ]\n            //   method = 'permitAndDepositTo'\n            // }\n            // if (supportsPermit && !needsPermit) {\n            //   additionalSubsequentParams = [\n            //     tokenAddress,\n            //     poolAddress,\n            //   ]\n            // }\n\n            params = _toConsumableArray(sharedParams);\n            id = sendTx(t, provider, usersAddress, contractAbi, contractAddress, method, params);\n            return _context.abrupt(\"return\", id);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function permitSignOrRegularDeposit(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/permitSignOrRegularDeposit.js"],"names":["poolTokenSupportsPermitSign","ethers","DaiAbi","PrizePoolAbi","CONTRACT_ADDRESSES","signPermit","permitSignOrRegularDeposit","t","provider","chainId","usersAddress","poolAddress","tokenAddress","sendTx","sharedParams","contractAbi","contractAddress","method","params","id"],"mappings":";;;AAAA,SAASA,2BAAT,QAA4C,uCAA5C;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,OAAOC,MAAP,MAAmB,+CAAnB,C,CACA;;AACA,OAAOC,YAAP,MAAyB,qDAAzB;AAEA,SAASC,kBAAT,QAAmC,eAAnC;AACA,SAASC,UAAT,QAA2B,sBAA3B;AAEA,OAAO,IAAMC,0BAA0B;AAAA,sEAAG,iBACxCC,CADwC,EAExCC,QAFwC,EAGxCC,OAHwC,EAIxCC,YAJwC,EAKxCC,WALwC,EAMxCC,YANwC,EAOxCC,MAPwC,EAQxCC,YARwC,CASxC;AATwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAWxC;AAEA;AACA;AACA;AACA;AACA;AAEIC,YAAAA,WAnBoC,GAmBtBZ,YAnBsB,EAoBxC;;AACIa,YAAAA,eArBoC,GAqBlBL,WArBkB,EAsBxC;;AACIM,YAAAA,MAvBoC,GAuB3B,WAvB2B,EAwBxC;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEMC,YAAAA,MA7EkC,sBAgFnCJ,YAhFmC;AAmFlCK,YAAAA,EAnFkC,GAmF7BN,MAAM,CACfN,CADe,EAEfC,QAFe,EAGfE,YAHe,EAIfK,WAJe,EAKfC,eALe,EAMfC,MANe,EAOfC,MAPe,CAnFuB;AAAA,6CA6FjCC,EA7FiC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAA1Bb,0BAA0B;AAAA;AAAA;AAAA,GAAhC","sourcesContent":["import { poolTokenSupportsPermitSign } from 'lib/utils/poolTokenSupportsPermitSign'\nimport { ethers } from 'ethers'\n\nimport DaiAbi from '@pooltogether/pooltogether-contracts/abis/Dai'\n// import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool'\n\nimport { CONTRACT_ADDRESSES } from 'lib/constants'\nimport { signPermit } from 'lib/utils/signPermit'\n\nexport const permitSignOrRegularDeposit = async (\n  t,\n  provider,\n  chainId,\n  usersAddress,\n  poolAddress,\n  tokenAddress,\n  sendTx,\n  sharedParams,\n  // needsPermit\n) => {\n  // let permitAddress\n  \n  // const supportsPermit = false\n  // const supportsPermit = poolTokenSupportsPermitSign(chainId, tokenAddress)// && provider.isMetaMask\n  // if (supportsPermit) {\n  //   permitAddress = CONTRACT_ADDRESSES[chainId].PermitAndDepositDai\n  // }\n\n  let contractAbi = PrizePoolAbi\n  // let contractAbi = supportsPermit ? PermitAndDepositDaiAbi : PrizePoolAbi\n  let contractAddress = poolAddress\n  // let contractAddress = supportsPermit ? permitAddress : poolAddress\n  let method = 'depositTo'\n  // let permitParams = []\n  // let additionalSubsequentParams = []\n\n  // if (supportsPermit && needsPermit) {\n  //   const signer = await provider.getSigner()\n  //   const daiContract = new ethers.Contract(tokenAddress, DaiAbi, provider)\n  //   const nonce = await daiContract.nonces(usersAddress)\n  //   const expiry = (new Date()).getTime() + 1200000 // 20 minutes into future\n\n  //   const holder = await signer.getAddress()\n\n  //   let permit = await signPermit(\n  //     signer,\n  //     {\n  //       name: \"Dai Stablecoin\",\n  //       version: \"1\",\n  //       chainId,\n  //       verifyingContract: tokenAddress,\n  //     },\n  //     {\n  //       holder,\n  //       spender: permitAddress,\n  //       nonce: nonce.toString(),\n  //       expiry,\n  //       allowed: true\n  //     }\n  //   )\n\n  //   let { v, r, s } = ethers.utils.splitSignature(permit.sig)\n\n    \n  //   permitParams = [\n  //     tokenAddress,\n  //     usersAddress,\n  //     nonce,\n  //     expiry,\n  //     true,\n  //     v,\n  //     r,\n  //     s,\n  //     poolAddress,\n  //   ]\n\n  //   method = 'permitAndDepositTo'\n  // }\n\n  // if (supportsPermit && !needsPermit) {\n  //   additionalSubsequentParams = [\n  //     tokenAddress,\n  //     poolAddress,\n  //   ]\n  // }\n\n  const params = [\n    // ...permitParams,\n    // ...additionalSubsequentParams,\n    ...sharedParams,\n  ]\n\n  const id = sendTx(\n    t,\n    provider,\n    usersAddress,\n    contractAbi,\n    contractAddress,\n    method,\n    params\n  )\n\n  return id\n}"]},"metadata":{},"sourceType":"module"}