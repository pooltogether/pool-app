{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { batch, contract } from '@pooltogether/etherplex';\nimport { ethers } from 'ethers';\nimport CTokenAbi from '@pooltogether/pooltogether-contracts/abis/CTokenInterface';\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool';\nimport SingleRandomWinnerAbi from '@pooltogether/pooltogether-contracts/abis/SingleRandomWinner';\n\nvar debug = require('debug')('pool-app:fetchGenericChainData');\n\nexport var fetchGenericChainData = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var provider, poolData, poolAddress, prizeStrategyAddress, cTokenAddress, etherplexPrizeStrategyContract, etherplexCTokenContract, etherplexPrizePoolContract, values;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            provider = _ref.provider, poolData = _ref.poolData;\n            poolAddress = poolData.poolAddress;\n            prizeStrategyAddress = poolData.prizeStrategy.id;\n            cTokenAddress = poolData.compoundPrizePool.cToken;\n            _context.prev = 4;\n            etherplexPrizeStrategyContract = contract('prizeStrategy', SingleRandomWinnerAbi, prizeStrategyAddress);\n            etherplexCTokenContract = contract('cToken', CTokenAbi, cTokenAddress);\n            etherplexPrizePoolContract = contract('prizePool', PrizePoolAbi, poolAddress);\n            _context.next = 10;\n            return batch(provider, etherplexPrizeStrategyContract.isRngRequested() // used to determine if the pool is locked\n            .isRngCompleted().canStartAward().canCompleteAward().prizePeriodRemainingSeconds().estimateRemainingBlocksToPrize(ethers.utils.parseEther('14')), etherplexCTokenContract.decimals().supplyRatePerBlock(), etherplexPrizePoolContract.captureAwardBalance());\n\n          case 10:\n            values = _context.sent;\n            return _context.abrupt(\"return\", {\n              awardBalance: values.prizePool.captureAwardBalance[0],\n              isRngRequested: values.prizeStrategy.isRngRequested[0],\n              isRngCompleted: values.prizeStrategy.isRngCompleted[0],\n              // do we need this?\n              canStartAward: values.prizeStrategy.canStartAward[0],\n              canCompleteAward: values.prizeStrategy.canCompleteAward[0],\n              supplyRatePerBlock: values.cToken.supplyRatePerBlock[0],\n              prizePeriodRemainingSeconds: values.prizeStrategy.prizePeriodRemainingSeconds[0],\n              estimateRemainingBlocksToPrize: values.prizeStrategy.estimateRemainingBlocksToPrize[0],\n              loading: false\n            });\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](4);\n            throw {\n              name: 'fetchGenericChainData Error',\n              message: \"Error from Infura was: \".concat(_context.t0.message)\n            };\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 14]]);\n  }));\n\n  return function fetchGenericChainData(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchGenericChainData.js"],"names":["batch","contract","ethers","CTokenAbi","PrizePoolAbi","SingleRandomWinnerAbi","debug","require","fetchGenericChainData","provider","poolData","poolAddress","prizeStrategyAddress","prizeStrategy","id","cTokenAddress","compoundPrizePool","cToken","etherplexPrizeStrategyContract","etherplexCTokenContract","etherplexPrizePoolContract","isRngRequested","isRngCompleted","canStartAward","canCompleteAward","prizePeriodRemainingSeconds","estimateRemainingBlocksToPrize","utils","parseEther","decimals","supplyRatePerBlock","captureAwardBalance","values","awardBalance","prizePool","loading","name","message"],"mappings":";;AAAA,SAASA,KAAT,EAAgBC,QAAhB,QAAgC,yBAAhC;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,OAAOC,SAAP,MAAsB,2DAAtB;AACA,OAAOC,YAAP,MAAyB,qDAAzB;AACA,OAAOC,qBAAP,MAAkC,8DAAlC;;AAEA,IAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,gCAAjB,CAAd;;AAEA,OAAO,IAAMC,qBAAqB;AAAA,uEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACnCC,YAAAA,QADmC,QACnCA,QADmC,EAEnCC,QAFmC,QAEnCA,QAFmC;AAI7BC,YAAAA,WAJ6B,GAIfD,QAAQ,CAACC,WAJM;AAK7BC,YAAAA,oBAL6B,GAKNF,QAAQ,CAACG,aAAT,CAAuBC,EALjB;AAM7BC,YAAAA,aAN6B,GAMbL,QAAQ,CAACM,iBAAT,CAA2BC,MANd;AAAA;AAS3BC,YAAAA,8BAT2B,GASMjB,QAAQ,CAC7C,eAD6C,EAE7CI,qBAF6C,EAG7CO,oBAH6C,CATd;AAc3BO,YAAAA,uBAd2B,GAcDlB,QAAQ,CACtC,QADsC,EAEtCE,SAFsC,EAGtCY,aAHsC,CAdP;AAmB3BK,YAAAA,0BAnB2B,GAmBEnB,QAAQ,CACzC,WADyC,EAEzCG,YAFyC,EAGzCO,WAHyC,CAnBV;AAAA;AAAA,mBA0BZX,KAAK,CACxBS,QADwB,EAExBS,8BAA8B,CAC3BG,cADH,GACoB;AADpB,aAEGC,cAFH,GAGGC,aAHH,GAIGC,gBAJH,GAKGC,2BALH,GAMGC,8BANH,CAMkCxB,MAAM,CAACyB,KAAP,CAAaC,UAAb,CAAwB,IAAxB,CANlC,CAFwB,EASxBT,uBAAuB,CACpBU,QADH,GAEGC,kBAFH,EATwB,EAYxBV,0BAA0B,CACvBW,mBADH,EAZwB,CA1BO;;AAAA;AA0B3BC,YAAAA,MA1B2B;AAAA,6CA0C1B;AACLC,cAAAA,YAAY,EAAED,MAAM,CAACE,SAAP,CAAiBH,mBAAjB,CAAqC,CAArC,CADT;AAELV,cAAAA,cAAc,EAAEW,MAAM,CAACnB,aAAP,CAAqBQ,cAArB,CAAoC,CAApC,CAFX;AAGLC,cAAAA,cAAc,EAAEU,MAAM,CAACnB,aAAP,CAAqBS,cAArB,CAAoC,CAApC,CAHX;AAGmD;AACxDC,cAAAA,aAAa,EAAES,MAAM,CAACnB,aAAP,CAAqBU,aAArB,CAAmC,CAAnC,CAJV;AAKLC,cAAAA,gBAAgB,EAAEQ,MAAM,CAACnB,aAAP,CAAqBW,gBAArB,CAAsC,CAAtC,CALb;AAMLM,cAAAA,kBAAkB,EAAEE,MAAM,CAACf,MAAP,CAAca,kBAAd,CAAiC,CAAjC,CANf;AAOLL,cAAAA,2BAA2B,EAAEO,MAAM,CAACnB,aAAP,CAAqBY,2BAArB,CAAiD,CAAjD,CAPxB;AAQLC,cAAAA,8BAA8B,EAAEM,MAAM,CAACnB,aAAP,CAAqBa,8BAArB,CAAoD,CAApD,CAR3B;AASLS,cAAAA,OAAO,EAAE;AATJ,aA1C0B;;AAAA;AAAA;AAAA;AAAA,kBAsD3B;AACJC,cAAAA,IAAI,EAAE,6BADF;AAEJC,cAAAA,OAAO,mCAA4B,YAAEA,OAA9B;AAFH,aAtD2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAArB7B,qBAAqB;AAAA;AAAA;AAAA,GAA3B","sourcesContent":["import { batch, contract } from '@pooltogether/etherplex'\nimport { ethers } from 'ethers'\n\nimport CTokenAbi from '@pooltogether/pooltogether-contracts/abis/CTokenInterface'\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool'\nimport SingleRandomWinnerAbi from '@pooltogether/pooltogether-contracts/abis/SingleRandomWinner'\n\nconst debug = require('debug')('pool-app:fetchGenericChainData')\n\nexport const fetchGenericChainData = async ({\n  provider,\n  poolData\n}) => {\n  const poolAddress = poolData.poolAddress\n  const prizeStrategyAddress = poolData.prizeStrategy.id\n  const cTokenAddress = poolData.compoundPrizePool.cToken\n\n  try {\n    const etherplexPrizeStrategyContract = contract(\n      'prizeStrategy',\n      SingleRandomWinnerAbi,\n      prizeStrategyAddress\n    )\n    const etherplexCTokenContract = contract(\n      'cToken',\n      CTokenAbi,\n      cTokenAddress\n    )\n    const etherplexPrizePoolContract = contract(\n      'prizePool',\n      PrizePoolAbi,\n      poolAddress\n    )\n\n\n    const values = await batch(\n      provider,\n      etherplexPrizeStrategyContract\n        .isRngRequested() // used to determine if the pool is locked\n        .isRngCompleted()\n        .canStartAward()\n        .canCompleteAward()\n        .prizePeriodRemainingSeconds()\n        .estimateRemainingBlocksToPrize(ethers.utils.parseEther('14')),\n      etherplexCTokenContract\n        .decimals()\n        .supplyRatePerBlock(),\n      etherplexPrizePoolContract\n        .captureAwardBalance()\n    )\n\n    return {\n      awardBalance: values.prizePool.captureAwardBalance[0],\n      isRngRequested: values.prizeStrategy.isRngRequested[0],\n      isRngCompleted: values.prizeStrategy.isRngCompleted[0], // do we need this?\n      canStartAward: values.prizeStrategy.canStartAward[0],\n      canCompleteAward: values.prizeStrategy.canCompleteAward[0],\n      supplyRatePerBlock: values.cToken.supplyRatePerBlock[0],\n      prizePeriodRemainingSeconds: values.prizeStrategy.prizePeriodRemainingSeconds[0],\n      estimateRemainingBlocksToPrize: values.prizeStrategy.estimateRemainingBlocksToPrize[0],\n      loading: false,\n    }\n  } catch (e) {\n    throw {\n      name: 'fetchGenericChainData Error',\n      message: `Error from Infura was: ${e.message}`\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}