{"ast":null,"code":"var _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar ethers = require('ethers');\n\nvar domainSchema = [{\n  name: \"name\",\n  type: \"string\"\n}, {\n  name: \"version\",\n  type: \"string\"\n}, {\n  name: \"chainId\",\n  type: \"uint256\"\n}, {\n  name: \"verifyingContract\",\n  type: \"address\"\n}];\nvar permitSchema = [{\n  name: \"holder\",\n  type: \"address\"\n}, {\n  name: \"spender\",\n  type: \"address\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"expiry\",\n  type: \"uint256\"\n}, {\n  name: \"allowed\",\n  type: \"bool\"\n}];\n\nfunction signPermit(_x, _x2, _x3) {\n  return _signPermit.apply(this, arguments);\n}\n\nfunction _signPermit() {\n  _signPermit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(signer, domain, message) {\n    var myAddr, tokenAbi, tokenContract, nonce, typedData, sig;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return signer.getAddress();\n\n          case 2:\n            myAddr = _context.sent;\n\n            if (!(myAddr.toLowerCase() !== message.holder.toLowerCase())) {\n              _context.next = 5;\n              break;\n            }\n\n            throw \"signPermit: address of signer does not match holder address in message\";\n\n          case 5:\n            if (!(message.nonce === undefined)) {\n              _context.next = 12;\n              break;\n            }\n\n            tokenAbi = ['function nonces(address holder) view returns (uint)'];\n            tokenContract = new ethers.Contract(domain.verifyingContract, tokenAbi, signer);\n            _context.next = 10;\n            return tokenContract.nonces(myAddr);\n\n          case 10:\n            nonce = _context.sent;\n            message = _objectSpread(_objectSpread({}, message), {}, {\n              nonce: nonce.toString()\n            });\n\n          case 12:\n            typedData = {\n              types: {\n                EIP712Domain: domainSchema,\n                Permit: permitSchema\n              },\n              primaryType: \"Permit\",\n              domain: domain,\n              message: message\n            };\n            _context.next = 15;\n            return signer.provider.send(\"eth_signTypedData_v3\", [myAddr, JSON.stringify(typedData)]);\n\n          case 15:\n            sig = _context.sent;\n            return _context.abrupt(\"return\", {\n              domain: domain,\n              message: message,\n              sig: sig\n            });\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signPermit.apply(this, arguments);\n}\n\nmodule.exports = {\n  signPermit: signPermit\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/signPermit.js"],"names":["ethers","require","domainSchema","name","type","permitSchema","signPermit","signer","domain","message","getAddress","myAddr","toLowerCase","holder","nonce","undefined","tokenAbi","tokenContract","Contract","verifyingContract","nonces","toString","typedData","types","EIP712Domain","Permit","primaryType","provider","send","JSON","stringify","sig","module","exports"],"mappings":";;;;;;;;;;AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,IAAMC,YAAY,GAAG,CACnB;AAAEC,EAAAA,IAAI,EAAE,MAAR;AAAgBC,EAAAA,IAAI,EAAE;AAAtB,CADmB,EAEnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAFmB,EAGnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAHmB,EAInB;AAAED,EAAAA,IAAI,EAAE,mBAAR;AAA6BC,EAAAA,IAAI,EAAE;AAAnC,CAJmB,CAArB;AAOA,IAAMC,YAAY,GAAG,CACnB;AAAEF,EAAAA,IAAI,EAAE,QAAR;AAAkBC,EAAAA,IAAI,EAAE;AAAxB,CADmB,EAEnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CAFmB,EAGnB;AAAED,EAAAA,IAAI,EAAE,OAAR;AAAiBC,EAAAA,IAAI,EAAE;AAAvB,CAHmB,EAInB;AAAED,EAAAA,IAAI,EAAE,QAAR;AAAkBC,EAAAA,IAAI,EAAE;AAAxB,CAJmB,EAKnB;AAAED,EAAAA,IAAI,EAAE,SAAR;AAAmBC,EAAAA,IAAI,EAAE;AAAzB,CALmB,CAArB;;SAQeE,U;;;;;yEAAf,iBAA0BC,MAA1B,EAAkCC,MAAlC,EAA0CC,OAA1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACqBF,MAAM,CAACG,UAAP,EADrB;;AAAA;AACMC,YAAAA,MADN;;AAAA,kBAGMA,MAAM,CAACC,WAAP,OAAyBH,OAAO,CAACI,MAAR,CAAeD,WAAf,EAH/B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,kBAOMH,OAAO,CAACK,KAAR,KAAkBC,SAPxB;AAAA;AAAA;AAAA;;AAQQC,YAAAA,QARR,GAQmB,CAAC,qDAAD,CARnB;AAUQC,YAAAA,aAVR,GAUwB,IAAIjB,MAAM,CAACkB,QAAX,CAAoBV,MAAM,CAACW,iBAA3B,EAA8CH,QAA9C,EAAwDT,MAAxD,CAVxB;AAAA;AAAA,mBAYsBU,aAAa,CAACG,MAAd,CAAqBT,MAArB,CAZtB;;AAAA;AAYQG,YAAAA,KAZR;AAcIL,YAAAA,OAAO,mCAAQA,OAAR;AAAiBK,cAAAA,KAAK,EAAEA,KAAK,CAACO,QAAN;AAAxB,cAAP;;AAdJ;AAiBMC,YAAAA,SAjBN,GAiBkB;AACdC,cAAAA,KAAK,EAAE;AACLC,gBAAAA,YAAY,EAAEtB,YADT;AAELuB,gBAAAA,MAAM,EAAEpB;AAFH,eADO;AAKdqB,cAAAA,WAAW,EAAE,QALC;AAMdlB,cAAAA,MAAM,EAANA,MANc;AAOdC,cAAAA,OAAO,EAAPA;AAPc,aAjBlB;AAAA;AAAA,mBA2BoBF,MAAM,CAACoB,QAAP,CAAgBC,IAAhB,CAAqB,sBAArB,EAA6C,CAACjB,MAAD,EAASkB,IAAI,CAACC,SAAL,CAAeR,SAAf,CAAT,CAA7C,CA3BpB;;AAAA;AA2BQS,YAAAA,GA3BR;AAAA,6CA6BS;AAAEvB,cAAAA,MAAM,EAANA,MAAF;AAAUC,cAAAA,OAAO,EAAPA,OAAV;AAAmBsB,cAAAA,GAAG,EAAHA;AAAnB,aA7BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAgCAC,MAAM,CAACC,OAAP,GAAiB;AACf3B,EAAAA,UAAU,EAAVA;AADe,CAAjB","sourcesContent":["const ethers = require('ethers')\n\nconst domainSchema = [\n  { name: \"name\", type: \"string\" },\n  { name: \"version\", type: \"string\" },\n  { name: \"chainId\", type: \"uint256\" },\n  { name: \"verifyingContract\", type: \"address\" },\n];\n\nconst permitSchema = [\n  { name: \"holder\", type: \"address\" },\n  { name: \"spender\", type: \"address\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"expiry\", type: \"uint256\" },\n  { name: \"allowed\", type: \"bool\" },\n];\n\nasync function signPermit(signer, domain, message) {\n  let myAddr = await signer.getAddress();\n\n  if (myAddr.toLowerCase() !== message.holder.toLowerCase()) {\n    throw (`signPermit: address of signer does not match holder address in message`);\n  }\n\n  if (message.nonce === undefined) {\n    let tokenAbi = ['function nonces(address holder) view returns (uint)',];\n\n    let tokenContract = new ethers.Contract(domain.verifyingContract, tokenAbi, signer);\n\n    let nonce = await tokenContract.nonces(myAddr);\n\n    message = { ...message, nonce: nonce.toString(), };\n  }\n\n  let typedData = {\n    types: {\n      EIP712Domain: domainSchema,\n      Permit: permitSchema,\n    },\n    primaryType: \"Permit\",\n    domain,\n    message,\n  };\n\n  const sig = await signer.provider.send(\"eth_signTypedData_v3\", [myAddr, JSON.stringify(typedData)])\n\n  return { domain, message, sig, };\n}\n\nmodule.exports = {\n  signPermit\n}\n"]},"metadata":{},"sourceType":"script"}