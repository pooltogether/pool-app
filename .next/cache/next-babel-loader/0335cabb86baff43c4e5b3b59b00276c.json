{"ast":null,"code":"import { batch, contract } from '@pooltogether/etherplex';\nimport { ethers } from 'ethers';\nimport CTokenAbi from '@pooltogether/pooltogether-contracts/abis/CTokenInterface';\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool';\nimport SingleRandomWinnerAbi from '@pooltogether/pooltogether-contracts/abis/SingleRandomWinner';\n\nconst debug = require('debug')('pool-app:fetchGenericChainData');\n\nexport const fetchGenericChainData = async ({\n  provider,\n  poolData\n}) => {\n  const poolAddress = poolData.poolAddress;\n  const prizeStrategyAddress = poolData.prizeStrategy.id;\n  const cTokenAddress = poolData.compoundPrizePool.cToken;\n\n  try {\n    const etherplexPrizeStrategyContract = contract('prizeStrategy', SingleRandomWinnerAbi, prizeStrategyAddress);\n    const etherplexCTokenContract = contract('cToken', CTokenAbi, cTokenAddress);\n    const etherplexPrizePoolContract = contract('prizePool', PrizePoolAbi, poolAddress);\n    const values = await batch(provider, etherplexPrizeStrategyContract.isRngRequested() // used to determine if the pool is locked\n    .isRngCompleted().canStartAward().canCompleteAward().prizePeriodRemainingSeconds().estimateRemainingBlocksToPrize(ethers.utils.parseEther('14')), etherplexCTokenContract.decimals().supplyRatePerBlock(), etherplexPrizePoolContract.captureAwardBalance());\n    return {\n      awardBalance: values.prizePool.captureAwardBalance[0],\n      isRngRequested: values.prizeStrategy.isRngRequested[0],\n      isRngCompleted: values.prizeStrategy.isRngCompleted[0],\n      // do we need this?\n      canStartAward: values.prizeStrategy.canStartAward[0],\n      canCompleteAward: values.prizeStrategy.canCompleteAward[0],\n      supplyRatePerBlock: values.cToken.supplyRatePerBlock[0],\n      prizePeriodRemainingSeconds: values.prizeStrategy.prizePeriodRemainingSeconds[0],\n      estimateRemainingBlocksToPrize: values.prizeStrategy.estimateRemainingBlocksToPrize[0],\n      loading: false\n    };\n  } catch (e) {\n    throw {\n      name: 'fetchGenericChainData Error',\n      message: `Error from Infura was: ${e.message}`\n    };\n  }\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchGenericChainData.js"],"names":["batch","contract","ethers","CTokenAbi","PrizePoolAbi","SingleRandomWinnerAbi","debug","require","fetchGenericChainData","provider","poolData","poolAddress","prizeStrategyAddress","prizeStrategy","id","cTokenAddress","compoundPrizePool","cToken","etherplexPrizeStrategyContract","etherplexCTokenContract","etherplexPrizePoolContract","values","isRngRequested","isRngCompleted","canStartAward","canCompleteAward","prizePeriodRemainingSeconds","estimateRemainingBlocksToPrize","utils","parseEther","decimals","supplyRatePerBlock","captureAwardBalance","awardBalance","prizePool","loading","e","name","message"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,QAAhB,QAAgC,yBAAhC;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,OAAOC,SAAP,MAAsB,2DAAtB;AACA,OAAOC,YAAP,MAAyB,qDAAzB;AACA,OAAOC,qBAAP,MAAkC,8DAAlC;;AAEA,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,gCAAjB,CAAd;;AAEA,OAAO,MAAMC,qBAAqB,GAAG,OAAO;AAC1CC,EAAAA,QAD0C;AAE1CC,EAAAA;AAF0C,CAAP,KAG/B;AACJ,QAAMC,WAAW,GAAGD,QAAQ,CAACC,WAA7B;AACA,QAAMC,oBAAoB,GAAGF,QAAQ,CAACG,aAAT,CAAuBC,EAApD;AACA,QAAMC,aAAa,GAAGL,QAAQ,CAACM,iBAAT,CAA2BC,MAAjD;;AAEA,MAAI;AACF,UAAMC,8BAA8B,GAAGjB,QAAQ,CAC7C,eAD6C,EAE7CI,qBAF6C,EAG7CO,oBAH6C,CAA/C;AAKA,UAAMO,uBAAuB,GAAGlB,QAAQ,CACtC,QADsC,EAEtCE,SAFsC,EAGtCY,aAHsC,CAAxC;AAKA,UAAMK,0BAA0B,GAAGnB,QAAQ,CACzC,WADyC,EAEzCG,YAFyC,EAGzCO,WAHyC,CAA3C;AAOA,UAAMU,MAAM,GAAG,MAAMrB,KAAK,CACxBS,QADwB,EAExBS,8BAA8B,CAC3BI,cADH,GACoB;AADpB,KAEGC,cAFH,GAGGC,aAHH,GAIGC,gBAJH,GAKGC,2BALH,GAMGC,8BANH,CAMkCzB,MAAM,CAAC0B,KAAP,CAAaC,UAAb,CAAwB,IAAxB,CANlC,CAFwB,EASxBV,uBAAuB,CACpBW,QADH,GAEGC,kBAFH,EATwB,EAYxBX,0BAA0B,CACvBY,mBADH,EAZwB,CAA1B;AAgBA,WAAO;AACLC,MAAAA,YAAY,EAAEZ,MAAM,CAACa,SAAP,CAAiBF,mBAAjB,CAAqC,CAArC,CADT;AAELV,MAAAA,cAAc,EAAED,MAAM,CAACR,aAAP,CAAqBS,cAArB,CAAoC,CAApC,CAFX;AAGLC,MAAAA,cAAc,EAAEF,MAAM,CAACR,aAAP,CAAqBU,cAArB,CAAoC,CAApC,CAHX;AAGmD;AACxDC,MAAAA,aAAa,EAAEH,MAAM,CAACR,aAAP,CAAqBW,aAArB,CAAmC,CAAnC,CAJV;AAKLC,MAAAA,gBAAgB,EAAEJ,MAAM,CAACR,aAAP,CAAqBY,gBAArB,CAAsC,CAAtC,CALb;AAMLM,MAAAA,kBAAkB,EAAEV,MAAM,CAACJ,MAAP,CAAcc,kBAAd,CAAiC,CAAjC,CANf;AAOLL,MAAAA,2BAA2B,EAAEL,MAAM,CAACR,aAAP,CAAqBa,2BAArB,CAAiD,CAAjD,CAPxB;AAQLC,MAAAA,8BAA8B,EAAEN,MAAM,CAACR,aAAP,CAAqBc,8BAArB,CAAoD,CAApD,CAR3B;AASLQ,MAAAA,OAAO,EAAE;AATJ,KAAP;AAWD,GA7CD,CA6CE,OAAOC,CAAP,EAAU;AACV,UAAM;AACJC,MAAAA,IAAI,EAAE,6BADF;AAEJC,MAAAA,OAAO,EAAG,0BAAyBF,CAAC,CAACE,OAAQ;AAFzC,KAAN;AAID;AACF,CA3DM","sourcesContent":["import { batch, contract } from '@pooltogether/etherplex'\nimport { ethers } from 'ethers'\n\nimport CTokenAbi from '@pooltogether/pooltogether-contracts/abis/CTokenInterface'\nimport PrizePoolAbi from '@pooltogether/pooltogether-contracts/abis/PrizePool'\nimport SingleRandomWinnerAbi from '@pooltogether/pooltogether-contracts/abis/SingleRandomWinner'\n\nconst debug = require('debug')('pool-app:fetchGenericChainData')\n\nexport const fetchGenericChainData = async ({\n  provider,\n  poolData\n}) => {\n  const poolAddress = poolData.poolAddress\n  const prizeStrategyAddress = poolData.prizeStrategy.id\n  const cTokenAddress = poolData.compoundPrizePool.cToken\n\n  try {\n    const etherplexPrizeStrategyContract = contract(\n      'prizeStrategy',\n      SingleRandomWinnerAbi,\n      prizeStrategyAddress\n    )\n    const etherplexCTokenContract = contract(\n      'cToken',\n      CTokenAbi,\n      cTokenAddress\n    )\n    const etherplexPrizePoolContract = contract(\n      'prizePool',\n      PrizePoolAbi,\n      poolAddress\n    )\n\n\n    const values = await batch(\n      provider,\n      etherplexPrizeStrategyContract\n        .isRngRequested() // used to determine if the pool is locked\n        .isRngCompleted()\n        .canStartAward()\n        .canCompleteAward()\n        .prizePeriodRemainingSeconds()\n        .estimateRemainingBlocksToPrize(ethers.utils.parseEther('14')),\n      etherplexCTokenContract\n        .decimals()\n        .supplyRatePerBlock(),\n      etherplexPrizePoolContract\n        .captureAwardBalance()\n    )\n\n    return {\n      awardBalance: values.prizePool.captureAwardBalance[0],\n      isRngRequested: values.prizeStrategy.isRngRequested[0],\n      isRngCompleted: values.prizeStrategy.isRngCompleted[0], // do we need this?\n      canStartAward: values.prizeStrategy.canStartAward[0],\n      canCompleteAward: values.prizeStrategy.canCompleteAward[0],\n      supplyRatePerBlock: values.cToken.supplyRatePerBlock[0],\n      prizePeriodRemainingSeconds: values.prizeStrategy.prizePeriodRemainingSeconds[0],\n      estimateRemainingBlocksToPrize: values.prizeStrategy.estimateRemainingBlocksToPrize[0],\n      loading: false,\n    }\n  } catch (e) {\n    throw {\n      name: 'fetchGenericChainData Error',\n      message: `Error from Infura was: ${e.message}`\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}