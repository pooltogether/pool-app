{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { useContext, useEffect, useState } from 'react';\nimport { ethers } from 'ethers';\nimport { MAINNET_POLLING_INTERVAL } from 'lib/constants';\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider';\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider';\nimport { fetchExitFees } from 'lib/utils/fetchExitFees';\nimport { useInterval } from 'lib/hooks/useInterval';\nexport function useExitFees(quantity) {\n  _s();\n\n  var _pool$prizeStrategy, _pool$prizeStrategy$s, _pool$prizeStrategy$s2;\n\n  var _useContext = useContext(AuthControllerContext),\n      pauseQueries = _useContext.pauseQueries,\n      usersAddress = _useContext.usersAddress,\n      networkName = _useContext.networkName;\n\n  var _useContext2 = useContext(PoolDataContext),\n      pool = _useContext2.pool;\n\n  var poolAddress = pool === null || pool === void 0 ? void 0 : pool.poolAddress;\n  var ticketAddress = pool === null || pool === void 0 ? void 0 : (_pool$prizeStrategy = pool.prizeStrategy) === null || _pool$prizeStrategy === void 0 ? void 0 : (_pool$prizeStrategy$s = _pool$prizeStrategy.singleRandomWinner) === null || _pool$prizeStrategy$s === void 0 ? void 0 : (_pool$prizeStrategy$s2 = _pool$prizeStrategy$s.ticket) === null || _pool$prizeStrategy$s2 === void 0 ? void 0 : _pool$prizeStrategy$s2.id;\n\n  var _useState = useState({}),\n      exitFees = _useState[0],\n      setExitFees = _useState[1];\n\n  var underlyingCollateralDecimals = 18;\n  underlyingCollateralDecimals = pool && pool.underlyingCollateralDecimals;\n\n  var getFees = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var quantityBN, result;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              quantityBN = ethers.utils.parseUnits(quantity, Number(underlyingCollateralDecimals));\n              _context.next = 3;\n              return fetchExitFees(networkName, usersAddress, poolAddress, ticketAddress, quantityBN);\n\n            case 3:\n              result = _context.sent;\n              setExitFees(result);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function getFees() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  useInterval(function () {\n    getFees();\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL);\n  useEffect(function () {\n    var ready = quantity && usersAddress && networkName && ticketAddress && poolAddress && networkName;\n\n    if (ready) {\n      getFees();\n    } // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n\n  }, [quantity, usersAddress, networkName, ticketAddress, poolAddress, networkName]);\n  return {\n    exitFees: exitFees\n  };\n}\n\n_s(useExitFees, \"Ab86PD3CBLQVN8wpOaDbytSTYzE=\", false, function () {\n  return [useInterval];\n});","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/hooks/useExitFees.jsx"],"names":["useContext","useEffect","useState","ethers","MAINNET_POLLING_INTERVAL","AuthControllerContext","PoolDataContext","fetchExitFees","useInterval","useExitFees","quantity","pauseQueries","usersAddress","networkName","pool","poolAddress","ticketAddress","prizeStrategy","singleRandomWinner","ticket","id","exitFees","setExitFees","underlyingCollateralDecimals","getFees","quantityBN","utils","parseUnits","Number","result","ready"],"mappings":";;;;;AAAA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,QAAhC,QAAgD,OAAhD;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,SACEC,wBADF,QAEO,eAFP;AAGA,SAASC,qBAAT,QAAsC,+DAAtC;AACA,SAASC,eAAT,QAAgC,yDAAhC;AACA,SAASC,aAAT,QAA8B,yBAA9B;AACA,SAASC,WAAT,QAA4B,uBAA5B;AAEA,OAAO,SAASC,WAAT,CAAqBC,QAArB,EAA+B;AAAA;;AAAA;;AAAA,oBACgBV,UAAU,CAACK,qBAAD,CAD1B;AAAA,MAC5BM,YAD4B,eAC5BA,YAD4B;AAAA,MACdC,YADc,eACdA,YADc;AAAA,MACAC,WADA,eACAA,WADA;;AAAA,qBAEnBb,UAAU,CAACM,eAAD,CAFS;AAAA,MAE5BQ,IAF4B,gBAE5BA,IAF4B;;AAIpC,MAAMC,WAAW,GAAGD,IAAH,aAAGA,IAAH,uBAAGA,IAAI,CAAEC,WAA1B;AACA,MAAMC,aAAa,GAAGF,IAAH,aAAGA,IAAH,8CAAGA,IAAI,CAAEG,aAAT,iFAAG,oBAAqBC,kBAAxB,oFAAG,sBAAyCC,MAA5C,2DAAG,uBAAiDC,EAAvE;;AALoC,kBAOJlB,QAAQ,CAAC,EAAD,CAPJ;AAAA,MAO7BmB,QAP6B;AAAA,MAOnBC,WAPmB;;AASpC,MAAIC,4BAA4B,GAAG,EAAnC;AACAA,EAAAA,4BAA4B,GAAGT,IAAI,IAAIA,IAAI,CAACS,4BAA5C;;AAEA,MAAMC,OAAO;AAAA,wEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACRC,cAAAA,UADQ,GACKtB,MAAM,CAACuB,KAAP,CAAaC,UAAb,CACjBjB,QADiB,EAEjBkB,MAAM,CAACL,4BAAD,CAFW,CADL;AAAA;AAAA,qBAMOhB,aAAa,CAChCM,WADgC,EAEhCD,YAFgC,EAGhCG,WAHgC,EAIhCC,aAJgC,EAKhCS,UALgC,CANpB;;AAAA;AAMRI,cAAAA,MANQ;AAcdP,cAAAA,WAAW,CAACO,MAAD,CAAX;;AAdc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAH;;AAAA,oBAAPL,OAAO;AAAA;AAAA;AAAA,KAAb;;AAiBAhB,EAAAA,WAAW,CAAC,YAAM;AAChBgB,IAAAA,OAAO;AACR,GAFU,EAERb,YAAY,GAAG,IAAH,GAAUP,wBAFd,CAAX;AAIAH,EAAAA,SAAS,CAAC,YAAM;AACd,QAAM6B,KAAK,GAAGpB,QAAQ,IAAIE,YAAZ,IAA4BC,WAA5B,IAA2CG,aAA3C,IAA4DD,WAA5D,IAA2EF,WAAzF;;AACA,QAAIiB,KAAJ,EAAW;AACTN,MAAAA,OAAO;AACR,KAJa,CAKd;;AACD,GANQ,EAMN,CACDd,QADC,EAEDE,YAFC,EAGDC,WAHC,EAIDG,aAJC,EAKDD,WALC,EAMDF,WANC,CANM,CAAT;AAeA,SAAO;AAAEQ,IAAAA,QAAQ,EAARA;AAAF,GAAP;AACD;;GAjDeZ,W;UA6BdD,W","sourcesContent":["import { useContext, useEffect, useState } from 'react'\nimport { ethers } from 'ethers'\n\nimport {\n  MAINNET_POLLING_INTERVAL\n} from 'lib/constants'\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider'\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider'\nimport { fetchExitFees } from 'lib/utils/fetchExitFees'\nimport { useInterval } from 'lib/hooks/useInterval'\n\nexport function useExitFees(quantity) {\n  const { pauseQueries, usersAddress, networkName } = useContext(AuthControllerContext)\n  const { pool } = useContext(PoolDataContext)\n\n  const poolAddress = pool?.poolAddress\n  const ticketAddress = pool?.prizeStrategy?.singleRandomWinner?.ticket?.id\n\n  const [exitFees, setExitFees] = useState({})\n \n  let underlyingCollateralDecimals = 18\n  underlyingCollateralDecimals = pool && pool.underlyingCollateralDecimals\n\n  const getFees = async () => {\n    const quantityBN = ethers.utils.parseUnits(\n      quantity,\n      Number(underlyingCollateralDecimals)\n    )\n\n    const result = await fetchExitFees(\n      networkName,\n      usersAddress,\n      poolAddress,\n      ticketAddress,\n      quantityBN\n    )\n\n    setExitFees(result)\n  }\n\n  useInterval(() => {\n    getFees()\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL)\n\n  useEffect(() => {\n    const ready = quantity && usersAddress && networkName && ticketAddress && poolAddress && networkName\n    if (ready) {\n      getFees()\n    }\n    // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [\n    quantity,\n    usersAddress,\n    networkName,\n    ticketAddress,\n    poolAddress,\n    networkName\n  ])\n  \n  return { exitFees }\n}\n"]},"metadata":{},"sourceType":"module"}