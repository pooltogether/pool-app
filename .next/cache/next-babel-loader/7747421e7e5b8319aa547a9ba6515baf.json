{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { batch, contract } from '@pooltogether/etherplex';\nimport ERC721Abi from 'lib/../abis/CustomERC721';\nimport { axiosInstance } from 'lib/axiosInstance';\n\nconst debug = require('debug')('pool-app:fetchExternalErc721Awards');\n\nconst _tryMetadataMethod = async (provider, contractAddress, etherplexTokenContract, tokenId, method) => {\n  let tokenValues;\n\n  try {\n    tokenValues = await batch(provider, etherplexTokenContract[method](tokenId));\n    debug(tokenValues);\n    return tokenValues[contractAddress][method][0];\n  } catch (e) {\n    // console.error(e)\n    debug(`NFT with tokenId ${tokenId} likely does not support metadata using method: ${method}():`, e.message);\n  }\n};\n\nexport const fetchExternalErc721Awards = async ({\n  provider,\n  graphErc721Awards,\n  poolAddress\n}) => {\n  const batchCalls = [];\n  let awards = {};\n  let etherplexTokenContract;\n  let values, tokenValues;\n  let i, j; // Prepare batched calls\n\n  for (i = 0; i < (graphErc721Awards === null || graphErc721Awards === void 0 ? void 0 : graphErc721Awards.length); i++) {\n    const award = _objectSpread(_objectSpread({}, graphErc721Awards[i]), {}, {\n      tokens: {}\n    });\n\n    const erc721Address = award.address;\n    etherplexTokenContract = contract(erc721Address, ERC721Abi, erc721Address);\n    batchCalls.push(etherplexTokenContract.balanceOf(poolAddress).name().symbol()); // TODO: split up the batching so we can query if metadata is supported by each NFT\n    //       or better yet, store the check to see if tokenURI/tokenMetadata is implemented on the Subgraph\n\n    for (j = 0; j < ((_award$tokenIds = award.tokenIds) === null || _award$tokenIds === void 0 ? void 0 : _award$tokenIds.length); j++) {\n      var _award$tokenIds;\n\n      const tokenId = award.tokenIds[j];\n      let tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenURI');\n\n      if (!tokenURI) {\n        tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenMetadata');\n      }\n\n      award.tokens[tokenId] = {\n        tokenURI\n      };\n    }\n\n    awards[award.address] = award;\n  } // Execute batched calls\n\n\n  values = await batch(provider, ...batchCalls); // Map batch call results to erc721 data and get metadata\n\n  for (i = 0; i < (graphErc721Awards === null || graphErc721Awards === void 0 ? void 0 : graphErc721Awards.length); i++) {\n    const address = graphErc721Awards[i].address;\n    const award = awards[address];\n    awards[address] = _objectSpread(_objectSpread({}, award), {}, {\n      tokens: awards[address].tokens,\n      name: values[address].name[0],\n      symbol: values[address].symbol[0],\n      balance: values[address].balanceOf[0]\n    });\n\n    for (j = 0; j < ((_award$tokenIds2 = award.tokenIds) === null || _award$tokenIds2 === void 0 ? void 0 : _award$tokenIds2.length); j++) {\n      var _award$tokenIds2;\n\n      const tokenId = award.tokenIds[j];\n      const tokenURI = award.tokens[tokenId].tokenURI;\n\n      if (!tokenURI) {\n        continue;\n      }\n\n      debug(tokenURI);\n\n      if (tokenURI.indexOf('http://') == 0 || tokenURI.indexOf('https://') == 0) {\n        try {\n          // bypass CORS\n          const proxyUrl = 'https://cors-anywhere.herokuapp.com/',\n                targetUrl = tokenURI;\n          const response = await axiosInstance.get(proxyUrl + targetUrl);\n\n          if (response.status < 305) {\n            const data = response.data;\n            award.tokens[tokenId] = _objectSpread(_objectSpread({}, award.tokens[tokenId]), data);\n          }\n        } catch (e) {\n          console.error('error while fetching 721 with tokenURI', tokenURI);\n          console.error(e);\n        }\n      }\n    }\n  }\n\n  debug(awards);\n  return awards;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchExternalErc721Awards.js"],"names":["batch","contract","ERC721Abi","axiosInstance","debug","require","_tryMetadataMethod","provider","contractAddress","etherplexTokenContract","tokenId","method","tokenValues","e","message","fetchExternalErc721Awards","graphErc721Awards","poolAddress","batchCalls","awards","values","i","j","length","award","tokens","erc721Address","address","push","balanceOf","name","symbol","tokenIds","tokenURI","balance","indexOf","proxyUrl","targetUrl","response","get","status","data","console","error"],"mappings":"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","sourcesContent":["import { batch, contract } from '@pooltogether/etherplex'\n\nimport ERC721Abi from 'lib/../abis/CustomERC721'\n\nimport { axiosInstance } from 'lib/axiosInstance'\n\nconst debug = require('debug')('pool-app:fetchExternalErc721Awards')\n\nconst _tryMetadataMethod = async (provider, contractAddress, etherplexTokenContract, tokenId, method) => {\n  let tokenValues\n\n  try {\n    tokenValues = await batch(\n      provider,\n      etherplexTokenContract[method](tokenId)\n    )\n    debug(tokenValues)\n\n    return tokenValues[contractAddress][method][0]\n  } catch (e) {\n    // console.error(e)\n    debug(`NFT with tokenId ${tokenId} likely does not support metadata using method: ${method}():`, e.message)\n  }\n}\n\nexport const fetchExternalErc721Awards = async ({\n  provider,\n  graphErc721Awards,\n  poolAddress,\n}) => {\n  const batchCalls = []\n\n  let awards = {}\n  let etherplexTokenContract\n  let values, tokenValues\n  let i, j\n\n  // Prepare batched calls\n  for (i = 0; i < graphErc721Awards?.length; i++) {\n    const award = {\n      ...graphErc721Awards[i],\n      tokens: {}\n    } \n    const erc721Address = award.address\n\n    etherplexTokenContract = contract(erc721Address, ERC721Abi, erc721Address)\n\n    batchCalls.push(\n      etherplexTokenContract\n        .balanceOf(poolAddress)\n        .name()\n        .symbol()\n    )\n\n\n    // TODO: split up the batching so we can query if metadata is supported by each NFT\n    //       or better yet, store the check to see if tokenURI/tokenMetadata is implemented on the Subgraph\n    for (j = 0; j < award.tokenIds?.length; j++) {\n      const tokenId = award.tokenIds[j]\n\n      let tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenURI')\n\n      if (!tokenURI) {\n        tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenMetadata')\n      }\n\n      award.tokens[tokenId] = {\n        tokenURI\n      }\n    }\n\n    awards[award.address] = award\n  }\n\n    \n  // Execute batched calls\n  values = await batch(\n    provider,\n    ...batchCalls\n  )\n\n  // Map batch call results to erc721 data and get metadata\n  for (i = 0; i < graphErc721Awards?.length; i++) {\n    const address = graphErc721Awards[i].address\n\n    const award = awards[address]\n    \n    awards[address] = {\n      ...award,\n      tokens: awards[address].tokens,\n      name: values[address].name[0],\n      symbol: values[address].symbol[0],\n      balance: values[address].balanceOf[0],\n    }\n\n    for (j = 0; j < award.tokenIds?.length; j++) {\n      const tokenId = award.tokenIds[j]\n      const tokenURI = award.tokens[tokenId].tokenURI\n\n      if (!tokenURI) {\n        continue\n      }\n      debug(tokenURI)\n\n      if (tokenURI.indexOf('http://') == 0 || tokenURI.indexOf('https://') == 0) {\n        try {\n          // bypass CORS\n          const proxyUrl = 'https://cors-anywhere.herokuapp.com/',\n            targetUrl = tokenURI\n\n          const response = await axiosInstance.get(proxyUrl + targetUrl)\n\n          if (response.status < 305) {\n            const data = response.data\n\n            award.tokens[tokenId] = {\n              ...award.tokens[tokenId],\n              ...data\n            }\n          }\n        } catch (e) {\n          console.error('error while fetching 721 with tokenURI', tokenURI)\n          console.error(e)\n        }\n      }\n    }\n  }\n  debug(awards)\n\n  return awards\n}\n"]},"metadata":{},"sourceType":"module"}