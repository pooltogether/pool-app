{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\nimport ComptrollerAbi from '@pooltogether/pooltogether-contracts/abis/Comptroller';\nimport { batch, contract } from '@pooltogether/etherplex';\nimport PoolV21Abi from 'lib/../abis/PoolV21Abi';\nimport PodAbi from 'lib/../abis/PodAbi';\nimport ERC20Abi from 'lib/../abis/ERC20Abi'; // import { DRIP_TOKENS } from 'lib/constants'\n\nconst _getUserPoolData = async (provider, usersAddress, pool, contractAddresses) => {\n  const {\n    underlyingCollateralToken,\n    poolAddress\n  } = pool;\n  const etherplexTokenContract = contract('token', ERC20Abi, underlyingCollateralToken);\n  const values = await batch(provider, etherplexTokenContract.balanceOf(usersAddress).allowance(usersAddress, poolAddress)); // OPTIMIZE: we can improve on this by batching in the same call above if we can figure out how to\n  // conditionally query depending on if we have a permitContract\n  // let daiPermitValues = {}\n  // const { daiPermitContract } = contractAddresses\n  // if (daiPermitContract) {\n  //   daiPermitValues = await batch(\n  //     provider,\n  //     etherplexTokenContract\n  //       .allowance(usersAddress, daiPermitContract)\n  //   )\n  // }\n\n  return {\n    // usersDaiPermitAllowance: daiPermitValues?.token?.allowance[0],\n    usersTokenAllowance: values.token.allowance[0],\n    usersTokenBalance: values.token.balanceOf[0]\n  };\n};\n\nconst _getUsersV2Data = async (provider, usersAddress, contractAddresses) => {\n  const chainId = provider.network.chainId;\n\n  if (chainId !== 1) {\n    return;\n  }\n\n  const etherplexV2DaiPoolContract = contract('v2DaiPool', PoolV21Abi, contractAddresses.v2DAIPool);\n  const etherplexV2UsdcPoolContract = contract('v2UsdcPool', PoolV21Abi, contractAddresses.v2USDCPool);\n  const etherplexV2DaiPodContract = contract('v2DaiPod', PodAbi, contractAddresses.v2DAIPod);\n  const etherplexV2UsdcPodContract = contract('v2UsdcPod', PodAbi, contractAddresses.v2USDCPod);\n  const values = await batch(provider, etherplexV2DaiPoolContract.committedBalanceOf(usersAddress).openBalanceOf(usersAddress), etherplexV2UsdcPoolContract.committedBalanceOf(usersAddress).openBalanceOf(usersAddress), etherplexV2DaiPodContract.balanceOfUnderlying(usersAddress).pendingDeposit(usersAddress).balanceOf(usersAddress), etherplexV2UsdcPodContract.balanceOfUnderlying(usersAddress).pendingDeposit(usersAddress).balanceOf(usersAddress));\n  return {\n    v2DaiPoolCommittedBalance: values.v2DaiPool.committedBalanceOf[0],\n    v2DaiPoolOpenBalance: values.v2DaiPool.openBalanceOf[0],\n    v2UsdcPoolCommittedBalance: values.v2UsdcPool.committedBalanceOf[0],\n    v2UsdcPoolOpenBalance: values.v2UsdcPool.openBalanceOf[0],\n    v2DaiPodCommittedBalance: values.v2DaiPod.balanceOfUnderlying[0],\n    v2DaiPodOpenBalance: values.v2DaiPod.pendingDeposit[0],\n    v2DaiPodSharesBalance: values.v2DaiPod.balanceOf[0],\n    v2UsdcPodCommittedBalance: values.v2UsdcPod.balanceOfUnderlying[0],\n    v2UsdcPodOpenBalance: values.v2UsdcPod.pendingDeposit[0],\n    v2UsdcPodSharesBalance: values.v2UsdcPod.balanceOf[0]\n  };\n};\n\nconst _getUserDripData = async (provider, comptrollerAddress, pairs, usersAddress, dripTokens) => {\n  try {\n    const etherplexComptrollerContract = contract('comptroller', ComptrollerAbi, comptrollerAddress);\n    const values = await batch(provider, etherplexComptrollerContract.updateDrips(pairs, usersAddress, dripTokens));\n    const usersDripBalances = values.comptroller.updateDrips[0];\n    const usersDripTokenData = await _getDripTokenData(provider, usersAddress, dripTokens, usersDripBalances);\n    return {\n      usersDripTokenData\n    };\n  } catch (e) {\n    console.warn(e.message); // console.error(e)\n\n    return {};\n  }\n};\n\nconst _getDripTokenData = async (provider, usersAddress, dripTokens, usersDripBalances) => {\n  const usersDripTokenData = {};\n  const batchCalls = [];\n  let etherplexTokenContract;\n  let dripTokenAddress;\n  let dripToken;\n  let values;\n  let i; // Prepare batched calls\n\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i];\n    etherplexTokenContract = contract(dripTokenAddress, ERC20Abi, dripTokenAddress);\n    batchCalls.push(etherplexTokenContract.balanceOf(usersAddress).name().symbol().decimals());\n  } // Execute batched calls\n\n\n  values = await batch(provider, ...batchCalls); // Map batch call results to drip token data\n\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i];\n    dripToken = dripTokens[dripTokenAddress];\n    const claimable = usersDripBalances.find(dripBalance => {\n      return dripBalance.dripToken.toLowerCase() === dripTokenAddress.toLowerCase();\n    }).balance;\n    usersDripTokenData[dripTokenAddress] = _objectSpread(_objectSpread({}, dripToken), {}, {\n      name: values[dripTokenAddress].name[0],\n      symbol: values[dripTokenAddress].symbol[0],\n      decimals: values[dripTokenAddress].decimals[0],\n      balance: values[dripTokenAddress].balanceOf[0],\n      claimable\n    });\n  }\n\n  return usersDripTokenData;\n};\n\nexport const fetchUsersChainData = async (provider, pool, comptrollerAddress, dripTokens, usersAddress, pairs, contractAddresses) => {\n  let userPoolData = {};\n  let usersV2Data = {};\n  let userDripData = {};\n\n  try {\n    // Get Balances of Drip Tokens\n    if (provider && usersAddress) {\n      if (comptrollerAddress && pairs && dripTokens) {\n        userDripData = await _getUserDripData(provider, comptrollerAddress, pairs, usersAddress, dripTokens);\n      } // Get Balances of Pool\n\n\n      if (pool) {\n        userPoolData = await _getUserPoolData(provider, usersAddress, pool, contractAddresses);\n      }\n\n      usersV2Data = await _getUsersV2Data(provider, usersAddress, contractAddresses);\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, userPoolData), userDripData), usersV2Data);\n  } catch (e) {\n    console.warn(e.message);\n    throw new Error(e);\n  }\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchUsersChainData.js"],"names":["ComptrollerAbi","batch","contract","PoolV21Abi","PodAbi","ERC20Abi","_getUserPoolData","provider","usersAddress","pool","contractAddresses","underlyingCollateralToken","poolAddress","etherplexTokenContract","values","balanceOf","allowance","usersTokenAllowance","token","usersTokenBalance","_getUsersV2Data","chainId","network","etherplexV2DaiPoolContract","v2DAIPool","etherplexV2UsdcPoolContract","v2USDCPool","etherplexV2DaiPodContract","v2DAIPod","etherplexV2UsdcPodContract","v2USDCPod","committedBalanceOf","openBalanceOf","balanceOfUnderlying","pendingDeposit","v2DaiPoolCommittedBalance","v2DaiPool","v2DaiPoolOpenBalance","v2UsdcPoolCommittedBalance","v2UsdcPool","v2UsdcPoolOpenBalance","v2DaiPodCommittedBalance","v2DaiPod","v2DaiPodOpenBalance","v2DaiPodSharesBalance","v2UsdcPodCommittedBalance","v2UsdcPod","v2UsdcPodOpenBalance","v2UsdcPodSharesBalance","_getUserDripData","comptrollerAddress","pairs","dripTokens","etherplexComptrollerContract","updateDrips","usersDripBalances","comptroller","usersDripTokenData","_getDripTokenData","e","console","warn","message","batchCalls","dripTokenAddress","dripToken","i","length","push","name","symbol","decimals","claimable","find","dripBalance","toLowerCase","balance","fetchUsersChainData","userPoolData","usersV2Data","userDripData","Error"],"mappings":"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","sourcesContent":["// import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\nimport ComptrollerAbi from '@pooltogether/pooltogether-contracts/abis/Comptroller'\nimport { batch, contract } from '@pooltogether/etherplex'\n\nimport PoolV21Abi from 'lib/../abis/PoolV21Abi'\nimport PodAbi from 'lib/../abis/PodAbi'\n\nimport ERC20Abi from 'lib/../abis/ERC20Abi'\n\n// import { DRIP_TOKENS } from 'lib/constants'\n\nconst _getUserPoolData = async (provider, usersAddress, pool, contractAddresses) => {\n  const {\n    underlyingCollateralToken,\n    poolAddress,\n  } = pool\n\n  const etherplexTokenContract = contract(\n    'token',\n    ERC20Abi,\n    underlyingCollateralToken\n  )\n\n  const values = await batch(\n    provider,\n    etherplexTokenContract\n      .balanceOf(usersAddress)\n      .allowance(usersAddress, poolAddress)\n  )\n  \n  // OPTIMIZE: we can improve on this by batching in the same call above if we can figure out how to\n  // conditionally query depending on if we have a permitContract\n  // let daiPermitValues = {}\n  // const { daiPermitContract } = contractAddresses\n  // if (daiPermitContract) {\n  //   daiPermitValues = await batch(\n  //     provider,\n  //     etherplexTokenContract\n  //       .allowance(usersAddress, daiPermitContract)\n  //   )\n  // }\n\n  return {\n    // usersDaiPermitAllowance: daiPermitValues?.token?.allowance[0],\n    usersTokenAllowance: values.token.allowance[0],\n    usersTokenBalance: values.token.balanceOf[0],\n  }\n}\n\nconst _getUsersV2Data = async (provider, usersAddress, contractAddresses) => {\n  const chainId = provider.network.chainId\n  if (chainId !== 1) {\n    return\n  }\n\n  const etherplexV2DaiPoolContract = contract(\n    'v2DaiPool',\n    PoolV21Abi,\n    contractAddresses.v2DAIPool\n  )\n  \n  const etherplexV2UsdcPoolContract = contract(\n    'v2UsdcPool',\n    PoolV21Abi,\n    contractAddresses.v2USDCPool\n  )\n\n  const etherplexV2DaiPodContract = contract(\n    'v2DaiPod',\n    PodAbi,\n    contractAddresses.v2DAIPod\n  )\n\n  const etherplexV2UsdcPodContract = contract(\n    'v2UsdcPod',\n    PodAbi,\n    contractAddresses.v2USDCPod\n  )\n\n  const values = await batch(\n    provider,\n    etherplexV2DaiPoolContract\n      .committedBalanceOf(usersAddress)\n      .openBalanceOf(usersAddress),\n    etherplexV2UsdcPoolContract\n      .committedBalanceOf(usersAddress)\n      .openBalanceOf(usersAddress),\n    etherplexV2DaiPodContract\n      .balanceOfUnderlying(usersAddress)\n      .pendingDeposit(usersAddress)\n      .balanceOf(usersAddress),\n    etherplexV2UsdcPodContract\n      .balanceOfUnderlying(usersAddress)\n      .pendingDeposit(usersAddress)\n      .balanceOf(usersAddress),\n  )\n\n  return {\n    v2DaiPoolCommittedBalance: values.v2DaiPool.committedBalanceOf[0],\n    v2DaiPoolOpenBalance: values.v2DaiPool.openBalanceOf[0],\n    v2UsdcPoolCommittedBalance: values.v2UsdcPool.committedBalanceOf[0],\n    v2UsdcPoolOpenBalance: values.v2UsdcPool.openBalanceOf[0],\n    v2DaiPodCommittedBalance: values.v2DaiPod.balanceOfUnderlying[0],\n    v2DaiPodOpenBalance: values.v2DaiPod.pendingDeposit[0],\n    v2DaiPodSharesBalance: values.v2DaiPod.balanceOf[0],\n    v2UsdcPodCommittedBalance: values.v2UsdcPod.balanceOfUnderlying[0],\n    v2UsdcPodOpenBalance: values.v2UsdcPod.pendingDeposit[0],\n    v2UsdcPodSharesBalance: values.v2UsdcPod.balanceOf[0],\n  }\n}\n\nconst _getUserDripData = async (provider, comptrollerAddress, pairs, usersAddress, dripTokens) => {\n  try {\n    const etherplexComptrollerContract = contract(\n      'comptroller',\n      ComptrollerAbi,\n      comptrollerAddress\n    )\n\n    const values = await batch(\n      provider,\n      etherplexComptrollerContract\n        .updateDrips(pairs, usersAddress, dripTokens)\n    )\n\n    const usersDripBalances = values.comptroller.updateDrips[0]\n    const usersDripTokenData = await _getDripTokenData(provider, usersAddress, dripTokens, usersDripBalances)\n\n    return {\n      usersDripTokenData\n    }\n  } catch (e) {\n    console.warn(e.message)\n    // console.error(e)\n    return {}\n  }\n  \n}\n\nconst _getDripTokenData = async (provider, usersAddress, dripTokens, usersDripBalances) => {\n  const usersDripTokenData = {}\n  const batchCalls = []\n\n  let etherplexTokenContract\n  let dripTokenAddress\n  let dripToken\n  let values\n  let i\n\n  // Prepare batched calls\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i]\n\n    etherplexTokenContract = contract(dripTokenAddress, ERC20Abi, dripTokenAddress)\n\n    batchCalls.push(\n      etherplexTokenContract\n        .balanceOf(usersAddress)\n        .name()\n        .symbol()\n        .decimals()\n    )\n  }\n\n  // Execute batched calls\n  values = await batch(\n    provider,\n    ...batchCalls\n  )\n\n  // Map batch call results to drip token data\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i]\n    dripToken = dripTokens[dripTokenAddress]\n\n    const claimable = usersDripBalances.find(dripBalance => {\n      return dripBalance.dripToken.toLowerCase() === dripTokenAddress.toLowerCase()\n    })\n      .balance\n\n    usersDripTokenData[dripTokenAddress] = {\n      ...dripToken,\n      name: values[dripTokenAddress].name[0],\n      symbol: values[dripTokenAddress].symbol[0],\n      decimals: values[dripTokenAddress].decimals[0],\n      balance: values[dripTokenAddress].balanceOf[0],\n      claimable,\n    }\n  }\n\n  return usersDripTokenData\n}\n\n\nexport const fetchUsersChainData = async (\n  provider,\n  pool,\n  comptrollerAddress,\n  dripTokens,\n  usersAddress,\n  pairs,\n  contractAddresses\n) => {\n  let userPoolData = {}\n  let usersV2Data = {}\n  let userDripData = {}\n\n  try {\n    // Get Balances of Drip Tokens\n    if (provider && usersAddress) {\n      if (comptrollerAddress && pairs && dripTokens) {\n        userDripData = await _getUserDripData(provider, comptrollerAddress, pairs, usersAddress, dripTokens)\n      }\n\n      // Get Balances of Pool\n      if (pool) {\n        userPoolData = await _getUserPoolData(provider, usersAddress, pool, contractAddresses)\n      }\n      \n      usersV2Data = await _getUsersV2Data(provider, usersAddress, contractAddresses)\n    }\n\n    return {\n      ...userPoolData,\n      ...userDripData,\n      ...usersV2Data,\n    }\n\n  } catch (e) {\n    console.warn(e.message)\n    throw new Error(e)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}