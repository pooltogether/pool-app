{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { request, gql } from 'graphql-request';\nimport { CONTRACT_ADDRESSES, UNISWAP_GRAPH_URIS } from 'lib/constants';\nconst QUERY_TEMPLATE = `token__num__: tokens(where: { id: \"__address__\" } __blockFilter__) {\n  id\n  derivedETH\n}`;\n\nconst _addStablecoin = (addresses, usdtAddress) => {\n  const usdt = addresses.find(address => usdtAddress === address);\n\n  if (!usdt) {\n    addresses.splice(0, 0, usdtAddress);\n  }\n\n  return addresses;\n};\n\nconst _getBlockFilter = blockNumber => {\n  let blockFilter = '';\n\n  if (blockNumber > 0) {\n    blockFilter = `, block: { number: ${blockNumber} }`;\n  }\n\n  return blockFilter;\n};\n\nconst _calculateUsd = token => {\n  let derivedETH = token === null || token === void 0 ? void 0 : token.derivedETH;\n\n  if (!derivedETH || derivedETH === '0') {\n    derivedETH = 0.2; // 1 ETH is $5 USD, used for Rinkeby, etc\n  }\n\n  return 1 / derivedETH;\n};\n\nexport const getUniswapData = async (chainId, addresses, blockNumber) => {\n  var _CONTRACT_ADDRESSES$c;\n\n  const blockFilter = _getBlockFilter(blockNumber); // We'll use this stablecoin to measure the price of ETH off of\n\n\n  const stablecoinAddress = (_CONTRACT_ADDRESSES$c = CONTRACT_ADDRESSES[chainId]) === null || _CONTRACT_ADDRESSES$c === void 0 ? void 0 : _CONTRACT_ADDRESSES$c['Usdt'];\n\n  _addStablecoin(addresses, stablecoinAddress); // build a query selection set from all the token addresses\n\n\n  let query = ``;\n\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i];\n    const selection = QUERY_TEMPLATE.replace('__num__', i).replace('__address__', address).replace('__blockFilter__', blockFilter);\n    query = `${query}\\n${selection}`;\n  }\n\n  const response = await request(UNISWAP_GRAPH_URIS[1], gql`\n      query uniswapTokensQuery {\n        ${query}\n      }\n    `); // unpack the data into a useful object \n\n  let data = {};\n\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i];\n    const token = response[`token${i}`][0];\n    data[address] = token;\n  } // calculate and cache the price of eth in the data object \n\n\n  data['ethereum'] = {\n    derivedETH: '1',\n    id: 'eth',\n    usd: _calculateUsd(data[stablecoinAddress])\n  }; // calculate the price of the token in USD\n\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i];\n    const token = data[address];\n\n    if (token) {\n      data[address] = _objectSpread(_objectSpread({}, token), {}, {\n        usd: data['ethereum'].usd * parseFloat(token.derivedETH)\n      });\n    }\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/fetchers/getUniswapData.js"],"names":["request","gql","CONTRACT_ADDRESSES","UNISWAP_GRAPH_URIS","QUERY_TEMPLATE","_addStablecoin","addresses","usdtAddress","usdt","find","address","splice","_getBlockFilter","blockNumber","blockFilter","_calculateUsd","token","derivedETH","getUniswapData","chainId","stablecoinAddress","query","i","length","selection","replace","response","data","id","usd","parseFloat"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\n\nimport { CONTRACT_ADDRESSES, UNISWAP_GRAPH_URIS } from 'lib/constants'\n\nconst QUERY_TEMPLATE = `token__num__: tokens(where: { id: \"__address__\" } __blockFilter__) {\n  id\n  derivedETH\n}`\n\nconst _addStablecoin = (addresses, usdtAddress) => {\n  const usdt = addresses.find(address => usdtAddress === address)\n\n  if (!usdt) {\n    addresses.splice(0, 0, usdtAddress)\n  }\n\n  return addresses\n}\n\nconst _getBlockFilter = (blockNumber) => {\n  let blockFilter = ''\n\n  if (blockNumber > 0) {\n    blockFilter = `, block: { number: ${blockNumber} }`\n  }\n\n  return blockFilter\n}\n\nconst _calculateUsd = (token) => {\n  let derivedETH = token?.derivedETH\n\n  if (!derivedETH || derivedETH === '0') {\n    derivedETH = 0.2 // 1 ETH is $5 USD, used for Rinkeby, etc\n  }\n\n  return 1 / derivedETH\n}\n\nexport const getUniswapData = async (chainId, addresses, blockNumber) => {\n  const blockFilter = _getBlockFilter(blockNumber)\n\n  // We'll use this stablecoin to measure the price of ETH off of\n  const stablecoinAddress = CONTRACT_ADDRESSES[chainId]?.['Usdt']\n\n  _addStablecoin(\n    addresses,\n    stablecoinAddress,\n  )\n\n  // build a query selection set from all the token addresses\n  let query = ``\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n\n    const selection = QUERY_TEMPLATE\n      .replace('__num__', i)\n      .replace('__address__', address)\n      .replace('__blockFilter__', blockFilter)\n\n    query = `${query}\\n${selection}`\n  }\n\n  const response = await request(\n    UNISWAP_GRAPH_URIS[1],\n    gql`\n      query uniswapTokensQuery {\n        ${query}\n      }\n    `\n  )\n\n  // unpack the data into a useful object \n  let data = {}\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n    const token = response[`token${i}`][0]\n\n    data[address] = token\n  }\n\n  // calculate and cache the price of eth in the data object \n  data['ethereum'] = {\n    derivedETH: '1',\n    id: 'eth',\n    usd: _calculateUsd(data[stablecoinAddress])\n  }\n\n  // calculate the price of the token in USD\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n    const token = data[address]\n\n    if (token) {\n      data[address] = {\n        ...token,\n        usd: data['ethereum'].usd * parseFloat(token.derivedETH)\n      }\n    }\n  }\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}