{"ast":null,"code":"import { useContext, useEffect, useState } from 'react';\nimport { uniqWith, isEqual } from 'lodash';\nimport { MAINNET_POLLING_INTERVAL } from 'lib/constants';\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider';\nimport { useInterval } from 'lib/hooks/useInterval';\nimport { fetchUsersChainData } from 'lib/utils/fetchUsersChainData';\n\nconst debug = require('debug')('pool-app:FetchUsersChainData');\n\nexport function FetchUsersChainData(props) {\n  const {\n    children,\n    graphDripData,\n    pool,\n    provider,\n    usersAddress,\n    contractAddresses\n  } = props;\n  const {\n    pauseQueries\n  } = useContext(AuthControllerContext);\n  const poolAddress = pool === null || pool === void 0 ? void 0 : pool.poolAddress;\n  const {\n    0: usersChainData,\n    1: setUsersChainData\n  } = useState({});\n  let pairs = [];\n  let dripTokens = [];\n  let comptrollerAddress;\n\n  if (graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips) {\n    const balanceDripPairs = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips.map(drip => [drip.sourceAddress, drip.measureToken]);\n    const volumeDripPairs = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.volumeDrips.map(drip => [drip.sourceAddress, drip.measureToken]);\n    pairs = uniqWith(balanceDripPairs === null || balanceDripPairs === void 0 ? void 0 : balanceDripPairs.concat(volumeDripPairs), isEqual);\n    const balanceDripTokens = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips.map(drip => drip.dripToken);\n    const volumeDripTokens = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.volumeDrips.map(drip => drip.dripToken);\n    dripTokens = uniqWith(balanceDripTokens === null || balanceDripTokens === void 0 ? void 0 : balanceDripTokens.concat(volumeDripTokens), isEqual);\n\n    if (graphDripData.balanceDrips.length > 0) {\n      comptrollerAddress = graphDripData.balanceDrips[0].comptroller.id;\n    }\n  }\n\n  const fetchUsersDataFromInfura = async () => {\n    try {\n      const data = await fetchUsersChainData(provider, pool, comptrollerAddress, dripTokens, usersAddress, pairs, contractAddresses);\n      return data;\n    } catch (e) {\n      // error while fetching from infura?\n      console.warn(e);\n      return {};\n    }\n  };\n\n  const updateOrDelete = async () => {\n    if (usersAddress) {\n      const usersData = await fetchUsersDataFromInfura();\n      setUsersChainData(usersData);\n    } else {\n      setUsersChainData({});\n    }\n  };\n\n  useInterval(() => {\n    debug('fetching new users chain data after MAINNET_POLLING_INTERVAL expired', MAINNET_POLLING_INTERVAL);\n    updateOrDelete();\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL);\n  useEffect(() => {\n    updateOrDelete(); // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [poolAddress, usersAddress, comptrollerAddress]);\n  return children({\n    usersChainData\n  });\n}","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/components/FetchUsersChainData.jsx"],"names":["useContext","useEffect","useState","uniqWith","isEqual","MAINNET_POLLING_INTERVAL","AuthControllerContext","useInterval","fetchUsersChainData","debug","require","FetchUsersChainData","props","children","graphDripData","pool","provider","usersAddress","contractAddresses","pauseQueries","poolAddress","usersChainData","setUsersChainData","pairs","dripTokens","comptrollerAddress","balanceDrips","balanceDripPairs","map","drip","sourceAddress","measureToken","volumeDripPairs","volumeDrips","concat","balanceDripTokens","dripToken","volumeDripTokens","length","comptroller","id","fetchUsersDataFromInfura","data","e","console","warn","updateOrDelete","usersData"],"mappings":"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","sourcesContent":["import { useContext, useEffect, useState } from 'react'\nimport { uniqWith, isEqual } from 'lodash'\n\nimport {\n  MAINNET_POLLING_INTERVAL\n} from 'lib/constants'\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider'\nimport { useInterval } from 'lib/hooks/useInterval'\nimport { fetchUsersChainData } from 'lib/utils/fetchUsersChainData'\n\nconst debug = require('debug')('pool-app:FetchUsersChainData')\n\nexport function FetchUsersChainData(props) {\n  const {\n    children,\n    graphDripData,\n    pool,\n    provider,\n    usersAddress,\n    contractAddresses,\n  } = props\n\n  const { pauseQueries } = useContext(AuthControllerContext)\n\n  const poolAddress = pool?.poolAddress\n\n  const [usersChainData, setUsersChainData] = useState({})\n\n  let pairs = []\n  let dripTokens = []\n  let comptrollerAddress\n  if (graphDripData?.balanceDrips) {\n    const balanceDripPairs = graphDripData?.balanceDrips.map((drip) => [drip.sourceAddress, drip.measureToken])\n    const volumeDripPairs = graphDripData?.volumeDrips.map((drip) => [drip.sourceAddress, drip.measureToken])\n\n    pairs = uniqWith(balanceDripPairs?.concat(volumeDripPairs), isEqual)\n\n    const balanceDripTokens = graphDripData?.balanceDrips.map((drip) => drip.dripToken)\n    const volumeDripTokens = graphDripData?.volumeDrips.map((drip) => drip.dripToken)\n\n    dripTokens = uniqWith(balanceDripTokens?.concat(volumeDripTokens), isEqual)\n\n    if (graphDripData.balanceDrips.length > 0) {\n      comptrollerAddress = graphDripData.balanceDrips[0].comptroller.id\n    }\n  }\n\n  const fetchUsersDataFromInfura = async () => {\n    try {\n      const data = await fetchUsersChainData(\n        provider,\n        pool,\n        comptrollerAddress,\n        dripTokens,\n        usersAddress,\n        pairs,\n        contractAddresses,\n      )\n\n      return data\n    } catch (e) {\n      // error while fetching from infura?\n      console.warn(e)\n      return {}\n    }\n  }\n\n  const updateOrDelete = async () => {\n    if (usersAddress) {\n      const usersData = await fetchUsersDataFromInfura()\n      setUsersChainData(usersData)\n    } else {\n      setUsersChainData({})\n    }\n\n\n    \n  }\n\n\n  useInterval(() => {\n    debug('fetching new users chain data after MAINNET_POLLING_INTERVAL expired', MAINNET_POLLING_INTERVAL)\n    updateOrDelete()\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL)\n\n  useEffect(() => {\n    updateOrDelete()\n    // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [poolAddress, usersAddress, comptrollerAddress])\n\n  return children({ usersChainData })\n}\n"]},"metadata":{},"sourceType":"module"}