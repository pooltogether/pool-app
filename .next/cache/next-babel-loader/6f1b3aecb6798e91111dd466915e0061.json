{"ast":null,"code":"/**\n  Retrieves a new provider specific to read.  The reason we separate the read and the writes is that the\n  web3 providers on mobile dapps are extremely buggy; it's better to read the network through an INFURA\n  JsonRpc endpoint.\n\n  This function will first check to see if there is an injected web3.  If web3 is being injected, then a\n  Ethers Web3Provider is instantiated to check the network.  Once the network is determined the Ethers\n  getDefaultProvider function is used to create a provider pointing to the same network using an Infura node.\n*/\nimport { ethers } from 'ethers';\nconst providerCache = {};\nexport const readProvider = async function (networkName) {\n  let provider;\n\n  if (/local/.test(networkName)) {\n    provider = new ethers.providers.JsonRpcProvider();\n  } else {\n    provider = ethers.getDefaultProvider(networkName === 'mainnet' ? 'homestead' : networkName);\n  }\n\n  const net = await provider.getNetwork(); // If we're running against a known network\n\n  if (net && net.name !== 'unknown') {\n    if (!providerCache[net.name]) {\n      providerCache[net.name] = new ethers.providers.InfuraProvider(net.name, process.env.NEXT_JS_INFURA_KEY);\n    } // use a separate Infura-based provider for consistent read api\n\n\n    provider = providerCache[net.name];\n  }\n\n  return provider;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/services/readProvider.js"],"names":["ethers","providerCache","readProvider","networkName","provider","test","providers","JsonRpcProvider","getDefaultProvider","net","getNetwork","name","InfuraProvider","process","env","NEXT_JS_INFURA_KEY"],"mappings":"AAAA;;;;;;;;;AASA,SAASA,MAAT,QAAuB,QAAvB;AAEA,MAAMC,aAAa,GAAG,EAAtB;AAEA,OAAO,MAAMC,YAAY,GAAG,gBAAgBC,WAAhB,EAA6B;AACvD,MAAIC,QAAJ;;AAEA,MAAI,QAAQC,IAAR,CAAaF,WAAb,CAAJ,EAA+B;AAC7BC,IAAAA,QAAQ,GAAG,IAAIJ,MAAM,CAACM,SAAP,CAAiBC,eAArB,EAAX;AACD,GAFD,MAEO;AACLH,IAAAA,QAAQ,GAAGJ,MAAM,CAACQ,kBAAP,CACTL,WAAW,KAAK,SAAhB,GAA4B,WAA5B,GAA0CA,WADjC,CAAX;AAGD;;AAED,QAAMM,GAAG,GAAG,MAAML,QAAQ,CAACM,UAAT,EAAlB,CAXuD,CAavD;;AACA,MAAID,GAAG,IAAIA,GAAG,CAACE,IAAJ,KAAa,SAAxB,EAAmC;AACjC,QAAI,CAACV,aAAa,CAACQ,GAAG,CAACE,IAAL,CAAlB,EAA8B;AAC5BV,MAAAA,aAAa,CAACQ,GAAG,CAACE,IAAL,CAAb,GAA0B,IAAIX,MAAM,CAACM,SAAP,CAAiBM,cAArB,CACxBH,GAAG,CAACE,IADoB,EAExBE,OAAO,CAACC,GAAR,CAAYC,kBAFY,CAA1B;AAID,KANgC,CAQjC;;;AACAX,IAAAA,QAAQ,GAAGH,aAAa,CAACQ,GAAG,CAACE,IAAL,CAAxB;AACD;;AAED,SAAOP,QAAP;AACD,CA3BM","sourcesContent":["/**\n  Retrieves a new provider specific to read.  The reason we separate the read and the writes is that the\n  web3 providers on mobile dapps are extremely buggy; it's better to read the network through an INFURA\n  JsonRpc endpoint.\n\n  This function will first check to see if there is an injected web3.  If web3 is being injected, then a\n  Ethers Web3Provider is instantiated to check the network.  Once the network is determined the Ethers\n  getDefaultProvider function is used to create a provider pointing to the same network using an Infura node.\n*/\nimport { ethers } from 'ethers'\n\nconst providerCache = {}\n\nexport const readProvider = async function (networkName) {\n  let provider\n\n  if (/local/.test(networkName)) {\n    provider = new ethers.providers.JsonRpcProvider()\n  } else {\n    provider = ethers.getDefaultProvider(\n      networkName === 'mainnet' ? 'homestead' : networkName\n    )\n  }\n\n  const net = await provider.getNetwork()\n\n  // If we're running against a known network\n  if (net && net.name !== 'unknown') {\n    if (!providerCache[net.name]) {\n      providerCache[net.name] = new ethers.providers.InfuraProvider(\n        net.name,\n        process.env.NEXT_JS_INFURA_KEY\n      )\n    }\n\n    // use a separate Infura-based provider for consistent read api\n    provider = providerCache[net.name]\n  }\n\n  return provider\n}\n"]},"metadata":{},"sourceType":"module"}