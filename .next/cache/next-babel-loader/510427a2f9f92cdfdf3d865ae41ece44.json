{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { batch, contract } from '@pooltogether/etherplex';\nimport ERC20Abi from 'lib/../abis/ERC20Abi';\n\nconst debug = require('debug')('pool-app:fetchExternalErc20Awards');\n\nexport const fetchExternalErc20Awards = async ({\n  provider,\n  graphErc20Awards,\n  poolAddress\n}) => {\n  const poolsExternalErc20AwardsData = [];\n  const batchCalls = [];\n  let etherplexTokenContract;\n  let erc20Address;\n  let values;\n  let i;\n  const awards = graphErc20Awards === null || graphErc20Awards === void 0 ? void 0 : graphErc20Awards.map(award => award.address); // Prepare batched calls\n\n  for (i = 0; i < (awards === null || awards === void 0 ? void 0 : awards.length); i++) {\n    erc20Address = awards[i];\n    etherplexTokenContract = contract(erc20Address, ERC20Abi, erc20Address);\n    batchCalls.push(etherplexTokenContract.balanceOf(poolAddress));\n  } // Execute batched calls\n\n\n  values = await batch(provider, ...batchCalls); // Map batch call results to erc20 data\n\n  for (i = 0; i < (awards === null || awards === void 0 ? void 0 : awards.length); i++) {\n    erc20Address = awards[i];\n    etherplexTokenContract = awards[erc20Address];\n    const balance = values[erc20Address].balanceOf[0];\n    poolsExternalErc20AwardsData.push(_objectSpread(_objectSpread({}, etherplexTokenContract), {}, {\n      address: erc20Address,\n      balance\n    }));\n  }\n\n  return poolsExternalErc20AwardsData;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchExternalErc20Awards.js"],"names":["batch","contract","ERC20Abi","debug","require","fetchExternalErc20Awards","provider","graphErc20Awards","poolAddress","poolsExternalErc20AwardsData","batchCalls","etherplexTokenContract","erc20Address","values","i","awards","map","award","address","length","push","balanceOf","balance"],"mappings":";;;;;;AAAA,SAASA,KAAT,EAAgBC,QAAhB,QAAgC,yBAAhC;AAEA,OAAOC,QAAP,MAAqB,sBAArB;;AAEA,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,mCAAjB,CAAd;;AAEA,OAAO,MAAMC,wBAAwB,GAAG,OAAO;AAC7CC,EAAAA,QAD6C;AAE7CC,EAAAA,gBAF6C;AAG7CC,EAAAA;AAH6C,CAAP,KAIlC;AACJ,QAAMC,4BAA4B,GAAG,EAArC;AACA,QAAMC,UAAU,GAAG,EAAnB;AAEA,MAAIC,sBAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,CAAJ;AAEA,QAAMC,MAAM,GAAGR,gBAAH,aAAGA,gBAAH,uBAAGA,gBAAgB,CAAES,GAAlB,CAAsBC,KAAK,IAAIA,KAAK,CAACC,OAArC,CAAf,CATI,CAWJ;;AACA,OAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAGC,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEI,MAAX,CAAb,EAAgCL,CAAC,EAAjC,EAAqC;AACnCF,IAAAA,YAAY,GAAGG,MAAM,CAACD,CAAD,CAArB;AACAH,IAAAA,sBAAsB,GAAGV,QAAQ,CAACW,YAAD,EAAeV,QAAf,EAAyBU,YAAzB,CAAjC;AAEAF,IAAAA,UAAU,CAACU,IAAX,CACET,sBAAsB,CACnBU,SADH,CACab,WADb,CADF;AAID,GApBG,CAsBJ;;;AACAK,EAAAA,MAAM,GAAG,MAAMb,KAAK,CAClBM,QADkB,EAElB,GAAGI,UAFe,CAApB,CAvBI,CA4BJ;;AACA,OAAKI,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAGC,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEI,MAAX,CAAb,EAAgCL,CAAC,EAAjC,EAAqC;AACnCF,IAAAA,YAAY,GAAGG,MAAM,CAACD,CAAD,CAArB;AACAH,IAAAA,sBAAsB,GAAGI,MAAM,CAACH,YAAD,CAA/B;AAEA,UAAMU,OAAO,GAAGT,MAAM,CAACD,YAAD,CAAN,CAAqBS,SAArB,CAA+B,CAA/B,CAAhB;AAEAZ,IAAAA,4BAA4B,CAACW,IAA7B,iCACKT,sBADL;AAEEO,MAAAA,OAAO,EAAEN,YAFX;AAGEU,MAAAA;AAHF;AAKD;;AAED,SAAOb,4BAAP;AACD,CA/CM","sourcesContent":["import { batch, contract } from '@pooltogether/etherplex'\n\nimport ERC20Abi from 'lib/../abis/ERC20Abi'\n\nconst debug = require('debug')('pool-app:fetchExternalErc20Awards')\n\nexport const fetchExternalErc20Awards = async ({\n  provider,\n  graphErc20Awards,\n  poolAddress,\n}) => {\n  const poolsExternalErc20AwardsData = []\n  const batchCalls = []\n  \n  let etherplexTokenContract\n  let erc20Address\n  let values\n  let i\n  \n  const awards = graphErc20Awards?.map(award => award.address)\n\n  // Prepare batched calls\n  for (i = 0; i < awards?.length; i++) {\n    erc20Address = awards[i]\n    etherplexTokenContract = contract(erc20Address, ERC20Abi, erc20Address)\n\n    batchCalls.push(\n      etherplexTokenContract\n        .balanceOf(poolAddress)\n    )\n  }\n\n  // Execute batched calls\n  values = await batch(\n    provider,\n    ...batchCalls\n  )\n\n  // Map batch call results to erc20 data\n  for (i = 0; i < awards?.length; i++) {\n    erc20Address = awards[i]\n    etherplexTokenContract = awards[erc20Address]\n\n    const balance = values[erc20Address].balanceOf[0]\n\n    poolsExternalErc20AwardsData.push({\n      ...etherplexTokenContract,\n      address: erc20Address,\n      balance,\n    })\n  }\n\n  return poolsExternalErc20AwardsData\n}\n"]},"metadata":{},"sourceType":"module"}