{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useEffect, useState, useContext } from 'react';\nimport Cookies from 'js-cookie';\nimport { useRouter } from 'next/router';\nimport { ethers } from 'ethers'; // import { Magic, RPCError, RPCErrorCode } from 'magic-sdk'\n\nimport { COOKIE_OPTIONS, MAGIC_EMAIL } from 'lib/constants';\nimport { poolToast } from 'lib/utils/poolToast';\nexport const MagicContext = /*#__PURE__*/React.createContext();\nexport function MagicContextProvider(props) {\n  return __jsx(MagicContext.Provider, {\n    value: {\n      address,\n      provider,\n      magic,\n      email,\n      signedIn,\n      signIn,\n      signOut\n    }\n  }, props.children);\n  const {\n    0: magic,\n    1: setMagic\n  } = useState();\n  const {\n    0: provider,\n    1: setProvider\n  } = useState();\n  const {\n    0: email,\n    1: setEmail\n  } = useState();\n  const {\n    0: address,\n    1: setAddress\n  } = useState();\n  const {\n    0: signedIn,\n    1: setSignedIn\n  } = useState(false);\n  const networkName = process.env.NEXT_JS_DEFAULT_ETHEREUM_NETWORK_NAME;\n\n  const updateStateVars = async () => {\n    const {\n      email,\n      publicAddress\n    } = await magic.user.getMetadata();\n    setSignedIn(true);\n    setEmail(email);\n    setAddress(publicAddress); // const [ethBalance, setEthBalance] = useState('')\n    // const email = Cookies.get(MAGIC_EMAIL)\n\n    Cookies.set(MAGIC_EMAIL, email, COOKIE_OPTIONS);\n  };\n\n  useEffect(() => {\n    const m = new Magic(process.env.NEXT_JS_MAGIC_PUB_KEY, {\n      network: networkName === 'homestead' ? 'mainnet' : networkName\n    });\n    setMagic(m);\n    setProvider(new ethers.providers.Web3Provider(m.rpcProvider, process.env.NEXT_JS_DEFAULT_ETHEREUM_NETWORK_NAME));\n  }, []);\n  useEffect(() => {\n    const checkSignedIn = async () => {\n      if (await magic.user.isLoggedIn()) {\n        updateStateVars();\n      }\n    };\n\n    if (magic && magic.user) {\n      checkSignedIn();\n    }\n  }, [magic]);\n\n  const signOut = async e => {\n    if (e) {\n      e.preventDefault();\n    }\n\n    const logout = await magic.user.logout();\n\n    if (logout) {\n      Cookies.remove(MAGIC_EMAIL, COOKIE_OPTIONS);\n      setSignedIn(false);\n      setEmail(undefined);\n      setAddress(undefined);\n    }\n  };\n\n  const signIn = async (formEmail, postSignInCallback) => {\n    try {\n      const did = await magic.auth.loginWithMagicLink({\n        email: formEmail\n      });\n      const isLoggedIn = await magic.user.isLoggedIn(); // magic.user.updateEmail({ email, showUI?= true })\n\n      if (isLoggedIn) {\n        updateStateVars();\n\n        if (postSignInCallback) {\n          postSignInCallback();\n        }\n      }\n    } catch (err) {\n      console.error(err);\n      poolToast.error(err.message);\n\n      if (err instanceof RPCError) {\n        switch (err.code) {\n          case RPCErrorCode.MagicLinkFailedVerification:\n            console.log('MagicLinkFailedVerification');\n            break;\n\n          case RPCErrorCode.MagicLinkExpired:\n            console.log('MagicLinkExpired');\n            break;\n\n          case RPCErrorCode.MagicLinkRateLimited:\n            console.log('MagicLinkRateLimited');\n            break;\n\n          case RPCErrorCode.UserAlreadyLoggedIn:\n            console.log('UserAlreadyLoggedIn');\n            break;\n        }\n      }\n    }\n  };\n\n  return __jsx(MagicContext.Provider, {\n    value: {\n      address,\n      provider,\n      magic,\n      email,\n      signedIn,\n      signIn,\n      signOut\n    }\n  }, props.children);\n}","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/components/contextProviders/MagicContextProvider.jsx"],"names":["React","useEffect","useState","useContext","Cookies","useRouter","ethers","COOKIE_OPTIONS","MAGIC_EMAIL","poolToast","MagicContext","createContext","MagicContextProvider","props","address","provider","magic","email","signedIn","signIn","signOut","children","setMagic","setProvider","setEmail","setAddress","setSignedIn","networkName","process","env","NEXT_JS_DEFAULT_ETHEREUM_NETWORK_NAME","updateStateVars","publicAddress","user","getMetadata","set","m","Magic","NEXT_JS_MAGIC_PUB_KEY","network","providers","Web3Provider","rpcProvider","checkSignedIn","isLoggedIn","e","preventDefault","logout","remove","undefined","formEmail","postSignInCallback","did","auth","loginWithMagicLink","err","console","error","message","RPCError","code","RPCErrorCode","MagicLinkFailedVerification","log","MagicLinkExpired","MagicLinkRateLimited","UserAlreadyLoggedIn"],"mappings":"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","sourcesContent":["import React, { useEffect, useState, useContext } from 'react'\nimport Cookies from 'js-cookie'\nimport { useRouter } from 'next/router'\nimport { ethers } from 'ethers'\n// import { Magic, RPCError, RPCErrorCode } from 'magic-sdk'\n\nimport {\n  COOKIE_OPTIONS,\n  MAGIC_EMAIL,\n} from 'lib/constants'\nimport { poolToast } from 'lib/utils/poolToast'\n\nexport const MagicContext = React.createContext()\n\nexport function MagicContextProvider(props) {\n  return <MagicContext.Provider\n    value={{\n      address,\n      provider,\n      magic,\n      email,\n      signedIn,\n      signIn,\n      signOut,\n    }}\n  >\n    {props.children}\n  </MagicContext.Provider>\n\n\n  const [magic, setMagic] = useState()\n  const [provider, setProvider] = useState()\n  const [email, setEmail] = useState()\n  const [address, setAddress] = useState()\n  const [signedIn, setSignedIn] = useState(false)\n\n  const networkName = process.env.NEXT_JS_DEFAULT_ETHEREUM_NETWORK_NAME\n\n  const updateStateVars = async () => {\n    const { email, publicAddress } = await magic.user.getMetadata()\n\n    setSignedIn(true)\n    setEmail(email)\n    setAddress(publicAddress)\n    // const [ethBalance, setEthBalance] = useState('')\n    // const email = Cookies.get(MAGIC_EMAIL)\n\n    Cookies.set(\n      MAGIC_EMAIL,\n      email,\n      COOKIE_OPTIONS\n    )\n  }\n\n  useEffect(() => {\n    const m = new Magic(\n      process.env.NEXT_JS_MAGIC_PUB_KEY,\n      { network: networkName === 'homestead' ? 'mainnet' : networkName }\n    )\n    setMagic(m)\n\n    setProvider(\n      new ethers.providers.Web3Provider(\n        m.rpcProvider,\n        process.env.NEXT_JS_DEFAULT_ETHEREUM_NETWORK_NAME\n      )\n    )\n  }, [])\n\n\n  useEffect(() => {\n    const checkSignedIn = async () => {\n      if (await magic.user.isLoggedIn()) {\n        updateStateVars()\n      }\n    }\n\n    if (magic && magic.user) {\n      checkSignedIn()\n    }\n  }, [magic])\n\n  const signOut = async (e) => {\n    if (e) {\n      e.preventDefault()\n    }\n    \n    const logout = await magic.user.logout()\n    if (logout) {\n      Cookies.remove(MAGIC_EMAIL, COOKIE_OPTIONS)\n\n      setSignedIn(false)\n      setEmail(undefined)\n      setAddress(undefined)\n    }\n  }\n\n  const signIn = async (formEmail, postSignInCallback) => {\n    try {\n      const did = await magic\n        .auth\n        .loginWithMagicLink({ email: formEmail })\n\n      const isLoggedIn = await magic.user.isLoggedIn()\n\n      // magic.user.updateEmail({ email, showUI?= true })\n\n      if (isLoggedIn) {\n        updateStateVars()\n        \n        if (postSignInCallback) {\n          postSignInCallback()\n        }\n      }\n    } catch (err) {\n      console.error(err)\n      poolToast.error(err.message)\n\n      if (err instanceof RPCError) {\n        switch (err.code) {\n          case RPCErrorCode.MagicLinkFailedVerification:\n            console.log('MagicLinkFailedVerification')\n            break\n          case RPCErrorCode.MagicLinkExpired:\n            console.log('MagicLinkExpired')\n            break\n          case RPCErrorCode.MagicLinkRateLimited:\n            console.log('MagicLinkRateLimited')\n            break\n          case RPCErrorCode.UserAlreadyLoggedIn:\n            console.log('UserAlreadyLoggedIn')\n            break\n        }\n      }\n    }\n\n  }\n\n  return <MagicContext.Provider\n    value={{\n      address,\n      provider,\n      magic,\n      email,\n      signedIn,\n      signIn,\n      signOut,\n    }}\n  >\n    {props.children}\n  </MagicContext.Provider>\n}\n"]},"metadata":{},"sourceType":"module"}