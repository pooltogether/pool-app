{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\nimport ComptrollerAbi from '@pooltogether/pooltogether-contracts/abis/Comptroller';\nimport { batch, contract } from '@pooltogether/etherplex';\nimport PoolV21Abi from 'lib/../abis/PoolV21Abi';\nimport PodAbi from 'lib/../abis/PodAbi';\nimport ERC20Abi from 'lib/../abis/ERC20Abi'; // import { DRIP_TOKENS } from 'lib/constants'\n\nvar _getUserPoolData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(provider, usersAddress, pool, contractAddresses) {\n    var underlyingCollateralToken, poolAddress, etherplexTokenContract, values;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            underlyingCollateralToken = pool.underlyingCollateralToken, poolAddress = pool.poolAddress;\n            etherplexTokenContract = contract('token', ERC20Abi, underlyingCollateralToken);\n            _context.next = 4;\n            return batch(provider, etherplexTokenContract.balanceOf(usersAddress).allowance(usersAddress, poolAddress));\n\n          case 4:\n            values = _context.sent;\n            return _context.abrupt(\"return\", {\n              // usersDaiPermitAllowance: daiPermitValues?.token?.allowance[0],\n              usersTokenAllowance: values.token.allowance[0],\n              usersTokenBalance: values.token.balanceOf[0]\n            });\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function _getUserPoolData(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar _getUsersV2Data = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(provider, usersAddress, contractAddresses) {\n    var chainId, etherplexV2DaiPoolContract, etherplexV2UsdcPoolContract, etherplexV2DaiPodContract, etherplexV2UsdcPodContract, values;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            chainId = provider.network.chainId;\n\n            if (!(chainId !== 1)) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 3:\n            etherplexV2DaiPoolContract = contract('v2DaiPool', PoolV21Abi, contractAddresses.v2DAIPool);\n            etherplexV2UsdcPoolContract = contract('v2UsdcPool', PoolV21Abi, contractAddresses.v2USDCPool);\n            etherplexV2DaiPodContract = contract('v2DaiPod', PodAbi, contractAddresses.v2DAIPod);\n            etherplexV2UsdcPodContract = contract('v2UsdcPod', PodAbi, contractAddresses.v2USDCPod);\n            _context2.next = 9;\n            return batch(provider, etherplexV2DaiPoolContract.committedBalanceOf(usersAddress).openBalanceOf(usersAddress), etherplexV2UsdcPoolContract.committedBalanceOf(usersAddress).openBalanceOf(usersAddress), etherplexV2DaiPodContract.balanceOfUnderlying(usersAddress).pendingDeposit(usersAddress).balanceOf(usersAddress), etherplexV2UsdcPodContract.balanceOfUnderlying(usersAddress).pendingDeposit(usersAddress).balanceOf(usersAddress));\n\n          case 9:\n            values = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              v2DaiPoolCommittedBalance: values.v2DaiPool.committedBalanceOf[0],\n              v2DaiPoolOpenBalance: values.v2DaiPool.openBalanceOf[0],\n              v2UsdcPoolCommittedBalance: values.v2UsdcPool.committedBalanceOf[0],\n              v2UsdcPoolOpenBalance: values.v2UsdcPool.openBalanceOf[0],\n              v2DaiPodCommittedBalance: values.v2DaiPod.balanceOfUnderlying[0],\n              v2DaiPodOpenBalance: values.v2DaiPod.pendingDeposit[0],\n              v2DaiPodSharesBalance: values.v2DaiPod.balanceOf[0],\n              v2UsdcPodCommittedBalance: values.v2UsdcPod.balanceOfUnderlying[0],\n              v2UsdcPodOpenBalance: values.v2UsdcPod.pendingDeposit[0],\n              v2UsdcPodSharesBalance: values.v2UsdcPod.balanceOf[0]\n            });\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function _getUsersV2Data(_x5, _x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar _getUserDripData = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(provider, comptrollerAddress, pairs, usersAddress, dripTokens) {\n    var etherplexComptrollerContract, values, usersDripBalances, usersDripTokenData;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            etherplexComptrollerContract = contract('comptroller', ComptrollerAbi, comptrollerAddress);\n            _context3.next = 4;\n            return batch(provider, etherplexComptrollerContract.updateDrips(pairs, usersAddress, dripTokens));\n\n          case 4:\n            values = _context3.sent;\n            usersDripBalances = values.comptroller.updateDrips[0];\n            _context3.next = 8;\n            return _getDripTokenData(provider, usersAddress, dripTokens, usersDripBalances);\n\n          case 8:\n            usersDripTokenData = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              usersDripTokenData: usersDripTokenData\n            });\n\n          case 12:\n            _context3.prev = 12;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.warn(_context3.t0.message); // console.error(e)\n\n            return _context3.abrupt(\"return\", {});\n\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 12]]);\n  }));\n\n  return function _getUserDripData(_x8, _x9, _x10, _x11, _x12) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar _getDripTokenData = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(provider, usersAddress, dripTokens, usersDripBalances) {\n    var usersDripTokenData, batchCalls, etherplexTokenContract, dripTokenAddress, dripToken, values, i, claimable;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            usersDripTokenData = {};\n            batchCalls = [];\n\n            // Prepare batched calls\n            for (i = 0; i < dripTokens.length; i++) {\n              dripTokenAddress = dripTokens[i];\n              etherplexTokenContract = contract(dripTokenAddress, ERC20Abi, dripTokenAddress);\n              batchCalls.push(etherplexTokenContract.balanceOf(usersAddress).name().symbol().decimals());\n            } // Execute batched calls\n\n\n            _context4.next = 5;\n            return batch.apply(void 0, [provider].concat(batchCalls));\n\n          case 5:\n            values = _context4.sent;\n\n            // Map batch call results to drip token data\n            for (i = 0; i < dripTokens.length; i++) {\n              dripTokenAddress = dripTokens[i];\n              dripToken = dripTokens[dripTokenAddress];\n              claimable = usersDripBalances.find(function (dripBalance) {\n                return dripBalance.dripToken.toLowerCase() === dripTokenAddress.toLowerCase();\n              }).balance;\n              usersDripTokenData[dripTokenAddress] = _objectSpread(_objectSpread({}, dripToken), {}, {\n                name: values[dripTokenAddress].name[0],\n                symbol: values[dripTokenAddress].symbol[0],\n                decimals: values[dripTokenAddress].decimals[0],\n                balance: values[dripTokenAddress].balanceOf[0],\n                claimable: claimable\n              });\n            }\n\n            return _context4.abrupt(\"return\", usersDripTokenData);\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function _getDripTokenData(_x13, _x14, _x15, _x16) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexport var fetchUsersChainData = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(provider, pool, comptrollerAddress, dripTokens, usersAddress, pairs, contractAddresses) {\n    var userPoolData, usersV2Data, userDripData;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            userPoolData = {};\n            usersV2Data = {};\n            userDripData = {};\n            _context5.prev = 3;\n\n            if (!(provider && usersAddress)) {\n              _context5.next = 16;\n              break;\n            }\n\n            if (!(comptrollerAddress && pairs && dripTokens)) {\n              _context5.next = 9;\n              break;\n            }\n\n            _context5.next = 8;\n            return _getUserDripData(provider, comptrollerAddress, pairs, usersAddress, dripTokens);\n\n          case 8:\n            userDripData = _context5.sent;\n\n          case 9:\n            if (!pool) {\n              _context5.next = 13;\n              break;\n            }\n\n            _context5.next = 12;\n            return _getUserPoolData(provider, usersAddress, pool, contractAddresses);\n\n          case 12:\n            userPoolData = _context5.sent;\n\n          case 13:\n            _context5.next = 15;\n            return _getUsersV2Data(provider, usersAddress, contractAddresses);\n\n          case 15:\n            usersV2Data = _context5.sent;\n\n          case 16:\n            return _context5.abrupt(\"return\", _objectSpread(_objectSpread(_objectSpread({}, userPoolData), userDripData), usersV2Data));\n\n          case 19:\n            _context5.prev = 19;\n            _context5.t0 = _context5[\"catch\"](3);\n            console.warn(_context5.t0.message);\n            throw new Error(_context5.t0);\n\n          case 23:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[3, 19]]);\n  }));\n\n  return function fetchUsersChainData(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {\n    return _ref5.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchUsersChainData.js"],"names":["ComptrollerAbi","batch","contract","PoolV21Abi","PodAbi","ERC20Abi","_getUserPoolData","provider","usersAddress","pool","contractAddresses","underlyingCollateralToken","poolAddress","etherplexTokenContract","balanceOf","allowance","values","usersTokenAllowance","token","usersTokenBalance","_getUsersV2Data","chainId","network","etherplexV2DaiPoolContract","v2DAIPool","etherplexV2UsdcPoolContract","v2USDCPool","etherplexV2DaiPodContract","v2DAIPod","etherplexV2UsdcPodContract","v2USDCPod","committedBalanceOf","openBalanceOf","balanceOfUnderlying","pendingDeposit","v2DaiPoolCommittedBalance","v2DaiPool","v2DaiPoolOpenBalance","v2UsdcPoolCommittedBalance","v2UsdcPool","v2UsdcPoolOpenBalance","v2DaiPodCommittedBalance","v2DaiPod","v2DaiPodOpenBalance","v2DaiPodSharesBalance","v2UsdcPodCommittedBalance","v2UsdcPod","v2UsdcPodOpenBalance","v2UsdcPodSharesBalance","_getUserDripData","comptrollerAddress","pairs","dripTokens","etherplexComptrollerContract","updateDrips","usersDripBalances","comptroller","_getDripTokenData","usersDripTokenData","console","warn","message","batchCalls","i","length","dripTokenAddress","push","name","symbol","decimals","dripToken","claimable","find","dripBalance","toLowerCase","balance","fetchUsersChainData","userPoolData","usersV2Data","userDripData","Error"],"mappings":"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","sourcesContent":["// import PermitAndDepositDaiAbi from '@pooltogether/pooltogether-contracts/abis/PermitAndDepositDai'\nimport ComptrollerAbi from '@pooltogether/pooltogether-contracts/abis/Comptroller'\nimport { batch, contract } from '@pooltogether/etherplex'\n\nimport PoolV21Abi from 'lib/../abis/PoolV21Abi'\nimport PodAbi from 'lib/../abis/PodAbi'\n\nimport ERC20Abi from 'lib/../abis/ERC20Abi'\n\n// import { DRIP_TOKENS } from 'lib/constants'\n\nconst _getUserPoolData = async (provider, usersAddress, pool, contractAddresses) => {\n  const {\n    underlyingCollateralToken,\n    poolAddress,\n  } = pool\n\n  const etherplexTokenContract = contract(\n    'token',\n    ERC20Abi,\n    underlyingCollateralToken\n  )\n\n  const values = await batch(\n    provider,\n    etherplexTokenContract\n      .balanceOf(usersAddress)\n      .allowance(usersAddress, poolAddress)\n  )\n  \n  // OPTIMIZE: we can improve on this by batching in the same call above if we can figure out how to\n  // conditionally query depending on if we have a permitContract\n  // let daiPermitValues = {}\n  // const { daiPermitContract } = contractAddresses\n  // if (daiPermitContract) {\n  //   daiPermitValues = await batch(\n  //     provider,\n  //     etherplexTokenContract\n  //       .allowance(usersAddress, daiPermitContract)\n  //   )\n  // }\n\n  return {\n    // usersDaiPermitAllowance: daiPermitValues?.token?.allowance[0],\n    usersTokenAllowance: values.token.allowance[0],\n    usersTokenBalance: values.token.balanceOf[0],\n  }\n}\n\nconst _getUsersV2Data = async (provider, usersAddress, contractAddresses) => {\n  const chainId = provider.network.chainId\n  if (chainId !== 1) {\n    return\n  }\n\n  const etherplexV2DaiPoolContract = contract(\n    'v2DaiPool',\n    PoolV21Abi,\n    contractAddresses.v2DAIPool\n  )\n  \n  const etherplexV2UsdcPoolContract = contract(\n    'v2UsdcPool',\n    PoolV21Abi,\n    contractAddresses.v2USDCPool\n  )\n\n  const etherplexV2DaiPodContract = contract(\n    'v2DaiPod',\n    PodAbi,\n    contractAddresses.v2DAIPod\n  )\n\n  const etherplexV2UsdcPodContract = contract(\n    'v2UsdcPod',\n    PodAbi,\n    contractAddresses.v2USDCPod\n  )\n\n  const values = await batch(\n    provider,\n    etherplexV2DaiPoolContract\n      .committedBalanceOf(usersAddress)\n      .openBalanceOf(usersAddress),\n    etherplexV2UsdcPoolContract\n      .committedBalanceOf(usersAddress)\n      .openBalanceOf(usersAddress),\n    etherplexV2DaiPodContract\n      .balanceOfUnderlying(usersAddress)\n      .pendingDeposit(usersAddress)\n      .balanceOf(usersAddress),\n    etherplexV2UsdcPodContract\n      .balanceOfUnderlying(usersAddress)\n      .pendingDeposit(usersAddress)\n      .balanceOf(usersAddress),\n  )\n\n  return {\n    v2DaiPoolCommittedBalance: values.v2DaiPool.committedBalanceOf[0],\n    v2DaiPoolOpenBalance: values.v2DaiPool.openBalanceOf[0],\n    v2UsdcPoolCommittedBalance: values.v2UsdcPool.committedBalanceOf[0],\n    v2UsdcPoolOpenBalance: values.v2UsdcPool.openBalanceOf[0],\n    v2DaiPodCommittedBalance: values.v2DaiPod.balanceOfUnderlying[0],\n    v2DaiPodOpenBalance: values.v2DaiPod.pendingDeposit[0],\n    v2DaiPodSharesBalance: values.v2DaiPod.balanceOf[0],\n    v2UsdcPodCommittedBalance: values.v2UsdcPod.balanceOfUnderlying[0],\n    v2UsdcPodOpenBalance: values.v2UsdcPod.pendingDeposit[0],\n    v2UsdcPodSharesBalance: values.v2UsdcPod.balanceOf[0],\n  }\n}\n\nconst _getUserDripData = async (provider, comptrollerAddress, pairs, usersAddress, dripTokens) => {\n  try {\n    const etherplexComptrollerContract = contract(\n      'comptroller',\n      ComptrollerAbi,\n      comptrollerAddress\n    )\n\n    const values = await batch(\n      provider,\n      etherplexComptrollerContract\n        .updateDrips(pairs, usersAddress, dripTokens)\n    )\n\n    const usersDripBalances = values.comptroller.updateDrips[0]\n    const usersDripTokenData = await _getDripTokenData(provider, usersAddress, dripTokens, usersDripBalances)\n\n    return {\n      usersDripTokenData\n    }\n  } catch (e) {\n    console.warn(e.message)\n    // console.error(e)\n    return {}\n  }\n  \n}\n\nconst _getDripTokenData = async (provider, usersAddress, dripTokens, usersDripBalances) => {\n  const usersDripTokenData = {}\n  const batchCalls = []\n\n  let etherplexTokenContract\n  let dripTokenAddress\n  let dripToken\n  let values\n  let i\n\n  // Prepare batched calls\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i]\n\n    etherplexTokenContract = contract(dripTokenAddress, ERC20Abi, dripTokenAddress)\n\n    batchCalls.push(\n      etherplexTokenContract\n        .balanceOf(usersAddress)\n        .name()\n        .symbol()\n        .decimals()\n    )\n  }\n\n  // Execute batched calls\n  values = await batch(\n    provider,\n    ...batchCalls\n  )\n\n  // Map batch call results to drip token data\n  for (i = 0; i < dripTokens.length; i++) {\n    dripTokenAddress = dripTokens[i]\n    dripToken = dripTokens[dripTokenAddress]\n\n    const claimable = usersDripBalances.find(dripBalance => {\n      return dripBalance.dripToken.toLowerCase() === dripTokenAddress.toLowerCase()\n    })\n      .balance\n\n    usersDripTokenData[dripTokenAddress] = {\n      ...dripToken,\n      name: values[dripTokenAddress].name[0],\n      symbol: values[dripTokenAddress].symbol[0],\n      decimals: values[dripTokenAddress].decimals[0],\n      balance: values[dripTokenAddress].balanceOf[0],\n      claimable,\n    }\n  }\n\n  return usersDripTokenData\n}\n\n\nexport const fetchUsersChainData = async (\n  provider,\n  pool,\n  comptrollerAddress,\n  dripTokens,\n  usersAddress,\n  pairs,\n  contractAddresses\n) => {\n  let userPoolData = {}\n  let usersV2Data = {}\n  let userDripData = {}\n\n  try {\n    // Get Balances of Drip Tokens\n    if (provider && usersAddress) {\n      if (comptrollerAddress && pairs && dripTokens) {\n        userDripData = await _getUserDripData(provider, comptrollerAddress, pairs, usersAddress, dripTokens)\n      }\n\n      // Get Balances of Pool\n      if (pool) {\n        userPoolData = await _getUserPoolData(provider, usersAddress, pool, contractAddresses)\n      }\n      \n      usersV2Data = await _getUsersV2Data(provider, usersAddress, contractAddresses)\n    }\n\n    return {\n      ...userPoolData,\n      ...userDripData,\n      ...usersV2Data,\n    }\n\n  } catch (e) {\n    console.warn(e.message)\n    throw new Error(e)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}