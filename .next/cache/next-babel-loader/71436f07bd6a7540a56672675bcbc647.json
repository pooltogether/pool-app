{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      query uniswapTokensQuery {\\n        \", \"\\n      }\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport { request, gql } from 'graphql-request';\nimport { CONTRACT_ADDRESSES, UNISWAP_GRAPH_URIS } from 'lib/constants';\nvar QUERY_TEMPLATE = \"token__num__: tokens(where: { id: \\\"__address__\\\" } __blockFilter__) {\\n  id\\n  derivedETH\\n}\";\n\nvar _addStablecoin = function _addStablecoin(addresses, usdtAddress) {\n  var usdt = addresses.find(function (address) {\n    return usdtAddress === address;\n  });\n\n  if (!usdt) {\n    addresses.splice(0, 0, usdtAddress);\n  }\n\n  return addresses;\n};\n\nvar _getBlockFilter = function _getBlockFilter(blockNumber) {\n  var blockFilter = '';\n\n  if (blockNumber > 0) {\n    blockFilter = \", block: { number: \".concat(blockNumber, \" }\");\n  }\n\n  return blockFilter;\n};\n\nvar _calculateUsd = function _calculateUsd(token) {\n  var derivedETH = token === null || token === void 0 ? void 0 : token.derivedETH;\n\n  if (!derivedETH || derivedETH === '0') {\n    derivedETH = 0.2; // 1 ETH is $5 USD, used for Rinkeby, etc\n  }\n\n  return 1 / derivedETH;\n};\n\nexport var getUniswapData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(chainId, addresses, blockNumber) {\n    var _CONTRACT_ADDRESSES$c;\n\n    var blockFilter, stablecoinAddress, query, i, address, selection, response, data, _i, _address, token, _i2, _address2, _token;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blockFilter = _getBlockFilter(blockNumber); // We'll use this stablecoin to measure the price of ETH off of\n\n            stablecoinAddress = (_CONTRACT_ADDRESSES$c = CONTRACT_ADDRESSES[chainId]) === null || _CONTRACT_ADDRESSES$c === void 0 ? void 0 : _CONTRACT_ADDRESSES$c['Usdt'];\n\n            _addStablecoin(addresses, stablecoinAddress); // build a query selection set from all the token addresses\n\n\n            query = \"\";\n\n            for (i = 0; i < addresses.length; i++) {\n              address = addresses[i];\n              selection = QUERY_TEMPLATE.replace('__num__', i).replace('__address__', address).replace('__blockFilter__', blockFilter);\n              query = \"\".concat(query, \"\\n\").concat(selection);\n            }\n\n            _context.next = 7;\n            return request(UNISWAP_GRAPH_URIS[1], gql(_templateObject(), query));\n\n          case 7:\n            response = _context.sent;\n            // unpack the data into a useful object \n            data = {};\n\n            for (_i = 0; _i < addresses.length; _i++) {\n              _address = addresses[_i];\n              token = response[\"token\".concat(_i)][0];\n              data[_address] = token;\n            } // calculate and cache the price of eth in the data object \n\n\n            data['ethereum'] = {\n              derivedETH: '1',\n              id: 'eth',\n              usd: _calculateUsd(data[stablecoinAddress])\n            }; // calculate the price of the token in USD\n\n            for (_i2 = 0; _i2 < addresses.length; _i2++) {\n              _address2 = addresses[_i2];\n              _token = data[_address2];\n\n              if (_token) {\n                data[_address2] = _objectSpread(_objectSpread({}, _token), {}, {\n                  usd: data['ethereum'].usd * parseFloat(_token.derivedETH)\n                });\n              }\n            }\n\n            return _context.abrupt(\"return\", data);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getUniswapData(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/fetchers/getUniswapData.js"],"names":["request","gql","CONTRACT_ADDRESSES","UNISWAP_GRAPH_URIS","QUERY_TEMPLATE","_addStablecoin","addresses","usdtAddress","usdt","find","address","splice","_getBlockFilter","blockNumber","blockFilter","_calculateUsd","token","derivedETH","getUniswapData","chainId","stablecoinAddress","query","i","length","selection","replace","response","data","id","usd","parseFloat"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\n\nimport { CONTRACT_ADDRESSES, UNISWAP_GRAPH_URIS } from 'lib/constants'\n\nconst QUERY_TEMPLATE = `token__num__: tokens(where: { id: \"__address__\" } __blockFilter__) {\n  id\n  derivedETH\n}`\n\nconst _addStablecoin = (addresses, usdtAddress) => {\n  const usdt = addresses.find(address => usdtAddress === address)\n\n  if (!usdt) {\n    addresses.splice(0, 0, usdtAddress)\n  }\n\n  return addresses\n}\n\nconst _getBlockFilter = (blockNumber) => {\n  let blockFilter = ''\n\n  if (blockNumber > 0) {\n    blockFilter = `, block: { number: ${blockNumber} }`\n  }\n\n  return blockFilter\n}\n\nconst _calculateUsd = (token) => {\n  let derivedETH = token?.derivedETH\n\n  if (!derivedETH || derivedETH === '0') {\n    derivedETH = 0.2 // 1 ETH is $5 USD, used for Rinkeby, etc\n  }\n\n  return 1 / derivedETH\n}\n\nexport const getUniswapData = async (chainId, addresses, blockNumber) => {\n  const blockFilter = _getBlockFilter(blockNumber)\n\n  // We'll use this stablecoin to measure the price of ETH off of\n  const stablecoinAddress = CONTRACT_ADDRESSES[chainId]?.['Usdt']\n\n  _addStablecoin(\n    addresses,\n    stablecoinAddress,\n  )\n\n  // build a query selection set from all the token addresses\n  let query = ``\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n\n    const selection = QUERY_TEMPLATE\n      .replace('__num__', i)\n      .replace('__address__', address)\n      .replace('__blockFilter__', blockFilter)\n\n    query = `${query}\\n${selection}`\n  }\n\n  const response = await request(\n    UNISWAP_GRAPH_URIS[1],\n    gql`\n      query uniswapTokensQuery {\n        ${query}\n      }\n    `\n  )\n\n  // unpack the data into a useful object \n  let data = {}\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n    const token = response[`token${i}`][0]\n\n    data[address] = token\n  }\n\n  // calculate and cache the price of eth in the data object \n  data['ethereum'] = {\n    derivedETH: '1',\n    id: 'eth',\n    usd: _calculateUsd(data[stablecoinAddress])\n  }\n\n  // calculate the price of the token in USD\n  for (let i = 0; i < addresses.length; i++) {\n    const address = addresses[i]\n    const token = data[address]\n\n    if (token) {\n      data[address] = {\n        ...token,\n        usd: data['ethereum'].usd * parseFloat(token.derivedETH)\n      }\n    }\n  }\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}