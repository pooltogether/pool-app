{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { updateTransaction } from 'lib/services/updateTransaction';\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'; // import { getRevertReason } from 'lib/utils/getRevertReason'\n\nvar getRevertReason = require('eth-revert-reason');\n\nexport var checkTransactionStatuses = function checkTransactionStatuses(localStorageTransactions, provider, transactions, setTransactions) {\n  localStorageTransactions = localStorageTransactions.filter(function (tx) {\n    return tx.sent && !tx.completed;\n  }).map(function (tx) {\n    return runAsyncCheckTx(tx, provider, localStorageTransactions, setTransactions);\n  });\n};\n\nvar runAsyncCheckTx = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tx, provider, transactions, setTransactions) {\n    var ethersTx, networkName, reason;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return provider.getTransaction(tx.hash);\n\n          case 3:\n            ethersTx = _context.sent;\n            _context.next = 6;\n            return ethersTx.wait();\n\n          case 6:\n            updateTransaction(tx.id, {\n              ethersTx: ethersTx,\n              // reason,\n              // error: reason.length > 0,\n              completed: true\n            }, transactions, setTransactions);\n            _context.next = 22;\n            break;\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (!_context.t0.message.match('transaction failed')) {\n              _context.next = 20;\n              break;\n            }\n\n            networkName = chainIdToNetworkName(ethersTx.chainId);\n\n            if (!(networkName !== 'rinkeby')) {\n              _context.next = 17;\n              break;\n            }\n\n            _context.next = 16;\n            return getRevertReason(tx.hash, networkName);\n\n          case 16:\n            reason = _context.sent;\n\n          case 17:\n            updateTransaction(tx.id, {\n              ethersTx: ethersTx,\n              reason: reason,\n              error: true,\n              completed: true\n            }, transactions, setTransactions);\n            _context.next = 21;\n            break;\n\n          case 20:\n            console.error(_context.t0);\n\n          case 21:\n            if (!ethersTx) {\n              updateTransaction(tx.id, {\n                reason: 'Failed to send, could not find transaction on blockchain',\n                error: true,\n                completed: true\n              }, transactions, setTransactions);\n            }\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 9]]);\n  }));\n\n  return function runAsyncCheckTx(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/checkTransactionStatuses.js"],"names":["updateTransaction","chainIdToNetworkName","getRevertReason","require","checkTransactionStatuses","localStorageTransactions","provider","transactions","setTransactions","filter","tx","sent","completed","map","runAsyncCheckTx","getTransaction","hash","ethersTx","wait","id","message","match","networkName","chainId","reason","error","console"],"mappings":";;AAAA,SAASA,iBAAT,QAAkC,gCAAlC;AACA,SAASC,oBAAT,QAAqC,gCAArC,C,CAEA;;AACA,IAAMC,eAAe,GAAGC,OAAO,CAAC,mBAAD,CAA/B;;AAEA,OAAO,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CACtCC,wBADsC,EAEtCC,QAFsC,EAGtCC,YAHsC,EAItCC,eAJsC,EAKnC;AACHH,EAAAA,wBAAwB,GAAGA,wBAAwB,CAACI,MAAzB,CAAgC,UAAAC,EAAE;AAAA,WAAIA,EAAE,CAACC,IAAH,IAAW,CAACD,EAAE,CAACE,SAAnB;AAAA,GAAlC,EACxBC,GADwB,CACpB,UAAAH,EAAE;AAAA,WAAII,eAAe,CAACJ,EAAD,EAAKJ,QAAL,EAAeD,wBAAf,EAAyCG,eAAzC,CAAnB;AAAA,GADkB,CAA3B;AAED,CARM;;AAUP,IAAMM,eAAe;AAAA,sEAAG,iBACtBJ,EADsB,EAEtBJ,QAFsB,EAGtBC,YAHsB,EAItBC,eAJsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAQHF,QAAQ,CAACS,cAAT,CAAwBL,EAAE,CAACM,IAA3B,CARG;;AAAA;AAQpBC,YAAAA,QARoB;AAAA;AAAA,mBAUdA,QAAQ,CAACC,IAAT,EAVc;;AAAA;AAYpBlB,YAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EAEf;AACEF,cAAAA,QAAQ,EAARA,QADF;AAEE;AACA;AACAL,cAAAA,SAAS,EAAE;AAJb,aAFe,EAQfL,YARe,EASfC,eATe,CAAjB;AAZoB;AAAA;;AAAA;AAAA;AAAA;;AAAA,iBAwBhB,YAAEY,OAAF,CAAUC,KAAV,CAAgB,oBAAhB,CAxBgB;AAAA;AAAA;AAAA;;AAyBZC,YAAAA,WAzBY,GAyBErB,oBAAoB,CAACgB,QAAQ,CAACM,OAAV,CAzBtB;;AAAA,kBA2BdD,WAAW,KAAK,SA3BF;AAAA;AAAA;AAAA;;AAAA;AAAA,mBA4BDpB,eAAe,CAACQ,EAAE,CAACM,IAAJ,EAAUM,WAAV,CA5Bd;;AAAA;AA4BhBE,YAAAA,MA5BgB;;AAAA;AA+BlBxB,YAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EAEf;AACEF,cAAAA,QAAQ,EAARA,QADF;AAEEO,cAAAA,MAAM,EAANA,MAFF;AAGEC,cAAAA,KAAK,EAAE,IAHT;AAIEb,cAAAA,SAAS,EAAE;AAJb,aAFe,EAQfL,YARe,EASfC,eATe,CAAjB;AA/BkB;AAAA;;AAAA;AA2ClBkB,YAAAA,OAAO,CAACD,KAAR;;AA3CkB;AA8CpB,gBAAI,CAACR,QAAL,EAAe;AACbjB,cAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EACR;AACLK,gBAAAA,MAAM,EAAE,0DADH;AAELC,gBAAAA,KAAK,EAAE,IAFF;AAGLb,gBAAAA,SAAS,EAAE;AAHN,eADQ,EAMfL,YANe,EAOfC,eAPe,CAAjB;AASD;;AAxDmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAfM,eAAe;AAAA;AAAA;AAAA,GAArB","sourcesContent":["import { updateTransaction } from 'lib/services/updateTransaction'\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'\n\n// import { getRevertReason } from 'lib/utils/getRevertReason'\nconst getRevertReason = require('eth-revert-reason')\n\nexport const checkTransactionStatuses = (\n  localStorageTransactions,\n  provider,\n  transactions,\n  setTransactions\n) => {\n  localStorageTransactions = localStorageTransactions.filter(tx => tx.sent && !tx.completed)\n    .map(tx => runAsyncCheckTx(tx, provider, localStorageTransactions, setTransactions))\n}\n\nconst runAsyncCheckTx = async (\n  tx,\n  provider,\n  transactions,\n  setTransactions\n) => {\n  let ethersTx\n  try {\n    ethersTx = await provider.getTransaction(tx.hash)\n\n    await ethersTx.wait()\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        // reason,\n        // error: reason.length > 0,\n        completed: true,\n      },\n      transactions,\n      setTransactions\n    )\n  } catch (e) {\n    if (e.message.match('transaction failed')) {\n      const networkName = chainIdToNetworkName(ethersTx.chainId)\n      let reason\n      if (networkName !== 'rinkeby') {\n        reason = await getRevertReason(tx.hash, networkName)\n      }\n\n      updateTransaction(\n        tx.id,\n        {\n          ethersTx,\n          reason,\n          error: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n    } else {\n      console.error(e)\n    }\n\n    if (!ethersTx) {\n      updateTransaction(\n        tx.id, {\n          reason: 'Failed to send, could not find transaction on blockchain',\n          error: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}