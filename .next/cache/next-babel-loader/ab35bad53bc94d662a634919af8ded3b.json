{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { batch, contract } from '@pooltogether/etherplex';\nimport ERC721Abi from 'lib/../abis/CustomERC721';\nimport { axiosInstance } from 'lib/axiosInstance';\n\nvar debug = require('debug')('pool-app:fetchExternalErc721Awards');\n\nvar _tryMetadataMethod = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(provider, contractAddress, etherplexTokenContract, tokenId, method) {\n    var tokenValues;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return batch(provider, etherplexTokenContract[method](tokenId));\n\n          case 3:\n            tokenValues = _context.sent;\n            debug(tokenValues);\n            return _context.abrupt(\"return\", tokenValues[contractAddress][method][0]);\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n            // console.error(e)\n            debug(\"NFT with tokenId \".concat(tokenId, \" likely does not support metadata using method: \").concat(method, \"():\"), _context.t0.message);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8]]);\n  }));\n\n  return function _tryMetadataMethod(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var fetchExternalErc721Awards = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var provider, graphErc721Awards, poolAddress, batchCalls, awards, etherplexTokenContract, values, tokenValues, i, j, award, erc721Address, _award$tokenIds, tokenId, tokenURI, address, _award, _award$tokenIds2, _tokenId, _tokenURI, proxyUrl, targetUrl, response, data;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            provider = _ref2.provider, graphErc721Awards = _ref2.graphErc721Awards, poolAddress = _ref2.poolAddress;\n            batchCalls = [];\n            awards = {};\n            i = 0;\n\n          case 4:\n            if (!(i < (graphErc721Awards === null || graphErc721Awards === void 0 ? void 0 : graphErc721Awards.length))) {\n              _context2.next = 27;\n              break;\n            }\n\n            award = _objectSpread(_objectSpread({}, graphErc721Awards[i]), {}, {\n              tokens: {}\n            });\n            erc721Address = award.address;\n            etherplexTokenContract = contract(erc721Address, ERC721Abi, erc721Address);\n            batchCalls.push(etherplexTokenContract.balanceOf(poolAddress).name().symbol()); // TODO: split up the batching so we can query if metadata is supported by each NFT\n            //       or better yet, store the check to see if tokenURI/tokenMetadata is implemented on the Subgraph\n\n            j = 0;\n\n          case 10:\n            if (!(j < ((_award$tokenIds = award.tokenIds) === null || _award$tokenIds === void 0 ? void 0 : _award$tokenIds.length))) {\n              _context2.next = 23;\n              break;\n            }\n\n            tokenId = award.tokenIds[j];\n            _context2.next = 14;\n            return _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenURI');\n\n          case 14:\n            tokenURI = _context2.sent;\n\n            if (tokenURI) {\n              _context2.next = 19;\n              break;\n            }\n\n            _context2.next = 18;\n            return _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenMetadata');\n\n          case 18:\n            tokenURI = _context2.sent;\n\n          case 19:\n            award.tokens[tokenId] = {\n              tokenURI: tokenURI\n            };\n\n          case 20:\n            j++;\n            _context2.next = 10;\n            break;\n\n          case 23:\n            awards[award.address] = award;\n\n          case 24:\n            i++;\n            _context2.next = 4;\n            break;\n\n          case 27:\n            _context2.next = 29;\n            return batch.apply(void 0, [provider].concat(batchCalls));\n\n          case 29:\n            values = _context2.sent;\n            i = 0;\n\n          case 31:\n            if (!(i < (graphErc721Awards === null || graphErc721Awards === void 0 ? void 0 : graphErc721Awards.length))) {\n              _context2.next = 61;\n              break;\n            }\n\n            address = graphErc721Awards[i].address;\n            _award = awards[address];\n            awards[address] = _objectSpread(_objectSpread({}, _award), {}, {\n              tokens: awards[address].tokens,\n              name: values[address].name[0],\n              symbol: values[address].symbol[0],\n              balance: values[address].balanceOf[0]\n            });\n            j = 0;\n\n          case 36:\n            if (!(j < ((_award$tokenIds2 = _award.tokenIds) === null || _award$tokenIds2 === void 0 ? void 0 : _award$tokenIds2.length))) {\n              _context2.next = 58;\n              break;\n            }\n\n            _tokenId = _award.tokenIds[j];\n            _tokenURI = _award.tokens[_tokenId].tokenURI;\n\n            if (_tokenURI) {\n              _context2.next = 41;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 55);\n\n          case 41:\n            debug(_tokenURI);\n\n            if (!(_tokenURI.indexOf('http://') == 0 || _tokenURI.indexOf('https://') == 0)) {\n              _context2.next = 55;\n              break;\n            }\n\n            _context2.prev = 43;\n            // bypass CORS\n            proxyUrl = 'https://cors-anywhere.herokuapp.com/', targetUrl = _tokenURI;\n            _context2.next = 47;\n            return axiosInstance.get(proxyUrl + targetUrl);\n\n          case 47:\n            response = _context2.sent;\n\n            if (response.status < 305) {\n              data = response.data;\n              _award.tokens[_tokenId] = _objectSpread(_objectSpread({}, _award.tokens[_tokenId]), data);\n            }\n\n            _context2.next = 55;\n            break;\n\n          case 51:\n            _context2.prev = 51;\n            _context2.t0 = _context2[\"catch\"](43);\n            console.error('error while fetching 721 with tokenURI', _tokenURI);\n            console.error(_context2.t0);\n\n          case 55:\n            j++;\n            _context2.next = 36;\n            break;\n\n          case 58:\n            i++;\n            _context2.next = 31;\n            break;\n\n          case 61:\n            debug(awards);\n            return _context2.abrupt(\"return\", awards);\n\n          case 63:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[43, 51]]);\n  }));\n\n  return function fetchExternalErc721Awards(_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/fetchExternalErc721Awards.js"],"names":["batch","contract","ERC721Abi","axiosInstance","debug","require","_tryMetadataMethod","provider","contractAddress","etherplexTokenContract","tokenId","method","tokenValues","message","fetchExternalErc721Awards","graphErc721Awards","poolAddress","batchCalls","awards","i","length","award","tokens","erc721Address","address","push","balanceOf","name","symbol","j","tokenIds","tokenURI","values","balance","indexOf","proxyUrl","targetUrl","get","response","status","data","console","error"],"mappings":"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","sourcesContent":["import { batch, contract } from '@pooltogether/etherplex'\n\nimport ERC721Abi from 'lib/../abis/CustomERC721'\n\nimport { axiosInstance } from 'lib/axiosInstance'\n\nconst debug = require('debug')('pool-app:fetchExternalErc721Awards')\n\nconst _tryMetadataMethod = async (provider, contractAddress, etherplexTokenContract, tokenId, method) => {\n  let tokenValues\n\n  try {\n    tokenValues = await batch(\n      provider,\n      etherplexTokenContract[method](tokenId)\n    )\n    debug(tokenValues)\n\n    return tokenValues[contractAddress][method][0]\n  } catch (e) {\n    // console.error(e)\n    debug(`NFT with tokenId ${tokenId} likely does not support metadata using method: ${method}():`, e.message)\n  }\n}\n\nexport const fetchExternalErc721Awards = async ({\n  provider,\n  graphErc721Awards,\n  poolAddress,\n}) => {\n  const batchCalls = []\n\n  let awards = {}\n  let etherplexTokenContract\n  let values, tokenValues\n  let i, j\n\n  // Prepare batched calls\n  for (i = 0; i < graphErc721Awards?.length; i++) {\n    const award = {\n      ...graphErc721Awards[i],\n      tokens: {}\n    } \n    const erc721Address = award.address\n\n    etherplexTokenContract = contract(erc721Address, ERC721Abi, erc721Address)\n\n    batchCalls.push(\n      etherplexTokenContract\n        .balanceOf(poolAddress)\n        .name()\n        .symbol()\n    )\n\n\n    // TODO: split up the batching so we can query if metadata is supported by each NFT\n    //       or better yet, store the check to see if tokenURI/tokenMetadata is implemented on the Subgraph\n    for (j = 0; j < award.tokenIds?.length; j++) {\n      const tokenId = award.tokenIds[j]\n\n      let tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenURI')\n\n      if (!tokenURI) {\n        tokenURI = await _tryMetadataMethod(provider, erc721Address, etherplexTokenContract, tokenId, 'tokenMetadata')\n      }\n\n      award.tokens[tokenId] = {\n        tokenURI\n      }\n    }\n\n    awards[award.address] = award\n  }\n\n    \n  // Execute batched calls\n  values = await batch(\n    provider,\n    ...batchCalls\n  )\n\n  // Map batch call results to erc721 data and get metadata\n  for (i = 0; i < graphErc721Awards?.length; i++) {\n    const address = graphErc721Awards[i].address\n\n    const award = awards[address]\n    \n    awards[address] = {\n      ...award,\n      tokens: awards[address].tokens,\n      name: values[address].name[0],\n      symbol: values[address].symbol[0],\n      balance: values[address].balanceOf[0],\n    }\n\n    for (j = 0; j < award.tokenIds?.length; j++) {\n      const tokenId = award.tokenIds[j]\n      const tokenURI = award.tokens[tokenId].tokenURI\n\n      if (!tokenURI) {\n        continue\n      }\n      debug(tokenURI)\n\n      if (tokenURI.indexOf('http://') == 0 || tokenURI.indexOf('https://') == 0) {\n        try {\n          // bypass CORS\n          const proxyUrl = 'https://cors-anywhere.herokuapp.com/',\n            targetUrl = tokenURI\n\n          const response = await axiosInstance.get(proxyUrl + targetUrl)\n\n          if (response.status < 305) {\n            const data = response.data\n\n            award.tokens[tokenId] = {\n              ...award.tokens[tokenId],\n              ...data\n            }\n          }\n        } catch (e) {\n          console.error('error while fetching 721 with tokenURI', tokenURI)\n          console.error(e)\n        }\n      }\n    }\n  }\n  debug(awards)\n\n  return awards\n}\n"]},"metadata":{},"sourceType":"module"}