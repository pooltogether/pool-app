{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nimport { ethers } from 'ethers';\nimport { V2_CONTRACT_ADDRESSES } from 'lib/constants';\nimport { updateTransaction } from 'lib/services/updateTransaction';\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName';\nimport { poolToast } from 'lib/utils/poolToast';\n\nconst debug = require('debug')('pool-app:callTransaction');\n\nconst getRevertReason = require('eth-revert-reason');\n\nconst bn = ethers.utils.bigNumberify; // this could be smart enough to know which ABI to use based on \n// the contract address\n\nexport const callTransaction = async (t, transactions, setTransactions, tx, provider, usersAddress, contractAbi, contractAddress, method, params = []) => {\n  let ethersTx;\n  const signer = provider.getSigner();\n  const contract = new ethers.Contract(contractAddress, contractAbi, signer);\n  const nextNonce = await provider.getTransactionCount(usersAddress, 'pending');\n  const fxn = contract.interface.functions[method];\n  const data = fxn.encode(params);\n  const chainId = provider.network.chainId;\n  let transactionRequest = {\n    to: contractAddress,\n    nonce: nextNonce,\n    data,\n    chainId // gasLimit: bn(50000) // false number, could be a red herring, ignore this!\n\n  };\n  let gasEstimate;\n\n  try {\n    gasEstimate = await contract.estimate[method](...params);\n  } catch (e) {\n    console.log(`error while estimating gas: `, e);\n  }\n\n  let gasLimit;\n  const lastParam = params[params.length - 1];\n\n  if (typeof lastParam === 'object' && lastParam.hasOwnProperty('gasLimit')) {\n    transactionRequest.gasLimit = params.pop().gasLimit;\n  } else if (gasEstimate) {\n    const isV2Method = V2_CONTRACT_ADDRESSES.includes(contractAddress);\n    const gasMultiplier = isV2Method ? 1.2 : 1.1;\n    transactionRequest.gasLimit = parseInt(gasEstimate.toNumber() * gasMultiplier, 10);\n  }\n\n  try {\n    // using the lower level `Signer#sendTransaction` API here\n    // since the basic 'contract.method()' (ie.\n    // const ethersTx = await contract[method].apply(null, params))\n    // one was intermittently\n    // failing to get the nonce on Kovan w/ MetaMask\n    debug('sending tx', transactionRequest);\n    ethersTx = await signer.sendTransaction(transactionRequest);\n    updateTransaction(tx.id, {\n      ethersTx,\n      sent: true,\n      inWallet: false,\n      hash: ethersTx.hash\n    }, transactions, setTransactions); // debug(tx)\n\n    poolToast.success(__jsx(React.Fragment, null, tx.name, __jsx(\"br\", null), \" \", t('transactionSentConfirming'))); // Transaction sent! Confirming...\n\n    await ethersTx.wait();\n    updateTransaction(tx.id, {\n      ethersTx,\n      completed: true\n    }, transactions, setTransactions);\n    poolToast.rainbow(__jsx(React.Fragment, null, tx.name, __jsx(\"br\", null), \" \", t('transactionSuccessful')));\n  } catch (e) {\n    console.error(e.message);\n\n    if (e.message.match('User denied transaction signature')) {\n      updateTransaction(tx.id, {\n        cancelled: true,\n        completed: true\n      }, transactions, setTransactions);\n      poolToast.warn(t('youCancelledTheTransaction')); // You cancelled the transaction\n    } else {\n      var _ethersTx, _reason;\n\n      let reason, errorMsg;\n\n      if ((_ethersTx = ethersTx) === null || _ethersTx === void 0 ? void 0 : _ethersTx.hash) {\n        const networkName = chainIdToNetworkName(ethersTx.chainId);\n        reason = await getRevertReason(ethersTx.hash, networkName);\n      }\n\n      if ((_reason = reason) === null || _reason === void 0 ? void 0 : _reason.match('rng-in-flight')) {\n        reason = t('prizeBeingAwardedPleaseTryAgainSoon'); // 'Prize being awarded! Please try again soon'\n      }\n\n      errorMsg = reason ? reason : e.message;\n\n      if (!reason && e.message.match('transaction failed')) {\n        errorMsg = t('transactionFailedUnknownError'); // 'Transaction failed: unknown error'\n      }\n\n      updateTransaction(tx.id, {\n        error: true,\n        completed: true,\n        reason: errorMsg\n      }, transactions, setTransactions); // Failed to complete. Reason:\n\n      poolToast.error(`${tx.name} - ${t('txFailedToCompleteWithReason')} ${errorMsg}`);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/callTransaction.js"],"names":["ethers","V2_CONTRACT_ADDRESSES","updateTransaction","chainIdToNetworkName","poolToast","debug","require","getRevertReason","bn","utils","bigNumberify","callTransaction","t","transactions","setTransactions","tx","provider","usersAddress","contractAbi","contractAddress","method","params","ethersTx","signer","getSigner","contract","Contract","nextNonce","getTransactionCount","fxn","interface","functions","data","encode","chainId","network","transactionRequest","to","nonce","gasEstimate","estimate","e","console","log","gasLimit","lastParam","length","hasOwnProperty","pop","isV2Method","includes","gasMultiplier","parseInt","toNumber","sendTransaction","id","sent","inWallet","hash","success","name","wait","completed","rainbow","error","message","match","cancelled","warn","reason","errorMsg","networkName"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\n\nimport { V2_CONTRACT_ADDRESSES } from 'lib/constants'\nimport { updateTransaction } from 'lib/services/updateTransaction'\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'\nimport { poolToast } from 'lib/utils/poolToast'\n\nconst debug = require('debug')('pool-app:callTransaction')\n\nconst getRevertReason = require('eth-revert-reason')\nconst bn = ethers.utils.bigNumberify\n\n// this could be smart enough to know which ABI to use based on \n// the contract address\nexport const callTransaction = async (\n  t,\n  transactions,\n  setTransactions,\n  tx,\n  provider,\n  usersAddress,\n  contractAbi,\n  contractAddress,\n  method,\n  params = [],\n) => {\n  let ethersTx\n\n  const signer = provider.getSigner()\n\n  const contract = new ethers.Contract(\n    contractAddress,\n    contractAbi,\n    signer\n  )\n\n  const nextNonce = await provider.getTransactionCount(\n    usersAddress,\n    'pending'\n  )\n\n  const fxn = contract.interface.functions[method]\n\n  const data = fxn.encode(params)\n\n  const chainId = provider.network.chainId\n  let transactionRequest = {\n    to: contractAddress,\n    nonce: nextNonce,\n    data,\n    chainId,\n    // gasLimit: bn(50000) // false number, could be a red herring, ignore this!\n  }\n  \n  let gasEstimate\n  try {\n    gasEstimate = await contract.estimate[method](...params)\n  } catch (e) {\n    console.log(`error while estimating gas: `, e)\n  }\n\n  let gasLimit\n  const lastParam = params[params.length - 1]\n  if (typeof lastParam === 'object' && lastParam.hasOwnProperty('gasLimit')) {\n    transactionRequest.gasLimit = params.pop().gasLimit\n  } else if (gasEstimate) {\n    const isV2Method = V2_CONTRACT_ADDRESSES.includes(contractAddress)\n    const gasMultiplier = isV2Method ? 1.2 : 1.1\n    \n    transactionRequest.gasLimit = parseInt(gasEstimate.toNumber() * gasMultiplier, 10)\n  }\n\n\n\n  try {\n    // using the lower level `Signer#sendTransaction` API here\n    // since the basic 'contract.method()' (ie.\n    // const ethersTx = await contract[method].apply(null, params))\n    // one was intermittently\n    // failing to get the nonce on Kovan w/ MetaMask\n    debug('sending tx', transactionRequest)\n    ethersTx = await signer.sendTransaction(transactionRequest)\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        sent: true,\n        inWallet: false,\n        hash: ethersTx.hash\n      },\n      transactions,\n      setTransactions\n    )\n    // debug(tx)\n\n    poolToast.success(<>{tx.name}<br /> {t('transactionSentConfirming')}</>)\n    // Transaction sent! Confirming...\n\n    await ethersTx.wait()\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        completed: true,\n      },\n      transactions,\n      setTransactions\n    )\n\n    poolToast.rainbow(<>{tx.name}<br /> {t('transactionSuccessful')}</>)\n  } catch (e) {\n    console.error(e.message)\n\n    if (e.message.match('User denied transaction signature')) {\n      updateTransaction(\n        tx.id,\n        {\n          cancelled: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n      \n      poolToast.warn(t('youCancelledTheTransaction'))\n      // You cancelled the transaction\n    } else {\n      let reason,\n        errorMsg\n        \n      if (ethersTx?.hash) {\n        const networkName = chainIdToNetworkName(ethersTx.chainId)\n        reason = await getRevertReason(ethersTx.hash, networkName)\n      }\n\n      if (reason?.match('rng-in-flight')) {\n        reason = t('prizeBeingAwardedPleaseTryAgainSoon')\n        // 'Prize being awarded! Please try again soon'\n      }\n\n      errorMsg = reason ? reason : e.message\n\n      if (!reason && e.message.match('transaction failed')) {\n        errorMsg = t('transactionFailedUnknownError')\n        // 'Transaction failed: unknown error'\n      }\n\n      updateTransaction(\n        tx.id,\n        {\n          error: true,\n          completed: true,\n          reason: errorMsg\n        },\n        transactions,\n        setTransactions\n      )\n\n      // Failed to complete. Reason:\n      poolToast.error(`${tx.name} - ${t('txFailedToCompleteWithReason')} ${errorMsg}`)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}