{"ast":null,"code":"import { useContext, useState } from 'react';\nimport { useAtom } from 'jotai';\nimport { PlayerDataContext } from 'lib/components/contextProviders/PlayerDataContextProvider';\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider';\nimport { transactionsAtom } from 'lib/atoms/transactionsAtom';\n\nconst debug = require('debug')('pool-app:TxRefetchListener');\n\nexport function TxRefetchListener(props) {\n  const [transactions] = useAtom(transactionsAtom);\n  const {\n    0: storedPendingTransactions,\n    1: setStoredPendingTransactions\n  } = useState([]);\n  const {\n    refetchPoolsData\n  } = useContext(PoolDataContext);\n  const {\n    refetchPlayerData,\n    refetchSponsorData\n  } = useContext(PlayerDataContext);\n  const pendingTransactions = transactions.filter(t => !t.completed && !t.cancelled);\n\n  const runRefetch = tx => {\n    const playerBalanceTransaction = tx.method === 'depositTo' || tx.method === 'transfer' || tx.method === 'approve' || tx.method === 'withdrawInstantlyFrom' || tx.method === 'updateAndClaimDrips';\n    const poolStateTransaction = tx.method === 'startAward' || tx.method === 'completeAward';\n\n    if (playerBalanceTransaction) {\n      // we don't know when the Graph will have processed the new block data or when it has\n      // so simply query a few times for the updated data\n      setTimeout(() => {\n        refetchPlayerData();\n        refetchSponsorData();\n        debug('refetch!');\n      }, 2000);\n      setTimeout(() => {\n        refetchPlayerData();\n        refetchSponsorData();\n        debug('refetch!');\n      }, 8000);\n      setTimeout(() => {\n        refetchPlayerData();\n        refetchSponsorData();\n        debug('refetch!');\n      }, 16000);\n    } else if (poolStateTransaction) {\n      setTimeout(() => {\n        refetchPoolsData();\n        debug('refetch pool/prize!');\n      }, 6000);\n    }\n  };\n\n  storedPendingTransactions.forEach(tx => {\n    const storedTxId = tx.id;\n    const currentTxState = transactions.find(_tx => _tx.id === storedTxId);\n\n    if (currentTxState && currentTxState.completed && !currentTxState.error && !currentTxState.cancelled) {\n      runRefetch(tx);\n    }\n  });\n\n  if (pendingTransactions.length !== storedPendingTransactions.length) {\n    setStoredPendingTransactions(pendingTransactions);\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/components/TxRefetchListener.jsx"],"names":["useContext","useState","useAtom","PlayerDataContext","PoolDataContext","transactionsAtom","debug","require","TxRefetchListener","props","transactions","storedPendingTransactions","setStoredPendingTransactions","refetchPoolsData","refetchPlayerData","refetchSponsorData","pendingTransactions","filter","t","completed","cancelled","runRefetch","tx","playerBalanceTransaction","method","poolStateTransaction","setTimeout","forEach","storedTxId","id","currentTxState","find","_tx","error","length"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,QAArB,QAAqC,OAArC;AACA,SAASC,OAAT,QAAwB,OAAxB;AAEA,SAASC,iBAAT,QAAkC,2DAAlC;AACA,SAASC,eAAT,QAAgC,yDAAhC;AACA,SAASC,gBAAT,QAAiC,4BAAjC;;AAEA,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,4BAAjB,CAAd;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AACvC,QAAM,CAACC,YAAD,IAAiBR,OAAO,CAACG,gBAAD,CAA9B;AAEA,QAAM;AAAA,OAACM,yBAAD;AAAA,OAA4BC;AAA5B,MAA4DX,QAAQ,CAAC,EAAD,CAA1E;AAEA,QAAM;AAAEY,IAAAA;AAAF,MAAuBb,UAAU,CAACI,eAAD,CAAvC;AACA,QAAM;AAAEU,IAAAA,iBAAF;AAAqBC,IAAAA;AAArB,MAA4Cf,UAAU,CAACG,iBAAD,CAA5D;AAEA,QAAMa,mBAAmB,GAAGN,YAAY,CACrCO,MADyB,CAClBC,CAAC,IAAI,CAACA,CAAC,CAACC,SAAH,IAAgB,CAACD,CAAC,CAACE,SADN,CAA5B;;AAIA,QAAMC,UAAU,GAAIC,EAAD,IAAQ;AACzB,UAAMC,wBAAwB,GAAGD,EAAE,CAACE,MAAH,KAAc,WAAd,IAC/BF,EAAE,CAACE,MAAH,KAAc,UADiB,IAE/BF,EAAE,CAACE,MAAH,KAAc,SAFiB,IAG/BF,EAAE,CAACE,MAAH,KAAc,uBAHiB,IAI/BF,EAAE,CAACE,MAAH,KAAc,qBAJhB;AAMA,UAAMC,oBAAoB,GAAGH,EAAE,CAACE,MAAH,KAAc,YAAd,IAC3BF,EAAE,CAACE,MAAH,KAAc,eADhB;;AAGA,QAAID,wBAAJ,EAA8B;AAC5B;AACA;AACAG,MAAAA,UAAU,CAAC,MAAM;AACfZ,QAAAA,iBAAiB;AACjBC,QAAAA,kBAAkB;AAClBT,QAAAA,KAAK,CAAC,UAAD,CAAL;AACD,OAJS,EAIP,IAJO,CAAV;AAMAoB,MAAAA,UAAU,CAAC,MAAM;AACfZ,QAAAA,iBAAiB;AACjBC,QAAAA,kBAAkB;AAClBT,QAAAA,KAAK,CAAC,UAAD,CAAL;AACD,OAJS,EAIP,IAJO,CAAV;AAMAoB,MAAAA,UAAU,CAAC,MAAM;AACfZ,QAAAA,iBAAiB;AACjBC,QAAAA,kBAAkB;AAClBT,QAAAA,KAAK,CAAC,UAAD,CAAL;AACD,OAJS,EAIP,KAJO,CAAV;AAKD,KApBD,MAoBO,IAAImB,oBAAJ,EAA0B;AAC/BC,MAAAA,UAAU,CAAC,MAAM;AACfb,QAAAA,gBAAgB;AAChBP,QAAAA,KAAK,CAAC,qBAAD,CAAL;AACD,OAHS,EAGP,IAHO,CAAV;AAID;AACF,GApCD;;AAsCAK,EAAAA,yBAAyB,CAACgB,OAA1B,CAAkCL,EAAE,IAAI;AACtC,UAAMM,UAAU,GAAGN,EAAE,CAACO,EAAtB;AACA,UAAMC,cAAc,GAAGpB,YAAY,CAACqB,IAAb,CAAmBC,GAAD,IAASA,GAAG,CAACH,EAAJ,KAAWD,UAAtC,CAAvB;;AAEA,QACEE,cAAc,IACdA,cAAc,CAACX,SADf,IAEA,CAACW,cAAc,CAACG,KAFhB,IAGA,CAACH,cAAc,CAACV,SAJlB,EAKE;AACAC,MAAAA,UAAU,CAACC,EAAD,CAAV;AACD;AACF,GAZD;;AAcA,MAAIN,mBAAmB,CAACkB,MAApB,KAA+BvB,yBAAyB,CAACuB,MAA7D,EAAqE;AACnEtB,IAAAA,4BAA4B,CAACI,mBAAD,CAA5B;AACD;;AAED,SAAO,IAAP;AACD","sourcesContent":["import { useContext, useState } from 'react'\nimport { useAtom } from 'jotai'\n\nimport { PlayerDataContext } from 'lib/components/contextProviders/PlayerDataContextProvider'\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider'\nimport { transactionsAtom } from 'lib/atoms/transactionsAtom'\n\nconst debug = require('debug')('pool-app:TxRefetchListener')\n\nexport function TxRefetchListener(props) {\n  const [transactions] = useAtom(transactionsAtom)\n\n  const [storedPendingTransactions, setStoredPendingTransactions] = useState([])\n\n  const { refetchPoolsData } = useContext(PoolDataContext)\n  const { refetchPlayerData, refetchSponsorData } = useContext(PlayerDataContext)\n\n  const pendingTransactions = transactions\n    .filter(t => !t.completed && !t.cancelled)\n\n\n  const runRefetch = (tx) => {\n    const playerBalanceTransaction = tx.method === 'depositTo' ||\n      tx.method === 'transfer' ||\n      tx.method === 'approve' ||\n      tx.method === 'withdrawInstantlyFrom' ||\n      tx.method === 'updateAndClaimDrips'\n\n    const poolStateTransaction = tx.method === 'startAward' ||\n      tx.method === 'completeAward'\n\n    if (playerBalanceTransaction) {\n      // we don't know when the Graph will have processed the new block data or when it has\n      // so simply query a few times for the updated data\n      setTimeout(() => {\n        refetchPlayerData()\n        refetchSponsorData()\n        debug('refetch!')\n      }, 2000)\n\n      setTimeout(() => {\n        refetchPlayerData()\n        refetchSponsorData()\n        debug('refetch!')\n      }, 8000)\n\n      setTimeout(() => {\n        refetchPlayerData()\n        refetchSponsorData()\n        debug('refetch!')\n      }, 16000)\n    } else if (poolStateTransaction) {\n      setTimeout(() => {\n        refetchPoolsData()\n        debug('refetch pool/prize!')\n      }, 6000)\n    }\n  }\n\n  storedPendingTransactions.forEach(tx => {\n    const storedTxId = tx.id\n    const currentTxState = transactions.find((_tx) => _tx.id === storedTxId)\n\n    if (\n      currentTxState &&\n      currentTxState.completed &&\n      !currentTxState.error && \n      !currentTxState.cancelled\n    ) {\n      runRefetch(tx)\n    }\n  })\n\n  if (pendingTransactions.length !== storedPendingTransactions.length) {\n    setStoredPendingTransactions(pendingTransactions)\n  }\n\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}