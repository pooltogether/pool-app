{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n  Retrieves a new provider specific to read.  The reason we separate the read and the writes is that the\n  web3 providers on mobile dapps are extremely buggy; it's better to read the network through an INFURA\n  JsonRpc endpoint.\n\n  This function will first check to see if there is an injected web3.  If web3 is being injected, then a\n  Ethers Web3Provider is instantiated to check the network.  Once the network is determined the Ethers\n  getDefaultProvider function is used to create a provider pointing to the same network using an Infura node.\n*/\nimport { ethers } from 'ethers';\nvar providerCache = {};\nexport var readProvider = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(networkName) {\n    var provider, net;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (/local/.test(networkName)) {\n              provider = new ethers.providers.JsonRpcProvider();\n            } else {\n              provider = ethers.getDefaultProvider(networkName === 'mainnet' ? 'homestead' : networkName);\n            }\n\n            _context.next = 3;\n            return provider.getNetwork();\n\n          case 3:\n            net = _context.sent;\n\n            // If we're running against a known network\n            if (net && net.name !== 'unknown') {\n              if (!providerCache[net.name]) {\n                providerCache[net.name] = new ethers.providers.InfuraProvider(net.name, process.env.NEXT_JS_INFURA_KEY);\n              } // use a separate Infura-based provider for consistent read api\n\n\n              provider = providerCache[net.name];\n            }\n\n            return _context.abrupt(\"return\", provider);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function readProvider(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/services/readProvider.js"],"names":["ethers","providerCache","readProvider","networkName","test","provider","providers","JsonRpcProvider","getDefaultProvider","getNetwork","net","name","InfuraProvider","process","env","NEXT_JS_INFURA_KEY"],"mappings":";;;AAAA;;;;;;;;;AASA,SAASA,MAAT,QAAuB,QAAvB;AAEA,IAAMC,aAAa,GAAG,EAAtB;AAEA,OAAO,IAAMC,YAAY;AAAA,sEAAG,iBAAgBC,WAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAG1B,gBAAI,QAAQC,IAAR,CAAaD,WAAb,CAAJ,EAA+B;AAC7BE,cAAAA,QAAQ,GAAG,IAAIL,MAAM,CAACM,SAAP,CAAiBC,eAArB,EAAX;AACD,aAFD,MAEO;AACLF,cAAAA,QAAQ,GAAGL,MAAM,CAACQ,kBAAP,CACTL,WAAW,KAAK,SAAhB,GAA4B,WAA5B,GAA0CA,WADjC,CAAX;AAGD;;AATyB;AAAA,mBAWRE,QAAQ,CAACI,UAAT,EAXQ;;AAAA;AAWpBC,YAAAA,GAXoB;;AAa1B;AACA,gBAAIA,GAAG,IAAIA,GAAG,CAACC,IAAJ,KAAa,SAAxB,EAAmC;AACjC,kBAAI,CAACV,aAAa,CAACS,GAAG,CAACC,IAAL,CAAlB,EAA8B;AAC5BV,gBAAAA,aAAa,CAACS,GAAG,CAACC,IAAL,CAAb,GAA0B,IAAIX,MAAM,CAACM,SAAP,CAAiBM,cAArB,CACxBF,GAAG,CAACC,IADoB,EAExBE,OAAO,CAACC,GAAR,CAAYC,kBAFY,CAA1B;AAID,eANgC,CAQjC;;;AACAV,cAAAA,QAAQ,GAAGJ,aAAa,CAACS,GAAG,CAACC,IAAL,CAAxB;AACD;;AAxByB,6CA0BnBN,QA1BmB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAZH,YAAY;AAAA;AAAA;AAAA,GAAlB","sourcesContent":["/**\n  Retrieves a new provider specific to read.  The reason we separate the read and the writes is that the\n  web3 providers on mobile dapps are extremely buggy; it's better to read the network through an INFURA\n  JsonRpc endpoint.\n\n  This function will first check to see if there is an injected web3.  If web3 is being injected, then a\n  Ethers Web3Provider is instantiated to check the network.  Once the network is determined the Ethers\n  getDefaultProvider function is used to create a provider pointing to the same network using an Infura node.\n*/\nimport { ethers } from 'ethers'\n\nconst providerCache = {}\n\nexport const readProvider = async function (networkName) {\n  let provider\n\n  if (/local/.test(networkName)) {\n    provider = new ethers.providers.JsonRpcProvider()\n  } else {\n    provider = ethers.getDefaultProvider(\n      networkName === 'mainnet' ? 'homestead' : networkName\n    )\n  }\n\n  const net = await provider.getNetwork()\n\n  // If we're running against a known network\n  if (net && net.name !== 'unknown') {\n    if (!providerCache[net.name]) {\n      providerCache[net.name] = new ethers.providers.InfuraProvider(\n        net.name,\n        process.env.NEXT_JS_INFURA_KEY\n      )\n    }\n\n    // use a separate Infura-based provider for consistent read api\n    provider = providerCache[net.name]\n  }\n\n  return provider\n}\n"]},"metadata":{},"sourceType":"module"}