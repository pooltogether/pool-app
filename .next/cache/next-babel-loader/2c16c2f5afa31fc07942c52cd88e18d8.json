{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { useContext, useEffect, useState } from 'react';\nimport { uniqWith, isEqual } from 'lodash';\nimport { MAINNET_POLLING_INTERVAL } from 'lib/constants';\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider';\nimport { useInterval } from 'lib/hooks/useInterval';\nimport { fetchUsersChainData } from 'lib/utils/fetchUsersChainData';\n\nvar debug = require('debug')('pool-app:FetchUsersChainData');\n\nexport function FetchUsersChainData(props) {\n  _s();\n\n  var children = props.children,\n      graphDripData = props.graphDripData,\n      pool = props.pool,\n      provider = props.provider,\n      usersAddress = props.usersAddress,\n      contractAddresses = props.contractAddresses;\n\n  var _useContext = useContext(AuthControllerContext),\n      pauseQueries = _useContext.pauseQueries;\n\n  var poolAddress = pool === null || pool === void 0 ? void 0 : pool.poolAddress;\n\n  var _useState = useState({}),\n      usersChainData = _useState[0],\n      setUsersChainData = _useState[1];\n\n  var pairs = [];\n  var dripTokens = [];\n  var comptrollerAddress;\n\n  if (graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips) {\n    var balanceDripPairs = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips.map(function (drip) {\n      return [drip.sourceAddress, drip.measureToken];\n    });\n    var volumeDripPairs = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.volumeDrips.map(function (drip) {\n      return [drip.sourceAddress, drip.measureToken];\n    });\n    pairs = uniqWith(balanceDripPairs === null || balanceDripPairs === void 0 ? void 0 : balanceDripPairs.concat(volumeDripPairs), isEqual);\n    var balanceDripTokens = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.balanceDrips.map(function (drip) {\n      return drip.dripToken;\n    });\n    var volumeDripTokens = graphDripData === null || graphDripData === void 0 ? void 0 : graphDripData.volumeDrips.map(function (drip) {\n      return drip.dripToken;\n    });\n    dripTokens = uniqWith(balanceDripTokens === null || balanceDripTokens === void 0 ? void 0 : balanceDripTokens.concat(volumeDripTokens), isEqual);\n\n    if (graphDripData.balanceDrips.length > 0) {\n      comptrollerAddress = graphDripData.balanceDrips[0].comptroller.id;\n    }\n  }\n\n  var fetchUsersDataFromInfura = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var data;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return fetchUsersChainData(provider, pool, comptrollerAddress, dripTokens, usersAddress, pairs, contractAddresses);\n\n            case 3:\n              data = _context.sent;\n              return _context.abrupt(\"return\", data);\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              // error while fetching from infura?\n              console.warn(_context.t0);\n              return _context.abrupt(\"return\", {});\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n\n    return function fetchUsersDataFromInfura() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var updateOrDelete = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var usersData;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!usersAddress) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 3;\n              return fetchUsersDataFromInfura();\n\n            case 3:\n              usersData = _context2.sent;\n              setUsersChainData(usersData);\n              _context2.next = 8;\n              break;\n\n            case 7:\n              setUsersChainData({});\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function updateOrDelete() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  useInterval(function () {\n    debug('fetching new users chain data after MAINNET_POLLING_INTERVAL expired', MAINNET_POLLING_INTERVAL);\n    updateOrDelete();\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL);\n  useEffect(function () {\n    updateOrDelete(); // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [poolAddress, usersAddress, comptrollerAddress]);\n  return children({\n    usersChainData: usersChainData\n  });\n}\n\n_s(FetchUsersChainData, \"mnqG296a4XghFQ35c1wnpRIZAJA=\", false, function () {\n  return [useInterval];\n});\n\n_c = FetchUsersChainData;\n\nvar _c;\n\n$RefreshReg$(_c, \"FetchUsersChainData\");","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/components/FetchUsersChainData.jsx"],"names":["useContext","useEffect","useState","uniqWith","isEqual","MAINNET_POLLING_INTERVAL","AuthControllerContext","useInterval","fetchUsersChainData","debug","require","FetchUsersChainData","props","children","graphDripData","pool","provider","usersAddress","contractAddresses","pauseQueries","poolAddress","usersChainData","setUsersChainData","pairs","dripTokens","comptrollerAddress","balanceDrips","balanceDripPairs","map","drip","sourceAddress","measureToken","volumeDripPairs","volumeDrips","concat","balanceDripTokens","dripToken","volumeDripTokens","length","comptroller","id","fetchUsersDataFromInfura","data","console","warn","updateOrDelete","usersData"],"mappings":"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","sourcesContent":["import { useContext, useEffect, useState } from 'react'\nimport { uniqWith, isEqual } from 'lodash'\n\nimport {\n  MAINNET_POLLING_INTERVAL\n} from 'lib/constants'\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider'\nimport { useInterval } from 'lib/hooks/useInterval'\nimport { fetchUsersChainData } from 'lib/utils/fetchUsersChainData'\n\nconst debug = require('debug')('pool-app:FetchUsersChainData')\n\nexport function FetchUsersChainData(props) {\n  const {\n    children,\n    graphDripData,\n    pool,\n    provider,\n    usersAddress,\n    contractAddresses,\n  } = props\n\n  const { pauseQueries } = useContext(AuthControllerContext)\n\n  const poolAddress = pool?.poolAddress\n\n  const [usersChainData, setUsersChainData] = useState({})\n\n  let pairs = []\n  let dripTokens = []\n  let comptrollerAddress\n  if (graphDripData?.balanceDrips) {\n    const balanceDripPairs = graphDripData?.balanceDrips.map((drip) => [drip.sourceAddress, drip.measureToken])\n    const volumeDripPairs = graphDripData?.volumeDrips.map((drip) => [drip.sourceAddress, drip.measureToken])\n\n    pairs = uniqWith(balanceDripPairs?.concat(volumeDripPairs), isEqual)\n\n    const balanceDripTokens = graphDripData?.balanceDrips.map((drip) => drip.dripToken)\n    const volumeDripTokens = graphDripData?.volumeDrips.map((drip) => drip.dripToken)\n\n    dripTokens = uniqWith(balanceDripTokens?.concat(volumeDripTokens), isEqual)\n\n    if (graphDripData.balanceDrips.length > 0) {\n      comptrollerAddress = graphDripData.balanceDrips[0].comptroller.id\n    }\n  }\n\n  const fetchUsersDataFromInfura = async () => {\n    try {\n      const data = await fetchUsersChainData(\n        provider,\n        pool,\n        comptrollerAddress,\n        dripTokens,\n        usersAddress,\n        pairs,\n        contractAddresses,\n      )\n\n      return data\n    } catch (e) {\n      // error while fetching from infura?\n      console.warn(e)\n      return {}\n    }\n  }\n\n  const updateOrDelete = async () => {\n    if (usersAddress) {\n      const usersData = await fetchUsersDataFromInfura()\n      setUsersChainData(usersData)\n    } else {\n      setUsersChainData({})\n    }\n\n\n    \n  }\n\n\n  useInterval(() => {\n    debug('fetching new users chain data after MAINNET_POLLING_INTERVAL expired', MAINNET_POLLING_INTERVAL)\n    updateOrDelete()\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL)\n\n  useEffect(() => {\n    updateOrDelete()\n    // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [poolAddress, usersAddress, comptrollerAddress])\n\n  return children({ usersChainData })\n}\n"]},"metadata":{},"sourceType":"module"}