{"ast":null,"code":"import { useContext, useEffect, useState } from 'react';\nimport { ethers } from 'ethers';\nimport { MAINNET_POLLING_INTERVAL } from 'lib/constants';\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider';\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider';\nimport { fetchExitFees } from 'lib/utils/fetchExitFees';\nimport { useInterval } from 'lib/hooks/useInterval';\nexport function useExitFees(quantity) {\n  var _pool$prizeStrategy, _pool$prizeStrategy$s, _pool$prizeStrategy$s2;\n\n  const {\n    pauseQueries,\n    usersAddress,\n    networkName\n  } = useContext(AuthControllerContext);\n  const {\n    pool\n  } = useContext(PoolDataContext);\n  const poolAddress = pool === null || pool === void 0 ? void 0 : pool.poolAddress;\n  const ticketAddress = pool === null || pool === void 0 ? void 0 : (_pool$prizeStrategy = pool.prizeStrategy) === null || _pool$prizeStrategy === void 0 ? void 0 : (_pool$prizeStrategy$s = _pool$prizeStrategy.singleRandomWinner) === null || _pool$prizeStrategy$s === void 0 ? void 0 : (_pool$prizeStrategy$s2 = _pool$prizeStrategy$s.ticket) === null || _pool$prizeStrategy$s2 === void 0 ? void 0 : _pool$prizeStrategy$s2.id;\n  const {\n    0: exitFees,\n    1: setExitFees\n  } = useState({});\n  let underlyingCollateralDecimals = 18;\n  underlyingCollateralDecimals = pool && pool.underlyingCollateralDecimals;\n\n  const getFees = async () => {\n    const quantityBN = ethers.utils.parseUnits(quantity, Number(underlyingCollateralDecimals));\n    const result = await fetchExitFees(networkName, usersAddress, poolAddress, ticketAddress, quantityBN);\n    setExitFees(result);\n  };\n\n  useInterval(() => {\n    getFees();\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL);\n  useEffect(() => {\n    const ready = quantity && usersAddress && networkName && ticketAddress && poolAddress && networkName;\n\n    if (ready) {\n      getFees();\n    } // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n\n  }, [quantity, usersAddress, networkName, ticketAddress, poolAddress, networkName]);\n  return {\n    exitFees\n  };\n}","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/hooks/useExitFees.jsx"],"names":["useContext","useEffect","useState","ethers","MAINNET_POLLING_INTERVAL","AuthControllerContext","PoolDataContext","fetchExitFees","useInterval","useExitFees","quantity","pauseQueries","usersAddress","networkName","pool","poolAddress","ticketAddress","prizeStrategy","singleRandomWinner","ticket","id","exitFees","setExitFees","underlyingCollateralDecimals","getFees","quantityBN","utils","parseUnits","Number","result","ready"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,QAAhC,QAAgD,OAAhD;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,SACEC,wBADF,QAEO,eAFP;AAGA,SAASC,qBAAT,QAAsC,+DAAtC;AACA,SAASC,eAAT,QAAgC,yDAAhC;AACA,SAASC,aAAT,QAA8B,yBAA9B;AACA,SAASC,WAAT,QAA4B,uBAA5B;AAEA,OAAO,SAASC,WAAT,CAAqBC,QAArB,EAA+B;AAAA;;AACpC,QAAM;AAAEC,IAAAA,YAAF;AAAgBC,IAAAA,YAAhB;AAA8BC,IAAAA;AAA9B,MAA8Cb,UAAU,CAACK,qBAAD,CAA9D;AACA,QAAM;AAAES,IAAAA;AAAF,MAAWd,UAAU,CAACM,eAAD,CAA3B;AAEA,QAAMS,WAAW,GAAGD,IAAH,aAAGA,IAAH,uBAAGA,IAAI,CAAEC,WAA1B;AACA,QAAMC,aAAa,GAAGF,IAAH,aAAGA,IAAH,8CAAGA,IAAI,CAAEG,aAAT,iFAAG,oBAAqBC,kBAAxB,oFAAG,sBAAyCC,MAA5C,2DAAG,uBAAiDC,EAAvE;AAEA,QAAM;AAAA,OAACC,QAAD;AAAA,OAAWC;AAAX,MAA0BpB,QAAQ,CAAC,EAAD,CAAxC;AAEA,MAAIqB,4BAA4B,GAAG,EAAnC;AACAA,EAAAA,4BAA4B,GAAGT,IAAI,IAAIA,IAAI,CAACS,4BAA5C;;AAEA,QAAMC,OAAO,GAAG,YAAY;AAC1B,UAAMC,UAAU,GAAGtB,MAAM,CAACuB,KAAP,CAAaC,UAAb,CACjBjB,QADiB,EAEjBkB,MAAM,CAACL,4BAAD,CAFW,CAAnB;AAKA,UAAMM,MAAM,GAAG,MAAMtB,aAAa,CAChCM,WADgC,EAEhCD,YAFgC,EAGhCG,WAHgC,EAIhCC,aAJgC,EAKhCS,UALgC,CAAlC;AAQAH,IAAAA,WAAW,CAACO,MAAD,CAAX;AACD,GAfD;;AAiBArB,EAAAA,WAAW,CAAC,MAAM;AAChBgB,IAAAA,OAAO;AACR,GAFU,EAERb,YAAY,GAAG,IAAH,GAAUP,wBAFd,CAAX;AAIAH,EAAAA,SAAS,CAAC,MAAM;AACd,UAAM6B,KAAK,GAAGpB,QAAQ,IAAIE,YAAZ,IAA4BC,WAA5B,IAA2CG,aAA3C,IAA4DD,WAA5D,IAA2EF,WAAzF;;AACA,QAAIiB,KAAJ,EAAW;AACTN,MAAAA,OAAO;AACR,KAJa,CAKd;;AACD,GANQ,EAMN,CACDd,QADC,EAEDE,YAFC,EAGDC,WAHC,EAIDG,aAJC,EAKDD,WALC,EAMDF,WANC,CANM,CAAT;AAeA,SAAO;AAAEQ,IAAAA;AAAF,GAAP;AACD","sourcesContent":["import { useContext, useEffect, useState } from 'react'\nimport { ethers } from 'ethers'\n\nimport {\n  MAINNET_POLLING_INTERVAL\n} from 'lib/constants'\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider'\nimport { PoolDataContext } from 'lib/components/contextProviders/PoolDataContextProvider'\nimport { fetchExitFees } from 'lib/utils/fetchExitFees'\nimport { useInterval } from 'lib/hooks/useInterval'\n\nexport function useExitFees(quantity) {\n  const { pauseQueries, usersAddress, networkName } = useContext(AuthControllerContext)\n  const { pool } = useContext(PoolDataContext)\n\n  const poolAddress = pool?.poolAddress\n  const ticketAddress = pool?.prizeStrategy?.singleRandomWinner?.ticket?.id\n\n  const [exitFees, setExitFees] = useState({})\n \n  let underlyingCollateralDecimals = 18\n  underlyingCollateralDecimals = pool && pool.underlyingCollateralDecimals\n\n  const getFees = async () => {\n    const quantityBN = ethers.utils.parseUnits(\n      quantity,\n      Number(underlyingCollateralDecimals)\n    )\n\n    const result = await fetchExitFees(\n      networkName,\n      usersAddress,\n      poolAddress,\n      ticketAddress,\n      quantityBN\n    )\n\n    setExitFees(result)\n  }\n\n  useInterval(() => {\n    getFees()\n  }, pauseQueries ? null : MAINNET_POLLING_INTERVAL)\n\n  useEffect(() => {\n    const ready = quantity && usersAddress && networkName && ticketAddress && poolAddress && networkName\n    if (ready) {\n      getFees()\n    }\n    // OPTIMIZE: Could reset the interval loop here since we just grabbed fresh data!\n  }, [\n    quantity,\n    usersAddress,\n    networkName,\n    ticketAddress,\n    poolAddress,\n    networkName\n  ])\n  \n  return { exitFees }\n}\n"]},"metadata":{},"sourceType":"module"}