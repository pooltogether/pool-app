{"ast":null,"code":"import { updateTransaction } from 'lib/services/updateTransaction';\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'; // import { getRevertReason } from 'lib/utils/getRevertReason'\n\nconst getRevertReason = require('eth-revert-reason');\n\nexport const checkTransactionStatuses = (localStorageTransactions, provider, transactions, setTransactions) => {\n  localStorageTransactions = localStorageTransactions.filter(tx => tx.sent && !tx.completed).map(tx => runAsyncCheckTx(tx, provider, localStorageTransactions, setTransactions));\n};\n\nconst runAsyncCheckTx = async (tx, provider, transactions, setTransactions) => {\n  let ethersTx;\n\n  try {\n    ethersTx = await provider.getTransaction(tx.hash);\n    await ethersTx.wait();\n    updateTransaction(tx.id, {\n      ethersTx,\n      // reason,\n      // error: reason.length > 0,\n      completed: true\n    }, transactions, setTransactions);\n  } catch (e) {\n    if (e.message.match('transaction failed')) {\n      const networkName = chainIdToNetworkName(ethersTx.chainId);\n      let reason;\n\n      if (networkName !== 'rinkeby') {\n        reason = await getRevertReason(tx.hash, networkName);\n      }\n\n      updateTransaction(tx.id, {\n        ethersTx,\n        reason,\n        error: true,\n        completed: true\n      }, transactions, setTransactions);\n    } else {\n      console.error(e);\n    }\n\n    if (!ethersTx) {\n      updateTransaction(tx.id, {\n        reason: 'Failed to send, could not find transaction on blockchain',\n        error: true,\n        completed: true\n      }, transactions, setTransactions);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/checkTransactionStatuses.js"],"names":["updateTransaction","chainIdToNetworkName","getRevertReason","require","checkTransactionStatuses","localStorageTransactions","provider","transactions","setTransactions","filter","tx","sent","completed","map","runAsyncCheckTx","ethersTx","getTransaction","hash","wait","id","e","message","match","networkName","chainId","reason","error","console"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,gCAAlC;AACA,SAASC,oBAAT,QAAqC,gCAArC,C,CAEA;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,mBAAD,CAA/B;;AAEA,OAAO,MAAMC,wBAAwB,GAAG,CACtCC,wBADsC,EAEtCC,QAFsC,EAGtCC,YAHsC,EAItCC,eAJsC,KAKnC;AACHH,EAAAA,wBAAwB,GAAGA,wBAAwB,CAACI,MAAzB,CAAgCC,EAAE,IAAIA,EAAE,CAACC,IAAH,IAAW,CAACD,EAAE,CAACE,SAArD,EACxBC,GADwB,CACpBH,EAAE,IAAII,eAAe,CAACJ,EAAD,EAAKJ,QAAL,EAAeD,wBAAf,EAAyCG,eAAzC,CADD,CAA3B;AAED,CARM;;AAUP,MAAMM,eAAe,GAAG,OACtBJ,EADsB,EAEtBJ,QAFsB,EAGtBC,YAHsB,EAItBC,eAJsB,KAKnB;AACH,MAAIO,QAAJ;;AACA,MAAI;AACFA,IAAAA,QAAQ,GAAG,MAAMT,QAAQ,CAACU,cAAT,CAAwBN,EAAE,CAACO,IAA3B,CAAjB;AAEA,UAAMF,QAAQ,CAACG,IAAT,EAAN;AAEAlB,IAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EAEf;AACEJ,MAAAA,QADF;AAEE;AACA;AACAH,MAAAA,SAAS,EAAE;AAJb,KAFe,EAQfL,YARe,EASfC,eATe,CAAjB;AAWD,GAhBD,CAgBE,OAAOY,CAAP,EAAU;AACV,QAAIA,CAAC,CAACC,OAAF,CAAUC,KAAV,CAAgB,oBAAhB,CAAJ,EAA2C;AACzC,YAAMC,WAAW,GAAGtB,oBAAoB,CAACc,QAAQ,CAACS,OAAV,CAAxC;AACA,UAAIC,MAAJ;;AACA,UAAIF,WAAW,KAAK,SAApB,EAA+B;AAC7BE,QAAAA,MAAM,GAAG,MAAMvB,eAAe,CAACQ,EAAE,CAACO,IAAJ,EAAUM,WAAV,CAA9B;AACD;;AAEDvB,MAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EAEf;AACEJ,QAAAA,QADF;AAEEU,QAAAA,MAFF;AAGEC,QAAAA,KAAK,EAAE,IAHT;AAIEd,QAAAA,SAAS,EAAE;AAJb,OAFe,EAQfL,YARe,EASfC,eATe,CAAjB;AAWD,KAlBD,MAkBO;AACLmB,MAAAA,OAAO,CAACD,KAAR,CAAcN,CAAd;AACD;;AAED,QAAI,CAACL,QAAL,EAAe;AACbf,MAAAA,iBAAiB,CACfU,EAAE,CAACS,EADY,EACR;AACLM,QAAAA,MAAM,EAAE,0DADH;AAELC,QAAAA,KAAK,EAAE,IAFF;AAGLd,QAAAA,SAAS,EAAE;AAHN,OADQ,EAMfL,YANe,EAOfC,eAPe,CAAjB;AASD;AACF;AACF,CA1DD","sourcesContent":["import { updateTransaction } from 'lib/services/updateTransaction'\nimport { chainIdToNetworkName } from 'lib/utils/chainIdToNetworkName'\n\n// import { getRevertReason } from 'lib/utils/getRevertReason'\nconst getRevertReason = require('eth-revert-reason')\n\nexport const checkTransactionStatuses = (\n  localStorageTransactions,\n  provider,\n  transactions,\n  setTransactions\n) => {\n  localStorageTransactions = localStorageTransactions.filter(tx => tx.sent && !tx.completed)\n    .map(tx => runAsyncCheckTx(tx, provider, localStorageTransactions, setTransactions))\n}\n\nconst runAsyncCheckTx = async (\n  tx,\n  provider,\n  transactions,\n  setTransactions\n) => {\n  let ethersTx\n  try {\n    ethersTx = await provider.getTransaction(tx.hash)\n\n    await ethersTx.wait()\n\n    updateTransaction(\n      tx.id,\n      {\n        ethersTx,\n        // reason,\n        // error: reason.length > 0,\n        completed: true,\n      },\n      transactions,\n      setTransactions\n    )\n  } catch (e) {\n    if (e.message.match('transaction failed')) {\n      const networkName = chainIdToNetworkName(ethersTx.chainId)\n      let reason\n      if (networkName !== 'rinkeby') {\n        reason = await getRevertReason(tx.hash, networkName)\n      }\n\n      updateTransaction(\n        tx.id,\n        {\n          ethersTx,\n          reason,\n          error: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n    } else {\n      console.error(e)\n    }\n\n    if (!ethersTx) {\n      updateTransaction(\n        tx.id, {\n          reason: 'Failed to send, could not find transaction on blockchain',\n          error: true,\n          completed: true,\n        },\n        transactions,\n        setTransactions\n      )\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}