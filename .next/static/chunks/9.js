(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[9],{

/***/ "./lib/services/initOnboard.js":
/*!*************************************!*\
  !*** ./lib/services/initOnboard.js ***!
  \*************************************/
/*! exports provided: initOnboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initOnboard\", function() { return initOnboard; });\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _pooltogether_bnc_onboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pooltogether/bnc-onboard */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard.js\");\n/* harmony import */ var lib_utils_networkNameToChainId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib/utils/networkNameToChainId */ \"./lib/utils/networkNameToChainId.js\");\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('pool-app:initOnboard');\n\nvar INFURA_KEY = \"5e378f49a3994737940a897b2d95222b\";\nvar FORTMATIC_KEY =  false || \"pk_test_BC1966CB2D1478D7\";\nvar PORTIS_KEY = \"59408c8d-a0a2-42df-ba09-f1372ddbe3e1\";\nvar networkName = \"mainnet\";\nvar networkId = Object(lib_utils_networkNameToChainId__WEBPACK_IMPORTED_MODULE_2__[\"networkNameToChainId\"])(networkName);\nvar RPC_URL = networkName && INFURA_KEY ? \"https://\".concat(networkName, \".infura.io/v3/\").concat(INFURA_KEY) : 'http://localhost:8545';\nvar cookieOptions = {\n  sameSite: 'strict'\n};\n\nif (false) {}\n\nvar APP_NAME = 'PoolTogether';\nvar WALLETS_CONFIG = [{\n  walletName: 'metamask',\n  preferred: true\n}, {\n  walletName: 'coinbase',\n  preferred: true\n}, {\n  walletName: 'trust',\n  preferred: true,\n  rpcUrl: RPC_URL\n}, {\n  walletName: 'trezor',\n  appUrl: 'https://app.pooltogether.com',\n  email: 'hello@pooltogether.com',\n  rpcUrl: RPC_URL,\n  preferred: true\n}, {\n  walletName: 'ledger',\n  rpcUrl: RPC_URL,\n  preferred: true\n}, {\n  walletName: 'fortmatic',\n  apiKey: FORTMATIC_KEY,\n  preferred: true\n}, {\n  walletName: 'walletConnect',\n  infuraKey: INFURA_KEY,\n  preferred: true\n}, {\n  walletName: 'walletLink',\n  rpcUrl: RPC_URL,\n  preferred: true\n}, {\n  walletName: 'imToken',\n  rpcUrl: RPC_URL,\n  preferred: true\n}, {\n  walletName: 'dcent'\n}, {\n  walletName: 'huobiwallet',\n  rpcUrl: RPC_URL\n}, {\n  walletName: 'portis',\n  apiKey: PORTIS_KEY\n}, {\n  walletName: 'authereum'\n}, {\n  walletName: 'dapper'\n}, {\n  walletName: 'status'\n}, {\n  walletName: 'torus'\n}, {\n  walletName: 'lattice',\n  rpcUrl: RPC_URL,\n  appName: APP_NAME\n}, {\n  walletName: 'mykey',\n  rpcUrl: RPC_URL\n}, {\n  walletName: 'opera'\n}, {\n  walletName: 'operaTouch'\n}, {\n  walletName: 'web3Wallet'\n}];\nvar initOnboard = function initOnboard(subscriptions) {\n  var onboard = _pooltogether_bnc_onboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n  debug('RUNNING initOnboard!');\n  return onboard({\n    hideBranding: true,\n    networkId: networkId,\n    darkMode: true,\n    subscriptions: subscriptions,\n    walletSelect: {\n      wallets: WALLETS_CONFIG\n    },\n    walletCheck: [{\n      checkName: 'derivationPath'\n    }, {\n      checkName: 'connect'\n    }, {\n      checkName: 'accounts'\n    }, {\n      checkName: 'network'\n    } // { checkName: 'balance' }\n    ]\n  });\n};\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3NlcnZpY2VzL2luaXRPbmJvYXJkLmpzPzE4YTAiXSwibmFtZXMiOlsiZGVidWciLCJyZXF1aXJlIiwiSU5GVVJBX0tFWSIsInByb2Nlc3MiLCJGT1JUTUFUSUNfS0VZIiwiUE9SVElTX0tFWSIsIm5ldHdvcmtOYW1lIiwibmV0d29ya0lkIiwibmV0d29ya05hbWVUb0NoYWluSWQiLCJSUENfVVJMIiwiY29va2llT3B0aW9ucyIsInNhbWVTaXRlIiwiQVBQX05BTUUiLCJXQUxMRVRTX0NPTkZJRyIsIndhbGxldE5hbWUiLCJwcmVmZXJyZWQiLCJycGNVcmwiLCJhcHBVcmwiLCJlbWFpbCIsImFwaUtleSIsImluZnVyYUtleSIsImFwcE5hbWUiLCJpbml0T25ib2FyZCIsInN1YnNjcmlwdGlvbnMiLCJvbmJvYXJkIiwiT25ib2FyZCIsImhpZGVCcmFuZGluZyIsImRhcmtNb2RlIiwid2FsbGV0U2VsZWN0Iiwid2FsbGV0cyIsIndhbGxldENoZWNrIiwiY2hlY2tOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBRUE7O0FBRUEsSUFBTUEsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLGtEQUFELENBQVAsQ0FBaUIsc0JBQWpCLENBQWQ7O0FBRUEsSUFBTUMsVUFBVSxHQUFHQyxrQ0FBbkI7QUFDQSxJQUFNQyxhQUFhLEdBQUdELE1BQUEsSUFDcEJBLDBCQURGO0FBRUEsSUFBTUUsVUFBVSxHQUFHRixzQ0FBbkI7QUFFQSxJQUFNRyxXQUFXLEdBQUdILFNBQXBCO0FBQ0EsSUFBTUksU0FBUyxHQUFHQywyRkFBb0IsQ0FBQ0YsV0FBRCxDQUF0QztBQUNBLElBQU1HLE9BQU8sR0FBSUgsV0FBVyxJQUFJSixVQUFoQixxQkFDSEksV0FERywyQkFDeUJKLFVBRHpCLElBRWQsdUJBRkY7QUFJQSxJQUFJUSxhQUFhLEdBQUc7QUFBRUMsVUFBUSxFQUFFO0FBQVosQ0FBcEI7O0FBQ0EsSUFBSVIsS0FBSixFQUFxQyxFQUtw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dCBPbmJvYXJkIGZyb20gJ0Bwb29sdG9nZXRoZXIvYm5jLW9uYm9hcmQnXG5cbmltcG9ydCB7IG5ldHdvcmtOYW1lVG9DaGFpbklkIH0gZnJvbSAnbGliL3V0aWxzL25ldHdvcmtOYW1lVG9DaGFpbklkJ1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3Bvb2wtYXBwOmluaXRPbmJvYXJkJylcblxuY29uc3QgSU5GVVJBX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfSlNfSU5GVVJBX0tFWVxuY29uc3QgRk9SVE1BVElDX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfSlNfRk9SVE1BVElDX1BST0RVQ1RJT05fQVBJX0tFWSB8fCBcbiAgcHJvY2Vzcy5lbnYuTkVYVF9KU19GT1JUTUFUSUNfQVBJX0tFWVxuY29uc3QgUE9SVElTX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfSlNfUE9SVElTX0FQSV9LRVlcblxuY29uc3QgbmV0d29ya05hbWUgPSBwcm9jZXNzLmVudi5ORVhUX0pTX0RFRkFVTFRfRVRIRVJFVU1fTkVUV09SS19OQU1FXG5jb25zdCBuZXR3b3JrSWQgPSBuZXR3b3JrTmFtZVRvQ2hhaW5JZChuZXR3b3JrTmFtZSlcbmNvbnN0IFJQQ19VUkwgPSAobmV0d29ya05hbWUgJiYgSU5GVVJBX0tFWSkgP1xuICBgaHR0cHM6Ly8ke25ldHdvcmtOYW1lfS5pbmZ1cmEuaW8vdjMvJHtJTkZVUkFfS0VZfWAgOlxuICAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1J1xuXG5sZXQgY29va2llT3B0aW9ucyA9IHsgc2FtZVNpdGU6ICdzdHJpY3QnIH1cbmlmIChwcm9jZXNzLmVudi5ORVhUX0pTX0RPTUFJTl9OQU1FKSB7XG4gIGNvb2tpZU9wdGlvbnMgPSB7XG4gICAgLi4uY29va2llT3B0aW9ucyxcbiAgICBkb21haW46IGAuJHtwcm9jZXNzLmVudi5ORVhUX0pTX0RPTUFJTl9OQU1FfWBcbiAgfVxufVxuXG5jb25zdCBBUFBfTkFNRSA9ICdQb29sVG9nZXRoZXInXG5cbmNvbnN0IFdBTExFVFNfQ09ORklHID0gW1xuICB7IHdhbGxldE5hbWU6ICdtZXRhbWFzaycsIHByZWZlcnJlZDogdHJ1ZSB9LFxuICB7IHdhbGxldE5hbWU6ICdjb2luYmFzZScsIHByZWZlcnJlZDogdHJ1ZSB9LFxuICB7IHdhbGxldE5hbWU6ICd0cnVzdCcsIHByZWZlcnJlZDogdHJ1ZSwgcnBjVXJsOiBSUENfVVJMIH0sXG4gIHtcbiAgICB3YWxsZXROYW1lOiAndHJlem9yJyxcbiAgICBhcHBVcmw6ICdodHRwczovL2FwcC5wb29sdG9nZXRoZXIuY29tJyxcbiAgICBlbWFpbDogJ2hlbGxvQHBvb2x0b2dldGhlci5jb20nLFxuICAgIHJwY1VybDogUlBDX1VSTCxcbiAgICBwcmVmZXJyZWQ6IHRydWVcbiAgfSxcbiAge1xuICAgIHdhbGxldE5hbWU6ICdsZWRnZXInLFxuICAgIHJwY1VybDogUlBDX1VSTCxcbiAgICBwcmVmZXJyZWQ6IHRydWVcbiAgfSxcbiAge1xuICAgIHdhbGxldE5hbWU6ICdmb3J0bWF0aWMnLFxuICAgIGFwaUtleTogRk9SVE1BVElDX0tFWSxcbiAgICBwcmVmZXJyZWQ6IHRydWVcbiAgfSxcbiAge1xuICAgIHdhbGxldE5hbWU6ICd3YWxsZXRDb25uZWN0JyxcbiAgICBpbmZ1cmFLZXk6IElORlVSQV9LRVksXG4gICAgcHJlZmVycmVkOiB0cnVlXG4gIH0sXG4gIHtcbiAgICB3YWxsZXROYW1lOiAnd2FsbGV0TGluaycsXG4gICAgcnBjVXJsOiBSUENfVVJMLFxuICAgIHByZWZlcnJlZDogdHJ1ZVxuICB9LFxuICB7XG4gICAgd2FsbGV0TmFtZTogJ2ltVG9rZW4nLFxuICAgIHJwY1VybDogUlBDX1VSTCxcbiAgICBwcmVmZXJyZWQ6IHRydWVcbiAgfSxcbiAgeyB3YWxsZXROYW1lOiAnZGNlbnQnIH0sXG4gIHtcbiAgICB3YWxsZXROYW1lOiAnaHVvYml3YWxsZXQnLFxuICAgIHJwY1VybDogUlBDX1VSTFxuICB9LFxuICB7XG4gICAgd2FsbGV0TmFtZTogJ3BvcnRpcycsXG4gICAgYXBpS2V5OiBQT1JUSVNfS0VZLFxuICB9LFxuICB7IHdhbGxldE5hbWU6ICdhdXRoZXJldW0nIH0sXG4gIHsgd2FsbGV0TmFtZTogJ2RhcHBlcicgfSxcbiAgeyB3YWxsZXROYW1lOiAnc3RhdHVzJyB9LFxuICB7IHdhbGxldE5hbWU6ICd0b3J1cycgfSxcbiAge1xuICAgIHdhbGxldE5hbWU6ICdsYXR0aWNlJyxcbiAgICBycGNVcmw6IFJQQ19VUkwsXG4gICAgYXBwTmFtZTogQVBQX05BTUVcbiAgfSxcbiAgeyB3YWxsZXROYW1lOiAnbXlrZXknLCBycGNVcmw6IFJQQ19VUkwgfSxcbiAgeyB3YWxsZXROYW1lOiAnb3BlcmEnIH0sXG4gIHsgd2FsbGV0TmFtZTogJ29wZXJhVG91Y2gnIH0sXG4gIHsgd2FsbGV0TmFtZTogJ3dlYjNXYWxsZXQnIH0sXG5dXG5cbmV4cG9ydCBjb25zdCBpbml0T25ib2FyZCA9IChzdWJzY3JpcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9uYm9hcmQgPSBPbmJvYXJkXG5cbiAgZGVidWcoJ1JVTk5JTkcgaW5pdE9uYm9hcmQhJylcblxuICByZXR1cm4gb25ib2FyZCh7XG4gICAgaGlkZUJyYW5kaW5nOiB0cnVlLFxuICAgIG5ldHdvcmtJZCxcbiAgICBkYXJrTW9kZTogdHJ1ZSxcbiAgICBzdWJzY3JpcHRpb25zLFxuICAgIHdhbGxldFNlbGVjdDoge1xuICAgICAgd2FsbGV0czogV0FMTEVUU19DT05GSUdcbiAgICB9LFxuICAgIHdhbGxldENoZWNrOiBbXG4gICAgICB7IGNoZWNrTmFtZTogJ2Rlcml2YXRpb25QYXRoJyB9LFxuICAgICAgeyBjaGVja05hbWU6ICdjb25uZWN0JyB9LFxuICAgICAgeyBjaGVja05hbWU6ICdhY2NvdW50cycgfSxcbiAgICAgIHsgY2hlY2tOYW1lOiAnbmV0d29yaycgfSxcbiAgICAgIC8vIHsgY2hlY2tOYW1lOiAnYmFsYW5jZScgfVxuICAgIF1cbiAgfSlcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/services/initOnboard.js\n");

/***/ }),

/***/ "./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard-197ee608.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard-197ee608.js ***!
  \*****************************************************************************/
/*! exports provided: a, b, c, i, n, o */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return networkToId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return balanceIcon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return connectIcon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return init$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return networkName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return openLink; });\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/@pooltogether/bnc-onboard/node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bnc-sdk */ \"./node_modules/bnc-sdk/dist/esm/index.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_3__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\n\nfunction noop() {}\n\nvar identity = function identity(x) {\n  return x;\n};\n\nfunction assign(tar, src) {\n  // @ts-ignore\n  for (var k in src) {\n    tar[k] = src[k];\n  }\n\n  return tar;\n}\n\nfunction run(fn) {\n  return fn();\n}\n\nfunction blank_object() {\n  return Object.create(null);\n}\n\nfunction run_all(fns) {\n  fns.forEach(run);\n}\n\nfunction is_function(thing) {\n  return typeof thing === 'function';\n}\n\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n}\n\nfunction subscribe(store) {\n  if (store == null) {\n    return noop;\n  }\n\n  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    callbacks[_key - 1] = arguments[_key];\n  }\n\n  var unsub = store.subscribe.apply(store, callbacks);\n  return unsub.unsubscribe ? function () {\n    return unsub.unsubscribe();\n  } : unsub;\n}\n\nfunction get_store_value(store) {\n  var value;\n  subscribe(store, function (_) {\n    return value = _;\n  })();\n  return value;\n}\n\nfunction component_subscribe(component, store, callback) {\n  component.$$.on_destroy.push(subscribe(store, callback));\n}\n\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    var lets = definition[2](fn(dirty));\n\n    if ($$scope.dirty === undefined) {\n      return lets;\n    }\n\n    if (_typeof(lets) === 'object') {\n      var merged = [];\n      var len = Math.max($$scope.dirty.length, lets.length);\n\n      for (var i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n\n      return merged;\n    }\n\n    return $$scope.dirty | lets;\n  }\n\n  return $$scope.dirty;\n}\n\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n  var slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\n  if (slot_changes) {\n    var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\n\nvar is_client = typeof window !== 'undefined';\nvar now = is_client ? function () {\n  return window.performance.now();\n} : function () {\n  return Date.now();\n};\nvar raf = is_client ? function (cb) {\n  return requestAnimationFrame(cb);\n} : noop;\nvar tasks = new Set();\n\nfunction run_tasks(now) {\n  tasks.forEach(function (task) {\n    if (!task.c(now)) {\n      tasks[\"delete\"](task);\n      task.f();\n    }\n  });\n  if (tasks.size !== 0) raf(run_tasks);\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\n\n\nfunction loop(callback) {\n  var task;\n  if (tasks.size === 0) raf(run_tasks);\n  return {\n    promise: new Promise(function (fulfill) {\n      tasks.add(task = {\n        c: callback,\n        f: fulfill\n      });\n    }),\n    abort: function abort() {\n      tasks[\"delete\"](task);\n    }\n  };\n}\n\nfunction append(target, node) {\n  target.appendChild(node);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\nfunction detach(node) {\n  node.parentNode.removeChild(node);\n}\n\nfunction element(name) {\n  return document.createElement(name);\n}\n\nfunction svg_element(name) {\n  return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\nfunction text(data) {\n  return document.createTextNode(data);\n}\n\nfunction space() {\n  return text(' ');\n}\n\nfunction empty() {\n  return text('');\n}\n\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return function () {\n    return node.removeEventListener(event, handler, options);\n  };\n}\n\nfunction attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.wholeText !== data) text.data = data;\n}\n\nfunction set_style(node, key, value, important) {\n  node.style.setProperty(key, value, important ? 'important' : '');\n}\n\nfunction toggle_class(element, name, toggle) {\n  element.classList[toggle ? 'add' : 'remove'](name);\n}\n\nfunction custom_event(type, detail) {\n  var e = document.createEvent('CustomEvent');\n  e.initCustomEvent(type, false, false, detail);\n  return e;\n}\n\nvar HtmlTag = /*#__PURE__*/function () {\n  function HtmlTag() {\n    var anchor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, HtmlTag);\n\n    this.a = anchor;\n    this.e = this.n = null;\n  }\n\n  _createClass(HtmlTag, [{\n    key: \"m\",\n    value: function m(html, target) {\n      var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      if (!this.e) {\n        this.e = element(target.nodeName);\n        this.t = target;\n        this.h(html);\n      }\n\n      this.i(anchor);\n    }\n  }, {\n    key: \"h\",\n    value: function h(html) {\n      this.e.innerHTML = html;\n      this.n = Array.from(this.e.childNodes);\n    }\n  }, {\n    key: \"i\",\n    value: function i(anchor) {\n      for (var i = 0; i < this.n.length; i += 1) {\n        insert(this.t, this.n[i], anchor);\n      }\n    }\n  }, {\n    key: \"p\",\n    value: function p(html) {\n      this.d();\n      this.h(html);\n      this.i(this.a);\n    }\n  }, {\n    key: \"d\",\n    value: function d() {\n      this.n.forEach(detach);\n    }\n  }]);\n\n  return HtmlTag;\n}();\n\nvar active_docs = new Set();\nvar active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n\n  while (i--) {\n    hash = (hash << 5) - hash ^ str.charCodeAt(i);\n  }\n\n  return hash >>> 0;\n}\n\nfunction create_rule(node, a, b, duration, delay, ease, fn) {\n  var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  var step = 16.666 / duration;\n  var keyframes = '{\\n';\n\n  for (var p = 0; p <= 1; p += step) {\n    var t = a + (b - a) * ease(p);\n    keyframes += p * 100 + \"%{\".concat(fn(t, 1 - t), \"}\\n\");\n  }\n\n  var rule = keyframes + \"100% {\".concat(fn(b, 1 - b), \"}\\n}\");\n  var name = \"__svelte_\".concat(hash(rule), \"_\").concat(uid);\n  var doc = node.ownerDocument;\n  active_docs.add(doc);\n  var stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n  var current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n\n  if (!current_rules[name]) {\n    current_rules[name] = true;\n    stylesheet.insertRule(\"@keyframes \".concat(name, \" \").concat(rule), stylesheet.cssRules.length);\n  }\n\n  var animation = node.style.animation || '';\n  node.style.animation = \"\".concat(animation ? \"\".concat(animation, \", \") : \"\").concat(name, \" \").concat(duration, \"ms linear \").concat(delay, \"ms 1 both\");\n  active += 1;\n  return name;\n}\n\nfunction delete_rule(node, name) {\n  var previous = (node.style.animation || '').split(', ');\n  var next = previous.filter(name ? function (anim) {\n    return anim.indexOf(name) < 0;\n  } // remove specific animation\n  : function (anim) {\n    return anim.indexOf('__svelte') === -1;\n  } // remove all Svelte animations\n  );\n  var deleted = previous.length - next.length;\n\n  if (deleted) {\n    node.style.animation = next.join(', ');\n    active -= deleted;\n    if (!active) clear_rules();\n  }\n}\n\nfunction clear_rules() {\n  raf(function () {\n    if (active) return;\n    active_docs.forEach(function (doc) {\n      var stylesheet = doc.__svelte_stylesheet;\n      var i = stylesheet.cssRules.length;\n\n      while (i--) {\n        stylesheet.deleteRule(i);\n      }\n\n      doc.__svelte_rules = {};\n    });\n    active_docs.clear();\n  });\n}\n\nvar current_component;\n\nfunction set_current_component(component) {\n  current_component = component;\n}\n\nfunction get_current_component() {\n  if (!current_component) throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\n\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\n\nfunction onDestroy(fn) {\n  get_current_component().$$.on_destroy.push(fn);\n}\n\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = Promise.resolve();\nvar update_scheduled = false;\n\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\nvar flushing = false;\nvar seen_callbacks = new Set();\n\nfunction flush() {\n  if (flushing) return;\n  flushing = true;\n\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    for (var i = 0; i < dirty_components.length; i += 1) {\n      var component = dirty_components[i];\n      set_current_component(component);\n      update(component.$$);\n    }\n\n    dirty_components.length = 0;\n\n    while (binding_callbacks.length) {\n      binding_callbacks.pop()();\n    } // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n\n\n    for (var _i = 0; _i < render_callbacks.length; _i += 1) {\n      var callback = render_callbacks[_i];\n\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n\n  update_scheduled = false;\n  flushing = false;\n  seen_callbacks.clear();\n}\n\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    var dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\n\nvar promise;\n\nfunction wait() {\n  if (!promise) {\n    promise = Promise.resolve();\n    promise.then(function () {\n      promise = null;\n    });\n  }\n\n  return promise;\n}\n\nfunction dispatch(node, direction, kind) {\n  node.dispatchEvent(custom_event(\"\".concat(direction ? 'intro' : 'outro').concat(kind)));\n}\n\nvar outroing = new Set();\nvar outros;\n\nfunction group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n\n  };\n}\n\nfunction check_outros() {\n  if (!outros.r) {\n    run_all(outros.c);\n  }\n\n  outros = outros.p;\n}\n\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing[\"delete\"](block);\n    block.i(local);\n  }\n}\n\nfunction transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(function () {\n      outroing[\"delete\"](block);\n\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  }\n}\n\nvar null_transition = {\n  duration: 0\n};\n\nfunction create_in_transition(node, fn, params) {\n  var config = fn(node, params);\n  var running = false;\n  var animation_name;\n  var task;\n  var uid = 0;\n\n  function cleanup() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  function go() {\n    var _ref = config || null_transition,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 300 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? identity : _ref$easing,\n        _ref$tick = _ref.tick,\n        tick = _ref$tick === void 0 ? noop : _ref$tick,\n        css = _ref.css;\n\n    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n    tick(0, 1);\n    var start_time = now() + delay;\n    var end_time = start_time + duration;\n    if (task) task.abort();\n    running = true;\n    add_render_callback(function () {\n      return dispatch(node, true, 'start');\n    });\n    task = loop(function (now) {\n      if (running) {\n        if (now >= end_time) {\n          tick(1, 0);\n          dispatch(node, true, 'end');\n          cleanup();\n          return running = false;\n        }\n\n        if (now >= start_time) {\n          var t = easing((now - start_time) / duration);\n          tick(t, 1 - t);\n        }\n      }\n\n      return running;\n    });\n  }\n\n  var started = false;\n  return {\n    start: function start() {\n      if (started) return;\n      delete_rule(node);\n\n      if (is_function(config)) {\n        config = config();\n        wait().then(go);\n      } else {\n        go();\n      }\n    },\n    invalidate: function invalidate() {\n      started = false;\n    },\n    end: function end() {\n      if (running) {\n        cleanup();\n        running = false;\n      }\n    }\n  };\n}\n\nfunction create_bidirectional_transition(node, fn, params, intro) {\n  var config = fn(node, params);\n  var t = intro ? 0 : 1;\n  var running_program = null;\n  var pending_program = null;\n  var animation_name = null;\n\n  function clear_animation() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  function init(program, duration) {\n    var d = program.b - t;\n    duration *= Math.abs(d);\n    return {\n      a: t,\n      b: program.b,\n      d: d,\n      duration: duration,\n      start: program.start,\n      end: program.start + duration,\n      group: program.group\n    };\n  }\n\n  function go(b) {\n    var _ref2 = config || null_transition,\n        _ref2$delay = _ref2.delay,\n        delay = _ref2$delay === void 0 ? 0 : _ref2$delay,\n        _ref2$duration = _ref2.duration,\n        duration = _ref2$duration === void 0 ? 300 : _ref2$duration,\n        _ref2$easing = _ref2.easing,\n        easing = _ref2$easing === void 0 ? identity : _ref2$easing,\n        _ref2$tick = _ref2.tick,\n        tick = _ref2$tick === void 0 ? noop : _ref2$tick,\n        css = _ref2.css;\n\n    var program = {\n      start: now() + delay,\n      b: b\n    };\n\n    if (!b) {\n      // @ts-ignore todo: improve typings\n      program.group = outros;\n      outros.r += 1;\n    }\n\n    if (running_program) {\n      pending_program = program;\n    } else {\n      // if this is an intro, and there's a delay, we need to do\n      // an initial tick and/or apply CSS animation immediately\n      if (css) {\n        clear_animation();\n        animation_name = create_rule(node, t, b, duration, delay, easing, css);\n      }\n\n      if (b) tick(0, 1);\n      running_program = init(program, duration);\n      add_render_callback(function () {\n        return dispatch(node, b, 'start');\n      });\n      loop(function (now) {\n        if (pending_program && now > pending_program.start) {\n          running_program = init(pending_program, duration);\n          pending_program = null;\n          dispatch(node, running_program.b, 'start');\n\n          if (css) {\n            clear_animation();\n            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n          }\n        }\n\n        if (running_program) {\n          if (now >= running_program.end) {\n            tick(t = running_program.b, 1 - t);\n            dispatch(node, running_program.b, 'end');\n\n            if (!pending_program) {\n              // we're done\n              if (running_program.b) {\n                // intro — we can tidy up immediately\n                clear_animation();\n              } else {\n                // outro — needs to be coordinated\n                if (! --running_program.group.r) run_all(running_program.group.c);\n              }\n            }\n\n            running_program = null;\n          } else if (now >= running_program.start) {\n            var p = now - running_program.start;\n            t = running_program.a + running_program.d * easing(p / running_program.duration);\n            tick(t, 1 - t);\n          }\n        }\n\n        return !!(running_program || pending_program);\n      });\n    }\n  }\n\n  return {\n    run: function run(b) {\n      if (is_function(config)) {\n        wait().then(function () {\n          // @ts-ignore\n          config = config();\n          go(b);\n        });\n      } else {\n        go(b);\n      }\n    },\n    end: function end() {\n      clear_animation();\n      running_program = pending_program = null;\n    }\n  };\n}\n\nfunction outro_and_destroy_block(block, lookup) {\n  transition_out(block, 1, 1, function () {\n    lookup[\"delete\"](block.key);\n  });\n}\n\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n  var o = old_blocks.length;\n  var n = list.length;\n  var i = o;\n  var old_indexes = {};\n\n  while (i--) {\n    old_indexes[old_blocks[i].key] = i;\n  }\n\n  var new_blocks = [];\n  var new_lookup = new Map();\n  var deltas = new Map();\n  i = n;\n\n  while (i--) {\n    var child_ctx = get_context(ctx, list, i);\n    var key = get_key(child_ctx);\n    var block = lookup.get(key);\n\n    if (!block) {\n      block = create_each_block(key, child_ctx);\n      block.c();\n    } else if (dynamic) {\n      block.p(child_ctx, dirty);\n    }\n\n    new_lookup.set(key, new_blocks[i] = block);\n    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n  }\n\n  var will_move = new Set();\n  var did_move = new Set();\n\n  function insert(block) {\n    transition_in(block, 1);\n    block.m(node, next);\n    lookup.set(block.key, block);\n    next = block.first;\n    n--;\n  }\n\n  while (o && n) {\n    var new_block = new_blocks[n - 1];\n    var old_block = old_blocks[o - 1];\n    var new_key = new_block.key;\n    var old_key = old_block.key;\n\n    if (new_block === old_block) {\n      // do nothing\n      next = new_block.first;\n      o--;\n      n--;\n    } else if (!new_lookup.has(old_key)) {\n      // remove old block\n      destroy(old_block, lookup);\n      o--;\n    } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n      insert(new_block);\n    } else if (did_move.has(old_key)) {\n      o--;\n    } else if (deltas.get(new_key) > deltas.get(old_key)) {\n      did_move.add(new_key);\n      insert(new_block);\n    } else {\n      will_move.add(old_key);\n      o--;\n    }\n  }\n\n  while (o--) {\n    var _old_block = old_blocks[o];\n    if (!new_lookup.has(_old_block.key)) destroy(_old_block, lookup);\n  }\n\n  while (n) {\n    insert(new_blocks[n - 1]);\n  }\n\n  return new_blocks;\n}\n\nfunction create_component(block) {\n  block && block.c();\n}\n\nfunction mount_component(component, target, anchor) {\n  var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n  fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate\n\n  add_render_callback(function () {\n    var new_on_destroy = on_mount.map(run).filter(is_function);\n\n    if (on_destroy) {\n      on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n    } else {\n      // Edge case - component was destroyed immediately,\n      // most likely as a result of a binding initialising\n      run_all(new_on_destroy);\n    }\n\n    component.$$.on_mount = [];\n  });\n  after_update.forEach(add_render_callback);\n}\n\nfunction destroy_component(component, detaching) {\n  var $$ = component.$$;\n\n  if ($$.fragment !== null) {\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\nfunction init(component, options, instance, create_fragment, not_equal, props) {\n  var dirty = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-1];\n  var parent_component = current_component;\n  set_current_component(component);\n  var prop_values = options.props || {};\n  var $$ = component.$$ = {\n    fragment: null,\n    ctx: null,\n    // state\n    props: props,\n    update: noop,\n    not_equal: not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(parent_component ? parent_component.$$.context : []),\n    // everything else\n    callbacks: blank_object(),\n    dirty: dirty\n  };\n  var ready = false;\n  $$.ctx = instance ? instance(component, prop_values, function (i, ret) {\n    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if ($$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update); // `false` as a special case of no DOM component\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n  if (options.target) {\n    if (options.hydrate) {\n      var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n\n    if (options.intro) transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor);\n    flush();\n  }\n\n  set_current_component(parent_component);\n}\n\nvar SvelteComponent = /*#__PURE__*/function () {\n  function SvelteComponent() {\n    _classCallCheck(this, SvelteComponent);\n  }\n\n  _createClass(SvelteComponent, [{\n    key: \"$destroy\",\n    value: function $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n  }, {\n    key: \"$on\",\n    value: function $on(type, callback) {\n      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return function () {\n        var index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      };\n    }\n  }, {\n    key: \"$set\",\n    value: function $set() {// overridden by instance, if it has props\n    }\n  }]);\n\n  return SvelteComponent;\n}();\n\nvar subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\n\nfunction readable(value, start) {\n  return {\n    subscribe: writable(value, start).subscribe\n  };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\n\n\nfunction writable(value) {\n  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  var stop;\n  var subscribers = [];\n\n  function set(new_value) {\n    if (safe_not_equal(value, new_value)) {\n      value = new_value;\n\n      if (stop) {\n        // store is ready\n        var run_queue = !subscriber_queue.length;\n\n        for (var i = 0; i < subscribers.length; i += 1) {\n          var s = subscribers[i];\n          s[1]();\n          subscriber_queue.push(s, value);\n        }\n\n        if (run_queue) {\n          for (var _i2 = 0; _i2 < subscriber_queue.length; _i2 += 2) {\n            subscriber_queue[_i2][0](subscriber_queue[_i2 + 1]);\n          }\n\n          subscriber_queue.length = 0;\n        }\n      }\n    }\n  }\n\n  function update(fn) {\n    set(fn(value));\n  }\n\n  function subscribe(run) {\n    var invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    var subscriber = [run, invalidate];\n    subscribers.push(subscriber);\n\n    if (subscribers.length === 1) {\n      stop = start(set) || noop;\n    }\n\n    run(value);\n    return function () {\n      var index = subscribers.indexOf(subscriber);\n\n      if (index !== -1) {\n        subscribers.splice(index, 1);\n      }\n\n      if (subscribers.length === 0) {\n        stop();\n        stop = null;\n      }\n    };\n  }\n\n  return {\n    set: set,\n    update: update,\n    subscribe: subscribe\n  };\n}\n\nfunction derived(stores, fn, initial_value) {\n  var single = !Array.isArray(stores);\n  var stores_array = single ? [stores] : stores;\n  var auto = fn.length < 2;\n  return readable(initial_value, function (set) {\n    var inited = false;\n    var values = [];\n    var pending = 0;\n    var cleanup = noop;\n\n    var sync = function sync() {\n      if (pending) {\n        return;\n      }\n\n      cleanup();\n      var result = fn(single ? values[0] : values, set);\n\n      if (auto) {\n        set(result);\n      } else {\n        cleanup = is_function(result) ? result : noop;\n      }\n    };\n\n    var unsubscribers = stores_array.map(function (store, i) {\n      return subscribe(store, function (value) {\n        values[i] = value;\n        pending &= ~(1 << i);\n\n        if (inited) {\n          sync();\n        }\n      }, function () {\n        pending |= 1 << i;\n      });\n    });\n    inited = true;\n    sync();\n    return function stop() {\n      run_all(unsubscribers);\n      cleanup();\n    };\n  });\n}\n\nfunction fade(node, _ref3) {\n  var _ref3$delay = _ref3.delay,\n      delay = _ref3$delay === void 0 ? 0 : _ref3$delay,\n      _ref3$duration = _ref3.duration,\n      duration = _ref3$duration === void 0 ? 400 : _ref3$duration,\n      _ref3$easing = _ref3.easing,\n      easing = _ref3$easing === void 0 ? identity : _ref3$easing;\n  var o = +getComputedStyle(node).opacity;\n  return {\n    delay: delay,\n    duration: duration,\n    easing: easing,\n    css: function css(t) {\n      return \"opacity: \".concat(t * o);\n    }\n  };\n}\n\nvar blocknative;\n\nfunction initializeBlocknative(dappId, networkId, apiUrl) {\n  blocknative = new bnc_sdk__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n    dappId: dappId,\n    networkId: networkId,\n    name: 'Onboard',\n    apiUrl: apiUrl\n  });\n  return blocknative;\n}\n\nfunction getBlocknative() {\n  return blocknative;\n}\n\nfunction getNetwork(provider) {\n  return new Promise(function (resolve, reject) {\n    var options = {\n      jsonrpc: '2.0',\n      method: 'net_version',\n      params: [],\n      id: 42\n    }; // use MetaMask parameter if there\n\n    if (provider.chainId) {\n      return resolve(Number(provider.chainId));\n    }\n\n    var callback = function callback(e, res) {\n      e && reject(e);\n      var result = res && res.result;\n      resolve(result && Number(result));\n    };\n\n    if (typeof provider.sendAsync === 'function') {\n      provider.sendAsync(options, callback);\n    } else if (typeof provider.send === 'function') {\n      provider.send(options, callback);\n    } else {\n      resolve(null);\n    }\n  });\n}\n\nfunction getAddress(provider) {\n  return new Promise(function (resolve, reject) {\n    var options = {\n      jsonrpc: '2.0',\n      method: 'eth_accounts',\n      params: [],\n      id: 42\n    }; // use MetaMask request method if there\n\n    if (provider.request) {\n      return provider.request(options).then(function (res) {\n        return resolve(res[0]);\n      });\n    }\n\n    var callback = function callback(e, res) {\n      e && reject(e);\n      var result = res && res.result && res.result[0];\n      resolve(result);\n    };\n\n    if (typeof provider.sendAsync === 'function') {\n      provider.sendAsync(options, callback);\n    } else if (typeof provider.send === 'function') {\n      provider.send(options, callback);\n    } else {\n      resolve(null);\n    }\n  });\n}\n\nfunction getBalance(provider, address) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resolve, reject) {\n      var currentAddress, options, callback;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = address;\n\n              if (_context.t0) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return getAddress(provider);\n\n            case 4:\n              _context.t0 = _context.sent;\n\n            case 5:\n              currentAddress = _context.t0;\n\n              if (currentAddress) {\n                _context.next = 9;\n                break;\n              }\n\n              resolve(null);\n              return _context.abrupt(\"return\");\n\n            case 9:\n              options = {\n                jsonrpc: '2.0',\n                method: 'eth_getBalance',\n                params: [currentAddress, 'latest'],\n                id: 42\n              }; // use MetaMask request method if there\n\n              if (!provider.request) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\", provider.request(options).then(function (res) {\n                return res ? new bignumber_js__WEBPACK_IMPORTED_MODULE_1___default.a(res).toString(10) : null;\n              }).then(resolve));\n\n            case 12:\n              callback = function callback(e, res) {\n                e && reject(e);\n                var result = res && res.result;\n                resolve(result && new bignumber_js__WEBPACK_IMPORTED_MODULE_1___default.a(result).toString(10));\n              };\n\n              if (typeof provider.sendAsync === 'function') {\n                provider.sendAsync(options, callback);\n              } else if (typeof provider.send === 'function') {\n                provider.send(options, callback);\n              } else {\n                resolve(null);\n              }\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }());\n}\n\nfunction createModernProviderInterface(provider) {\n  provider.autoRefreshOnNetworkChange = false;\n  var onFuncExists = typeof provider.on === 'function';\n  return {\n    address: onFuncExists ? {\n      onChange: function onChange(func) {\n        // get the initial value\n        getAddress(provider).then(func);\n        provider.on('accountsChanged', function (accounts) {\n          return func(accounts && accounts[0]);\n        });\n      }\n    } : {\n      get: function get() {\n        return getAddress(provider);\n      }\n    },\n    network: onFuncExists ? {\n      onChange: function onChange(func) {\n        // get initial value\n        getNetwork(provider).then(func); // networkChanged event is deprecated in MM, keep for wallets that may not have updated\n\n        provider.on('networkChanged', function (netId) {\n          return func(netId && Number(netId));\n        }); // use new chainChanged event for network change\n\n        provider.on('chainChanged', function (netId) {\n          return func(netId && Number(netId));\n        });\n      }\n    } : {\n      get: function get() {\n        return getNetwork(provider);\n      }\n    },\n    balance: {\n      get: function get() {\n        return getBalance(provider);\n      }\n    },\n    connect: function connect() {\n      return new Promise(function (resolve, reject) {\n        var request = provider.request ? getAddress(provider).then(function (address) {\n          return address ? address : provider.request({\n            method: 'eth_requestAccounts'\n          });\n        }) : provider.enable();\n        return request.then(resolve)[\"catch\"](function () {\n          return reject({\n            message: 'This dapp needs access to your account information.'\n          });\n        });\n      });\n    },\n    name: getProviderName(provider)\n  };\n}\n\nfunction createLegacyProviderInterface(provider) {\n  return {\n    address: {\n      get: function get() {\n        return getAddress(provider);\n      }\n    },\n    network: {\n      get: function get() {\n        return getNetwork(provider);\n      }\n    },\n    balance: {\n      get: function get() {\n        return getBalance(provider);\n      }\n    },\n    name: getProviderName(provider)\n  };\n}\n\nfunction getProviderName(provider) {\n  if (!provider) return;\n\n  if (provider.isWalletIO) {\n    return 'wallet.io';\n  }\n\n  if (provider.isDcentWallet) {\n    return 'D\\'CENT';\n  }\n\n  if (provider.isTokenPocket) {\n    return 'TokenPocket';\n  }\n\n  if (provider.wallet === 'MEETONE') {\n    return 'MEETONE';\n  }\n\n  if (provider.isTorus) {\n    return 'Torus';\n  }\n\n  if (provider.isImToken) {\n    return 'imToken';\n  }\n\n  if (provider.isDapper) {\n    return 'Dapper';\n  }\n\n  if (provider.isWalletConnect) {\n    return 'WalletConnect';\n  }\n\n  if (provider.isTrust) {\n    return 'Trust';\n  }\n\n  if (provider.isCoinbaseWallet) {\n    return 'Coinbase';\n  }\n\n  if (provider.isToshi) {\n    return 'Toshi';\n  }\n\n  if (provider.isCipher) {\n    return 'Cipher';\n  }\n\n  if (provider.isOpera) {\n    return 'Opera';\n  }\n\n  if (provider.isStatus) {\n    return 'Status';\n  }\n\n  if (provider.isMetaMask) {\n    return 'MetaMask';\n  }\n\n  if (provider.isMYKEY) {\n    return 'MYKEY';\n  }\n\n  if (provider.isHbWallet) {\n    return 'huobiwallet';\n  }\n\n  if (provider.isHyperPay) {\n    return 'HyperPay';\n  }\n\n  if (provider.host && provider.host.indexOf('localhost') !== -1) {\n    return 'localhost';\n  }\n\n  return 'web3Wallet';\n}\n\nfunction getDeviceInfo() {\n  var parsed = bowser__WEBPACK_IMPORTED_MODULE_3___default.a.getParser(window.navigator.userAgent);\n  var os = parsed.getOS();\n  var browser = parsed.getBrowser();\n\n  var _parsed$getPlatform = parsed.getPlatform(),\n      type = _parsed$getPlatform.type;\n\n  return {\n    isMobile: type ? type !== 'desktop' : window.innerWidth < 600,\n    os: os,\n    browser: browser\n  };\n}\n\nfunction networkName(id) {\n  switch (id) {\n    case 1:\n      return 'mainnet';\n\n    case 3:\n      return 'ropsten';\n\n    case 4:\n      return 'rinkeby';\n\n    case 5:\n      return 'goerli';\n\n    case 42:\n      return 'kovan';\n\n    case 100:\n      return 'xdai';\n\n    default:\n      return 'local';\n  }\n}\n\nfunction networkToId(network) {\n  switch (network) {\n    case 'mainnet':\n      return 1;\n\n    case 'ropsten':\n      return 3;\n\n    case 'rinkeby':\n      return 4;\n\n    case 'goerli':\n      return 5;\n\n    case 'kovan':\n      return 42;\n\n    case 'xdai':\n      return 100;\n\n    default:\n      return 0;\n  }\n}\n\nfunction wait$1(time) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, time);\n  });\n}\n\nfunction makeCancelable(promise) {\n  var rejectFn;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    rejectFn = reject;\n    promise.then(resolve)[\"catch\"](reject);\n  });\n\n  wrappedPromise.cancel = function () {\n    rejectFn('canceled');\n  };\n\n  return wrappedPromise;\n}\n\nfunction isPromise(val) {\n  if (val instanceof Promise) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createInterval(func, interval) {\n  var id = setInterval(func, interval);\n  var status = {\n    active: true\n  };\n  return {\n    status: status,\n    clear: function clear() {\n      clearInterval(id);\n      status.active = false;\n    }\n  };\n}\n\nfunction openLink(url) {\n  window.open(url);\n}\n\nvar validSubscriptionKeys = ['address', 'network', 'balance', 'wallet'];\n\nfunction validateType(options) {\n  var name = options.name,\n      value = options.value,\n      type = options.type,\n      optional = options.optional;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(\"\\\"\".concat(name, \"\\\" is required\"));\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : _typeof(value) !== type)) {\n    throw new Error(\"\\\"\".concat(name, \"\\\" must be of type: \").concat(type, \", received type: \").concat(_typeof(value), \" from value: \").concat(value));\n  }\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  var keys = Object.keys(params);\n  keys.forEach(function (key) {\n    if (!validParams.includes(key)) {\n      throw new Error(\"\".concat(key, \" is not a valid parameter for \").concat(functionName, \", must be one of the following valid parameters: \").concat(validParams.join(', ')));\n    }\n  });\n}\n\nfunction validateInit(init) {\n  validateType({\n    name: 'init',\n    value: init,\n    type: 'object'\n  });\n\n  var dappId = init.dappId,\n      networkId = init.networkId,\n      subscriptions = init.subscriptions,\n      walletSelect = init.walletSelect,\n      walletCheck = init.walletCheck,\n      darkMode = init.darkMode,\n      apiUrl = init.apiUrl,\n      hideBranding = init.hideBranding,\n      otherParams = _objectWithoutProperties(init, [\"dappId\", \"networkId\", \"subscriptions\", \"walletSelect\", \"walletCheck\", \"darkMode\", \"apiUrl\", \"hideBranding\"]);\n\n  invalidParams(otherParams, ['dappId', 'networkId', 'subscriptions', 'walletSelect', 'walletCheck', 'darkMode', 'apiUrl', 'hideBranding'], 'init');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'darkMode',\n    value: darkMode,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'hideBranding',\n    value: hideBranding,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions',\n    value: subscriptions,\n    type: 'object',\n    optional: true\n  });\n\n  if (subscriptions) {\n    validateSubscriptions(subscriptions);\n  }\n\n  validateType({\n    name: 'walletSelect',\n    value: walletSelect,\n    type: 'object',\n    optional: true\n  });\n\n  if (walletSelect) {\n    validateWalletSelect(walletSelect);\n  }\n\n  validateType({\n    name: 'walletCheck',\n    value: walletCheck,\n    type: 'object',\n    optional: true\n  });\n\n  if (walletCheck) {\n    validateWalletCheck(walletCheck);\n  }\n}\n\nfunction validateSubscriptions(subscriptions) {\n  var address = subscriptions.address,\n      network = subscriptions.network,\n      balance = subscriptions.balance,\n      wallet = subscriptions.wallet,\n      otherParams = _objectWithoutProperties(subscriptions, [\"address\", \"network\", \"balance\", \"wallet\"]);\n\n  invalidParams(otherParams, validSubscriptionKeys, 'subscriptions');\n  validateType({\n    name: 'subscriptions.address',\n    value: address,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.network',\n    value: network,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.balance',\n    value: balance,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.wallet',\n    value: wallet,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validateWalletSelect(walletSelect) {\n  validateType({\n    name: 'walletSelect',\n    value: walletSelect,\n    type: 'object'\n  });\n\n  var heading = walletSelect.heading,\n      description = walletSelect.description,\n      explanation = walletSelect.explanation,\n      wallets = walletSelect.wallets,\n      otherParams = _objectWithoutProperties(walletSelect, [\"heading\", \"description\", \"explanation\", \"wallets\"]);\n\n  invalidParams(otherParams, ['heading', 'description', 'explanation', 'wallets'], 'walletSelect');\n  validateType({\n    name: 'heading',\n    value: heading,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'description',\n    value: description,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'explanation',\n    value: explanation,\n    type: 'string',\n    optional: true\n  });\n\n  if (Array.isArray(wallets)) {\n    wallets.forEach(validateWallet);\n  }\n}\n\nfunction isWalletModule(obj) {\n  return obj.wallet !== undefined;\n}\n\nfunction isWalletInit(obj) {\n  return obj.walletName !== undefined;\n}\n\nfunction validateWallet(obj) {\n  validateType({\n    name: 'selectWallet.wallets item',\n    value: obj,\n    type: 'object'\n  });\n\n  if (isWalletModule(obj)) {\n    var name = obj.name,\n        iconSrc = obj.iconSrc,\n        iconSrcSet = obj.iconSrcSet,\n        svg = obj.svg,\n        _wallet = obj.wallet,\n        link = obj.link,\n        installMessage = obj.installMessage,\n        preferred = obj.preferred,\n        desktop = obj.desktop,\n        mobile = obj.mobile,\n        type = obj.type,\n        osExclusions = obj.osExclusions,\n        otherParams = _objectWithoutProperties(obj, [\"name\", \"iconSrc\", \"iconSrcSet\", \"svg\", \"wallet\", \"link\", \"installMessage\", \"preferred\", \"desktop\", \"mobile\", \"type\", \"osExclusions\"]);\n\n    invalidParams(otherParams, ['name', 'iconSrc', 'iconSrcSet', 'svg', 'wallet', 'type', 'link', 'installMessage', 'preferred', 'desktop', 'mobile', 'osExclusions'], 'selectWallets.wallets item');\n    validateType({\n      name: 'name',\n      value: name,\n      type: 'string'\n    });\n    validateType({\n      name: 'wallet',\n      value: _wallet,\n      type: 'function'\n    });\n    validateType({\n      name: 'iconSrc',\n      value: iconSrc,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'iconSrcSet',\n      value: iconSrcSet,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'svg',\n      value: svg,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'link',\n      value: link,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'installMessage',\n      value: installMessage,\n      type: 'function',\n      optional: true\n    });\n    validateType({\n      name: 'preferred',\n      value: preferred,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'desktop',\n      value: desktop,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'mobile',\n      value: mobile,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'type',\n      value: type,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'osExclusions',\n      value: osExclusions,\n      type: 'array',\n      optional: true\n    });\n    return;\n  }\n\n  validateWalletInit(obj);\n}\n\nfunction isWalletCheckModule(obj) {\n  return typeof obj === 'function';\n}\n\nfunction validateWalletCheck(walletCheck) {\n  validateType({\n    name: 'walletCheck',\n    value: walletCheck,\n    type: 'array'\n  });\n  walletCheck.forEach(function (check) {\n    if (isWalletCheckModule(check)) {\n      validateWalletCheckModule(check);\n    } else {\n      validateType({\n        name: 'walletCheck item',\n        value: check,\n        type: 'object'\n      });\n\n      var checkName = check.checkName,\n          heading = check.heading,\n          description = check.description,\n          minimumBalance = check.minimumBalance,\n          html = check.html,\n          icon = check.icon,\n          button = check.button,\n          otherParams = _objectWithoutProperties(check, [\"checkName\", \"heading\", \"description\", \"minimumBalance\", \"html\", \"icon\", \"button\"]);\n\n      invalidParams(otherParams, ['checkName', 'heading', 'description', 'html', 'icon', 'button', 'minimumBalance'], 'walletCheck item');\n      validateType({\n        name: 'checkName',\n        value: checkName,\n        type: 'string'\n      });\n      validateType({\n        name: 'heading',\n        value: heading,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'description',\n        value: description,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'html',\n        value: html,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'icon',\n        value: icon,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'button',\n        value: button,\n        type: 'object',\n        optional: true\n      });\n      validateType({\n        name: 'minimumBalance',\n        value: minimumBalance,\n        type: 'string',\n        optional: true\n      });\n    }\n  });\n}\n\nfunction validateWalletCheckModule(module) {\n  validateType({\n    name: 'walletCheck module',\n    value: module,\n    type: 'function'\n  });\n}\n\nfunction validateConfig(configuration) {\n  validateType({\n    name: 'configuration',\n    value: configuration,\n    type: 'object'\n  });\n\n  var darkMode = configuration.darkMode,\n      networkId = configuration.networkId,\n      otherParams = _objectWithoutProperties(configuration, [\"darkMode\", \"networkId\"]);\n\n  invalidParams(otherParams, ['darkMode', 'networkId'], 'configuration');\n  validateType({\n    name: 'darkMode',\n    value: darkMode,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number',\n    optional: true\n  });\n}\n\nfunction validateModal(modal) {\n  validateType({\n    name: 'modal',\n    value: modal,\n    type: 'object'\n  });\n\n  var heading = modal.heading,\n      description = modal.description,\n      button = modal.button,\n      eventCode = modal.eventCode,\n      action = modal.action,\n      icon = modal.icon,\n      html = modal.html,\n      otherParams = _objectWithoutProperties(modal, [\"heading\", \"description\", \"button\", \"eventCode\", \"action\", \"icon\", \"html\"]);\n\n  invalidParams(otherParams, ['heading', 'description', 'button', 'eventCode', 'action', 'icon', 'html'], 'modal');\n  validateType({\n    name: 'heading',\n    value: heading,\n    type: 'string'\n  });\n  validateType({\n    name: 'description',\n    value: description,\n    type: 'string'\n  });\n  validateType({\n    name: 'eventCode',\n    value: eventCode,\n    type: 'string'\n  });\n  validateType({\n    name: 'action',\n    value: action,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'button',\n    value: button,\n    type: 'object',\n    optional: true\n  });\n  validateType({\n    name: 'html',\n    value: html,\n    type: 'string',\n    optional: true\n  });\n\n  if (button) {\n    var onclick = button.onclick,\n        _text = button.text,\n        restParams = _objectWithoutProperties(button, [\"onclick\", \"text\"]);\n\n    invalidParams(restParams, ['onclick', 'text'], 'button');\n    validateType({\n      name: 'onclick',\n      value: onclick,\n      type: 'function'\n    });\n    validateType({\n      name: 'text',\n      value: _text,\n      type: 'string'\n    });\n  }\n\n  validateType({\n    name: 'icon',\n    value: icon,\n    type: 'string',\n    optional: true\n  });\n}\n\nfunction validateWalletInterface(walletInterface) {\n  validateType({\n    name: 'walletInterface',\n    value: walletInterface,\n    type: 'object'\n  });\n\n  var name = walletInterface.name,\n      connect = walletInterface.connect,\n      disconnect = walletInterface.disconnect,\n      address = walletInterface.address,\n      network = walletInterface.network,\n      balance = walletInterface.balance,\n      otherParams = _objectWithoutProperties(walletInterface, [\"name\", \"connect\", \"disconnect\", \"address\", \"network\", \"balance\"]);\n\n  invalidParams(otherParams, ['name', 'connect', 'disconnect', 'address', 'network', 'balance'], 'walletInterface');\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string'\n  });\n  validateType({\n    name: 'connect',\n    value: connect,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'disconnect',\n    value: disconnect,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'address',\n    value: address,\n    type: 'object'\n  });\n  validateType({\n    name: 'address.get',\n    value: address.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'address.onChange',\n    value: address.onChange,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'network',\n    value: network,\n    type: 'object'\n  });\n  validateType({\n    name: 'network.get',\n    value: network.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'network.onChange',\n    value: network.onChange,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'balance',\n    value: balance,\n    type: 'object'\n  });\n  validateType({\n    name: 'balance.get',\n    value: balance.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'balance.onChange',\n    value: balance.onChange,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validateWalletInit(walletInit) {\n  validateType({\n    name: 'walletInit',\n    value: walletInit,\n    type: 'object'\n  });\n\n  var walletName = walletInit.walletName,\n      preferred = walletInit.preferred,\n      label = walletInit.label,\n      iconSrc = walletInit.iconSrc,\n      svg = walletInit.svg,\n      otherParams = _objectWithoutProperties(walletInit, [\"walletName\", \"preferred\", \"label\", \"iconSrc\", \"svg\"]);\n\n  invalidParams(otherParams, ['walletName', 'apiKey', 'networkId', 'infuraKey', 'rpc', 'bridge', 'preferred', 'label', 'iconSrc', 'svg', 'appUrl', 'email', 'rpcUrl', 'LedgerTransport', 'buildEnv', 'buttonPosition', 'enableLogging', 'loginMethod', 'loginConfig', 'showTorusButton', 'modalZindex', 'integrity', 'whiteLabel', 'appName', 'appLogoUrl', 'enabledVerifiers', 'disableNotifications', 'rpcUri', 'webUri', 'xsUri', 'blockedPopupRedirect'], 'walletInitObject');\n  validateType({\n    name: 'walletInit.walletName',\n    value: walletName,\n    type: 'string'\n  });\n  validateType({\n    name: 'walletInit.preferred',\n    value: preferred,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.label',\n    value: label,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.iconSrc',\n    value: iconSrc,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.svg',\n    value: svg,\n    type: 'string',\n    optional: true\n  });\n}\n\nvar app = writable({\n  dappId: '',\n  networkId: 1,\n  version: '',\n  mobileDevice: false,\n  os: '',\n  darkMode: false,\n  walletSelectInProgress: false,\n  walletSelectCompleted: false,\n  walletCheckInProgress: false,\n  walletCheckCompleted: false,\n  accountSelectInProgress: false,\n  autoSelectWallet: '',\n  checkModules: [],\n  walletSelectDisplayedUI: false,\n  walletCheckDisplayedUI: false,\n  displayBranding: false\n});\nvar stateSyncStatus = {\n  balance: null,\n  address: null,\n  network: null\n};\nvar address;\nvar network;\nvar balance;\nvar wallet;\nvar state;\nvar walletInterface;\nvar currentSyncerIntervals;\n\nfunction initializeStores() {\n  address = createWalletStateSliceStore({\n    parameter: 'address',\n    initialState: null\n  });\n  network = createWalletStateSliceStore({\n    parameter: 'network',\n    initialState: null\n  });\n  balance = get_store_value(app).dappId ? createBalanceStore(null) : createWalletStateSliceStore({\n    parameter: 'balance',\n    initialState: null,\n    intervalSetting: 1000\n  });\n  wallet = writable({\n    name: null,\n    provider: null,\n    connect: null,\n    instance: null,\n    dashboard: null,\n    type: null\n  });\n  state = derived([address, network, balance, wallet, app], function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 5),\n        $address = _ref6[0],\n        $network = _ref6[1],\n        $balance = _ref6[2],\n        $wallet = _ref6[3],\n        $app = _ref6[4];\n\n    return {\n      address: $address,\n      network: $network,\n      balance: $balance,\n      wallet: $wallet,\n      mobileDevice: $app.mobileDevice,\n      appNetworkId: $app.networkId\n    };\n  });\n  currentSyncerIntervals = [];\n  walletInterface = createWalletInterfaceStore(null);\n  walletInterface.subscribe(function (walletInterface) {\n    // make sure that stores have been initialized\n    if (state) {\n      // clear all current intervals if they exist\n      currentSyncerIntervals.forEach(function (interval) {\n        return interval && interval.clear();\n      });\n      var currentState = get_store_value(state); // reset state\n\n      currentState.balance && balance.reset();\n      currentState.address && address.reset();\n      currentState.network && network.reset();\n\n      if (walletInterface) {\n        // start syncing state and save intervals\n        currentSyncerIntervals = [address.setStateSyncer(walletInterface.address), network.setStateSyncer(walletInterface.network), balance.setStateSyncer(walletInterface.balance)];\n      }\n\n      resetCheckModules();\n    }\n  });\n}\n\nfunction resetWalletState(options) {\n  walletInterface.update(function (currentInterface) {\n    // no interface then don't do anything\n    if (!currentInterface) {\n      return currentInterface;\n    } // no options object, so do a full reset by disconnecting and setting interface to null\n\n\n    if (!options) {\n      wallet.update(function () {\n        return {\n          name: undefined,\n          provider: undefined,\n          connect: undefined,\n          instance: undefined,\n          dashboard: undefined,\n          type: undefined\n        };\n      });\n      currentInterface.disconnect && currentInterface.disconnect();\n      return null;\n    }\n\n    var walletName = options.walletName,\n        disconnected = options.disconnected; // if walletName is the same as the current interface name then do a full reset (checking if to do a disconnect)\n\n    if (currentInterface.name === walletName) {\n      wallet.update(function () {\n        return {\n          name: undefined,\n          provider: undefined,\n          connect: undefined,\n          instance: undefined,\n          dashboard: undefined\n        };\n      });\n      !disconnected && currentInterface.disconnect && currentInterface.disconnect();\n      return null;\n    }\n\n    return currentInterface;\n  });\n  resetCheckModules();\n  app.update(function (store) {\n    return _objectSpread(_objectSpread({}, store), {}, {\n      walletSelectInProgress: false,\n      walletSelectCompleted: false\n    });\n  });\n}\n\nfunction resetCheckModules() {\n  var _get_store_value = get_store_value(app),\n      checkModules = _get_store_value.checkModules;\n\n  if (Array.isArray(checkModules)) {\n    checkModules.forEach(function (m) {\n      return m.reset && m.reset();\n    });\n  }\n}\n\nfunction createWalletInterfaceStore(initialState) {\n  var _writable = writable(initialState),\n      subscribe = _writable.subscribe,\n      _set = _writable.set,\n      update = _writable.update;\n\n  return {\n    subscribe: subscribe,\n    update: update,\n    set: function set(walletInterface) {\n      if (walletInterface) {\n        validateWalletInterface(walletInterface);\n      }\n\n      _set(walletInterface);\n    }\n  };\n}\n\nfunction createWalletStateSliceStore(options) {\n  var parameter = options.parameter,\n      initialState = options.initialState,\n      intervalSetting = options.intervalSetting;\n\n  var _writable2 = writable(initialState),\n      subscribe = _writable2.subscribe,\n      set = _writable2.set;\n\n  var currentState;\n  subscribe(function (store) {\n    currentState = store;\n  });\n  return {\n    subscribe: subscribe,\n    reset: function reset() {\n      set(undefined);\n    },\n    get: function get() {\n      return currentState;\n    },\n    setStateSyncer: function setStateSyncer(stateSyncer) {\n      validateType({\n        name: 'stateSyncer',\n        value: stateSyncer,\n        type: 'object'\n      });\n      var get = stateSyncer.get,\n          onChange = stateSyncer.onChange;\n      validateType({\n        name: \"\".concat(parameter, \".get\"),\n        value: get,\n        type: 'function',\n        optional: true\n      });\n      validateType({\n        name: \"\".concat(parameter, \".onChange\"),\n        value: onChange,\n        type: 'function',\n        optional: true\n      });\n\n      if (onChange) {\n        stateSyncStatus[parameter] = new Promise(function (resolve) {\n          onChange(function (newVal) {\n            resolve();\n\n            if (newVal || currentState !== initialState) {\n              set(newVal);\n            }\n          });\n        });\n        return;\n      }\n\n      if (get) {\n        var interval = createInterval(function () {\n          stateSyncStatus[parameter] = get().then(function (newVal) {\n            stateSyncStatus[parameter] = null;\n\n            if (newVal || currentState !== initialState) {\n              interval.status.active && set(newVal);\n            }\n          })[\"catch\"](function (err) {\n            console.warn(\"Error getting \".concat(parameter, \" from state syncer: \").concat(err));\n            stateSyncStatus[parameter] = null;\n          });\n        }, intervalSetting || 200);\n        return interval;\n      }\n    }\n  };\n}\n\nfunction createBalanceStore(initialState) {\n  var stateSyncer;\n  var emitter;\n  var emitterAddress;\n\n  var cancel = function cancel() {};\n\n  var _derived = derived([address, network], function (_ref7, set) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        $address = _ref8[0],\n        $network = _ref8[1];\n\n    if (stateSyncer && !stateSyncer.onChange) {\n      if ($address && $network && stateSyncer.get && set) {\n        cancel = syncStateWithTimeout({\n          getState: stateSyncer.get,\n          setState: set,\n          timeout: 2000,\n          currentBalance: get_store_value(balance)\n        });\n\n        if (emitterAddress !== $address) {\n          var _blocknative = getBlocknative(); // unsubscribe from previous address\n\n\n          if (emitterAddress) {\n            _blocknative.unsubscribe(emitterAddress);\n          }\n\n          emitter = _blocknative.account($address).emitter;\n          emitter.on('txConfirmed', function () {\n            if (stateSyncer.get) {\n              cancel = syncStateWithTimeout({\n                getState: stateSyncer.get,\n                setState: set,\n                timeout: 2000,\n                currentBalance: get_store_value(balance),\n                pollStart: Date.now()\n              });\n            }\n\n            return false;\n          });\n          emitterAddress = $address;\n        }\n      } else if (emitterAddress && !$address) {\n        var _blocknative2 = getBlocknative(); // unsubscribe from previous address\n\n\n        _blocknative2.unsubscribe(emitterAddress); // no address, so set balance to undefined\n\n\n        set && set(undefined);\n        emitterAddress = undefined;\n      }\n    }\n\n    set(initialState);\n  }),\n      subscribe = _derived.subscribe;\n\n  var currentState;\n  subscribe(function (store) {\n    currentState = store;\n  });\n  return {\n    subscribe: subscribe,\n    get: function get() {\n      return currentState;\n    },\n    setStateSyncer: function setStateSyncer(syncer) {\n      validateType({\n        name: 'syncer',\n        value: syncer,\n        type: 'object'\n      });\n      var get = syncer.get,\n          onChange = syncer.onChange;\n      validateType({\n        name: 'balance.get',\n        value: get,\n        type: 'function',\n        optional: true\n      });\n      validateType({\n        name: 'balance.onChange',\n        value: onChange,\n        type: 'function',\n        optional: true\n      });\n      stateSyncer = syncer;\n      return undefined;\n    },\n    reset: cancel\n  };\n}\n\nfunction syncStateWithTimeout(options) {\n  var getState = options.getState,\n      setState = options.setState,\n      timeout = options.timeout,\n      currentBalance = options.currentBalance,\n      pollStart = options.pollStart;\n\n  if (pollStart && Date.now() - pollStart > 25000) {\n    return function () {};\n  }\n\n  var prom = makeCancelable(getState());\n  stateSyncStatus.balance = prom;\n  prom.then( /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(result) {\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(result === currentBalance && pollStart)) {\n                _context2.next = 6;\n                break;\n              }\n\n              _context2.next = 3;\n              return wait$1(350);\n\n            case 3:\n              syncStateWithTimeout(options);\n              _context2.next = 8;\n              break;\n\n            case 6:\n              stateSyncStatus.balance = null;\n              setState(result);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3) {\n      return _ref9.apply(this, arguments);\n    };\n  }())[\"catch\"](function () {\n    stateSyncStatus.balance = null;\n  });\n  var timedOut = wait$1(timeout);\n  timedOut.then(function () {\n    prom.cancel();\n  });\n  return function () {\n    return prom.cancel();\n  };\n}\n/* src/elements/Branding.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css() {\n  var style = element(\"style\");\n  style.id = \"svelte-15m9up6-style\";\n  style.textContent = \".bn-branding.svelte-15m9up6{font-size:0.75rem;font-family:inherit;margin:0.4rem;display:flex;justify-content:center;width:100%;align-items:center}span.svelte-15m9up6{opacity:0.3}a.svelte-15m9up6{color:inherit;display:flex;margin-left:0.25rem;align-items:center}.bn-logo.svelte-15m9up6{height:1.1rem;margin-left:0.25rem;margin-bottom:0.1rem}svg.svelte-15m9up6{height:100%;width:auto}\";\n  append(document.head, style);\n} // (76:6) {:else}\n\n\nfunction create_else_block(ctx) {\n  var svg;\n  var g;\n  var path0;\n  var path1;\n  return {\n    c: function c() {\n      svg = svg_element(\"svg\");\n      g = svg_element(\"g\");\n      path0 = svg_element(\"path\");\n      path1 = svg_element(\"path\");\n      attr(path0, \"d\", \"m1.35473654 25.2695268\\n              41.68515786-24.21771792c.5647044-.32807482 1.2619836-.32807795\\n              1.8266909-.00000821l19.9275013\\n              11.57698923c.5635938.3274228.9088026.9314826.9048094\\n              1.5832707l-.1501112 24.5017756 20.8472716\\n              12.1113348c.5601525.3254236.9048434.9243111.9048434\\n              1.5721317v48.4560123c0 .647825-.3446953 1.246715-.9048537\\n              1.572138l-41.6835092\\n              24.215895c-.5655731.328567-1.2640448.328023-1.8291052-.001426l-41.5311197-24.21401c-.5587764-.325785-.90240476-.923899-.90240476-1.570712v-49.505258-24.5082917c0-.6478147.34468473-1.2466978.9048293-1.5721235z\");\n      attr(path1, \"d\", \"m22.0428451 114.442824v-25.2731141l-21.59284788-12.5449388\\n              42.75014288 24.6551909c.5648507.325765 1.260898.324109\\n              1.8241926-.004339l42.2766571-24.6508519-21.5955473\\n              12.6370084v-24.2248276c0-.6488012-.3457266-1.2484405-.9072187-1.5735092l-20.9222804-12.1126883\\n              21.6729314-12.6370084-42.4525958\\n              24.4763352c-.5545159.3197099-1.236865.3218902-1.7934127.0057303l-20.85286908-11.8459598\");\n      set_style(g, \"stroke\", \"#000\");\n      set_style(g, \"stroke-width\", \"2.70793\");\n      set_style(g, \"fill\", \"none\");\n      set_style(g, \"fill-rule\", \"evenodd\");\n      set_style(g, \"stroke-linecap\", \"round\");\n      set_style(g, \"stroke-linejoin\", \"round\");\n      attr(g, \"transform\", \"translate(1.818182 .909091)\");\n      attr(svg, \"height\", \"130\");\n      attr(svg, \"viewBox\", \"0 0 91 130\");\n      attr(svg, \"width\", \"91\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"class\", \"svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, svg, anchor);\n      append(svg, g);\n      append(g, path0);\n      append(g, path1);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(svg);\n    }\n  };\n} // (48:6) {#if darkMode}\n\n\nfunction create_if_block(ctx) {\n  var svg;\n  var g;\n  var path0;\n  var path1;\n  return {\n    c: function c() {\n      svg = svg_element(\"svg\");\n      g = svg_element(\"g\");\n      path0 = svg_element(\"path\");\n      path1 = svg_element(\"path\");\n      attr(path0, \"d\", \"m1.35473654 25.2695268\\n              41.68515786-24.21771792c.5647044-.32807482 1.2619836-.32807795\\n              1.8266909-.00000821l19.9275013\\n              11.57698923c.5635938.3274228.9088026.9314826.9048094\\n              1.5832707l-.1501112 24.5017756 20.8472716\\n              12.1113348c.5601525.3254236.9048434.9243111.9048434\\n              1.5721317v48.4560123c0 .647825-.3446953 1.246715-.9048537\\n              1.572138l-41.6835092\\n              24.215895c-.5655731.328567-1.2640448.328023-1.8291052-.001426l-41.5311197-24.21401c-.5587764-.325785-.90240476-.923899-.90240476-1.570712v-49.505258-24.5082917c0-.6478147.34468473-1.2466978.9048293-1.5721235z\");\n      attr(path1, \"d\", \"m22.0428451 114.442824v-25.2731141l-21.59284788-12.5449388\\n              42.75014288 24.6551909c.5648507.325765 1.260898.324109\\n              1.8241926-.004339l42.2766571-24.6508519-21.5955473\\n              12.6370084v-24.2248276c0-.6488012-.3457266-1.2484405-.9072187-1.5735092l-20.9222804-12.1126883\\n              21.6729314-12.6370084-42.4525958\\n              24.4763352c-.5545159.3197099-1.236865.3218902-1.7934127.0057303l-20.85286908-11.8459598\");\n      set_style(g, \"stroke\", \"#fff\");\n      set_style(g, \"stroke-width\", \"2.70793\");\n      set_style(g, \"fill\", \"none\");\n      set_style(g, \"fill-rule\", \"evenodd\");\n      set_style(g, \"stroke-linecap\", \"round\");\n      set_style(g, \"stroke-linejoin\", \"round\");\n      attr(g, \"transform\", \"translate(1.818182 .909091)\");\n      attr(svg, \"height\", \"130\");\n      attr(svg, \"viewBox\", \"0 0 91 130\");\n      attr(svg, \"width\", \"91\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"class\", \"svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, svg, anchor);\n      append(svg, g);\n      append(g, path0);\n      append(g, path1);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(svg);\n    }\n  };\n}\n\nfunction create_fragment(ctx) {\n  var div1;\n  var span0;\n  var t1;\n  var a;\n  var span1;\n  var t3;\n  var div0;\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*darkMode*/\n    ctx[0]) return create_if_block;\n    return create_else_block;\n  }\n\n  var current_block_type = select_block_type(ctx);\n  var if_block = current_block_type(ctx);\n  return {\n    c: function c() {\n      div1 = element(\"div\");\n      span0 = element(\"span\");\n      span0.textContent = \"Powered by\";\n      t1 = space();\n      a = element(\"a\");\n      span1 = element(\"span\");\n      span1.textContent = \"Blocknative\";\n      t3 = space();\n      div0 = element(\"div\");\n      if_block.c();\n      attr(span0, \"class\", \"svelte-15m9up6\");\n      attr(span1, \"class\", \"svelte-15m9up6\");\n      attr(div0, \"class\", \"bn-logo svelte-15m9up6\");\n      attr(a, \"href\", \"https://hubs.ly/H0qh2g10\");\n      attr(a, \"class\", \"bn-onboard-clickable svelte-15m9up6\");\n      attr(a, \"target\", \"_blank\");\n      attr(a, \"rel\", \"noopener noreferrer\");\n      attr(div1, \"class\", \"bn-branding svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, span0);\n      append(div1, t1);\n      append(div1, a);\n      append(a, span1);\n      append(a, t3);\n      append(a, div0);\n      if_block.m(div0, null);\n    },\n    p: function p(ctx, _ref10) {\n      var _ref11 = _slicedToArray(_ref10, 1),\n          dirty = _ref11[0];\n\n      if (current_block_type !== (current_block_type = select_block_type(ctx))) {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n\n        if (if_block) {\n          if_block.c();\n          if_block.m(div0, null);\n        }\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div1);\n      if_block.d();\n    }\n  };\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  var darkMode = $$props.darkMode;\n\n  $$self.$set = function ($$props) {\n    if (\"darkMode\" in $$props) $$invalidate(0, darkMode = $$props.darkMode);\n  };\n\n  return [darkMode];\n}\n\nvar Branding = /*#__PURE__*/function (_SvelteComponent) {\n  _inherits(Branding, _SvelteComponent);\n\n  var _super = _createSuper(Branding);\n\n  function Branding(options) {\n    var _this;\n\n    _classCallCheck(this, Branding);\n\n    _this = _super.call(this);\n    if (!document.getElementById(\"svelte-15m9up6-style\")) add_css();\n    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {\n      darkMode: 0\n    });\n    return _this;\n  }\n\n  return Branding;\n}(SvelteComponent);\n/* src/components/Modal.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$1() {\n  var style = element(\"style\");\n  style.id = \"svelte-rntogh-style\";\n  style.textContent = \"aside.svelte-rntogh{display:flex;font-family:'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;justify-content:center;align-items:center;position:fixed;font-size:16px;top:0;left:0;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.3)}@media screen and (max-width: 420px){aside.svelte-rntogh{font-size:14px}}section.svelte-rntogh{display:block;box-sizing:content-box;background:#ffffff;border-radius:10px;box-shadow:0 1px 5px 0 rgba(0, 0, 0, 0.1);font-family:inherit;font-size:inherit;padding:1.33em;position:relative;overflow:hidden;max-width:37em;color:#4a4a4a}div.svelte-rntogh{height:0.66em;position:absolute;padding:0.25em;top:1.33em;right:1.33em;font-size:inherit;font-family:inherit;border-radius:5px;transition:background 200ms ease-in-out;display:flex;justify-content:center;align-items:center}div.svelte-rntogh:hover{cursor:pointer;background:#eeeeee}svg.svelte-rntogh{width:10px;height:10px}.bn-onboard-dark-mode-close-background.svelte-rntogh:hover{background:#00222c}.no-padding-branding.svelte-rntogh{padding-bottom:0}\";\n  append(document.head, style);\n} // (95:4) {#if $app.displayBranding}\n\n\nfunction create_if_block_1(ctx) {\n  var branding;\n  var current;\n  branding = new Branding({\n    props: {\n      darkMode:\n      /*$app*/\n      ctx[3].darkMode\n    }\n  });\n  return {\n    c: function c() {\n      create_component(branding.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(branding, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var branding_changes = {};\n      if (dirty &\n      /*$app*/\n      8) branding_changes.darkMode =\n      /*$app*/\n      ctx[3].darkMode;\n      branding.$set(branding_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(branding.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(branding.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(branding, detaching);\n    }\n  };\n} // (98:4) {#if closeable}\n\n\nfunction create_if_block$1(ctx) {\n  var div;\n  var svg;\n  var g0;\n  var path;\n  var g1;\n  var g2;\n  var g3;\n  var g4;\n  var g5;\n  var g6;\n  var g7;\n  var g8;\n  var g9;\n  var g10;\n  var g11;\n  var g12;\n  var g13;\n  var g14;\n  var g15;\n  var svg_fill_value;\n  var mounted;\n  var dispose;\n  return {\n    c: function c() {\n      div = element(\"div\");\n      svg = svg_element(\"svg\");\n      g0 = svg_element(\"g\");\n      path = svg_element(\"path\");\n      g1 = svg_element(\"g\");\n      g2 = svg_element(\"g\");\n      g3 = svg_element(\"g\");\n      g4 = svg_element(\"g\");\n      g5 = svg_element(\"g\");\n      g6 = svg_element(\"g\");\n      g7 = svg_element(\"g\");\n      g8 = svg_element(\"g\");\n      g9 = svg_element(\"g\");\n      g10 = svg_element(\"g\");\n      g11 = svg_element(\"g\");\n      g12 = svg_element(\"g\");\n      g13 = svg_element(\"g\");\n      g14 = svg_element(\"g\");\n      g15 = svg_element(\"g\");\n      attr(path, \"d\", \"M28.228,23.986L47.092,5.122c1.172-1.171,1.172-3.071,0-4.242c-1.172-1.172-3.07-1.172-4.242,0L23.986,19.744L5.121,0.88\\n              c-1.172-1.172-3.07-1.172-4.242,0c-1.172,1.171-1.172,3.071,0,4.242l18.865,18.864L0.879,42.85c-1.172,1.171-1.172,3.071,0,4.242\\n              C1.465,47.677,2.233,47.97,3,47.97s1.535-0.293,2.121-0.879l18.865-18.864L42.85,47.091c0.586,0.586,1.354,0.879,2.121,0.879\\n              s1.535-0.293,2.121-0.879c1.172-1.171,1.172-3.071,0-4.242L28.228,23.986z\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n      attr(svg, \"x\", \"0px\");\n      attr(svg, \"y\", \"0px\");\n      attr(svg, \"viewBox\", \"0 0 47.971 47.971\");\n      set_style(svg, \"enable-background\", \"new 0 0 47.971 47.971\");\n      set_style(svg, \"transition\", \"fill 150ms\\n          ease-in-out\");\n      attr(svg, \"fill\", svg_fill_value =\n      /*closeHovered*/\n      ctx[2] ?\n      /*$app*/\n      ctx[3].darkMode ? \"#ffffff\" : \"#4a4a4a\" : \"#9B9B9B\");\n      attr(svg, \"xml:space\", \"preserve\");\n      attr(svg, \"class\", \"svelte-rntogh\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-modal-content-close svelte-rntogh\");\n      toggle_class(div, \"bn-onboard-dark-mode-close-background\",\n      /*$app*/\n      ctx[3].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, svg);\n      append(svg, g0);\n      append(g0, path);\n      append(svg, g1);\n      append(svg, g2);\n      append(svg, g3);\n      append(svg, g4);\n      append(svg, g5);\n      append(svg, g6);\n      append(svg, g7);\n      append(svg, g8);\n      append(svg, g9);\n      append(svg, g10);\n      append(svg, g11);\n      append(svg, g12);\n      append(svg, g13);\n      append(svg, g14);\n      append(svg, g15);\n\n      if (!mounted) {\n        dispose = [listen(div, \"click\", function () {\n          if (is_function(\n          /*closeModal*/\n          ctx[0]))\n            /*closeModal*/\n            ctx[0].apply(this, arguments);\n        }), listen(div, \"mouseenter\",\n        /*mouseenter_handler*/\n        ctx[6]), listen(div, \"mouseleave\",\n        /*mouseleave_handler*/\n        ctx[7])];\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n\n      if (dirty &\n      /*closeHovered, $app*/\n      12 && svg_fill_value !== (svg_fill_value =\n      /*closeHovered*/\n      ctx[2] ?\n      /*$app*/\n      ctx[3].darkMode ? \"#ffffff\" : \"#4a4a4a\" : \"#9B9B9B\")) {\n        attr(svg, \"fill\", svg_fill_value);\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(div, \"bn-onboard-dark-mode-close-background\",\n        /*$app*/\n        ctx[3].darkMode);\n      }\n    },\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\n\nfunction create_fragment$1(ctx) {\n  var aside;\n  var section;\n  var t0;\n  var t1;\n  var aside_transition;\n  var current;\n  var mounted;\n  var dispose;\n  var default_slot_template =\n  /*$$slots*/\n  ctx[5][\"default\"];\n  var default_slot = create_slot(default_slot_template, ctx,\n  /*$$scope*/\n  ctx[4], null);\n  var if_block0 =\n  /*$app*/\n  ctx[3].displayBranding && create_if_block_1(ctx);\n  var if_block1 =\n  /*closeable*/\n  ctx[1] && create_if_block$1(ctx);\n  return {\n    c: function c() {\n      aside = element(\"aside\");\n      section = element(\"section\");\n      if (default_slot) default_slot.c();\n      t0 = space();\n      if (if_block0) if_block0.c();\n      t1 = space();\n      if (if_block1) if_block1.c();\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-modal-content svelte-rntogh\");\n      toggle_class(section, \"bn-onboard-dark-mode\",\n      /*$app*/\n      ctx[3].darkMode);\n      toggle_class(section, \"no-padding-branding\",\n      /*$app*/\n      ctx[3].displayBranding);\n      attr(aside, \"class\", \"bn-onboard-custom bn-onboard-modal svelte-rntogh\");\n    },\n    m: function m(target, anchor) {\n      insert(target, aside, anchor);\n      append(aside, section);\n\n      if (default_slot) {\n        default_slot.m(section, null);\n      }\n\n      append(section, t0);\n      if (if_block0) if_block0.m(section, null);\n      append(section, t1);\n      if (if_block1) if_block1.m(section, null);\n      current = true;\n\n      if (!mounted) {\n        dispose = [listen(section, \"click\", click_handler), listen(aside, \"click\", function () {\n          if (is_function(\n          /*closeModal*/\n          ctx[0]))\n            /*closeModal*/\n            ctx[0].apply(this, arguments);\n        })];\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref12) {\n      var _ref13 = _slicedToArray(_ref12, 1),\n          dirty = _ref13[0];\n\n      ctx = new_ctx;\n\n      if (default_slot) {\n        if (default_slot.p && dirty &\n        /*$$scope*/\n        16) {\n          update_slot(default_slot, default_slot_template, ctx,\n          /*$$scope*/\n          ctx[4], dirty, null, null);\n        }\n      }\n\n      if (\n      /*$app*/\n      ctx[3].displayBranding) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          8) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_1(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(section, t1);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*closeable*/\n      ctx[1]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n        } else {\n          if_block1 = create_if_block$1(ctx);\n          if_block1.c();\n          if_block1.m(section, null);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(section, \"bn-onboard-dark-mode\",\n        /*$app*/\n        ctx[3].darkMode);\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(section, \"no-padding-branding\",\n        /*$app*/\n        ctx[3].displayBranding);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      transition_in(if_block0);\n      add_render_callback(function () {\n        if (!aside_transition) aside_transition = create_bidirectional_transition(aside, fade, {}, true);\n        aside_transition.run(1);\n      });\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(default_slot, local);\n      transition_out(if_block0);\n      if (!aside_transition) aside_transition = create_bidirectional_transition(aside, fade, {}, false);\n      aside_transition.run(0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(aside);\n      if (default_slot) default_slot.d(detaching);\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n      if (detaching && aside_transition) aside_transition.end();\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\n\nvar click_handler = function click_handler(e) {\n  return e.stopPropagation();\n};\n\nfunction instance$1($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(3, $app = $$value);\n  });\n  var closeModal = $$props.closeModal;\n  var _$$props$closeable = $$props.closeable,\n      closeable = _$$props$closeable === void 0 ? true : _$$props$closeable;\n  var closeHovered;\n  var _$$props$$$slots = $$props.$$slots,\n      $$slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,\n      $$scope = $$props.$$scope;\n\n  var mouseenter_handler = function mouseenter_handler() {\n    return $$invalidate(2, closeHovered = true);\n  };\n\n  var mouseleave_handler = function mouseleave_handler() {\n    return $$invalidate(2, closeHovered = false);\n  };\n\n  $$self.$set = function ($$props) {\n    if (\"closeModal\" in $$props) $$invalidate(0, closeModal = $$props.closeModal);\n    if (\"closeable\" in $$props) $$invalidate(1, closeable = $$props.closeable);\n    if (\"$$scope\" in $$props) $$invalidate(4, $$scope = $$props.$$scope);\n  };\n\n  return [closeModal, closeable, closeHovered, $app, $$scope, $$slots, mouseenter_handler, mouseleave_handler];\n}\n\nvar Modal = /*#__PURE__*/function (_SvelteComponent2) {\n  _inherits(Modal, _SvelteComponent2);\n\n  var _super2 = _createSuper(Modal);\n\n  function Modal(options) {\n    var _this2;\n\n    _classCallCheck(this, Modal);\n\n    _this2 = _super2.call(this);\n    if (!document.getElementById(\"svelte-rntogh-style\")) add_css$1();\n    init(_assertThisInitialized(_this2), options, instance$1, create_fragment$1, safe_not_equal, {\n      closeModal: 0,\n      closeable: 1\n    });\n    return _this2;\n  }\n\n  return Modal;\n}(SvelteComponent);\n/* src/components/ModalHeader.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$2() {\n  var style = element(\"style\");\n  style.id = \"svelte-8i8o6j-style\";\n  style.textContent = \"header.svelte-8i8o6j{display:flex;align-items:center;font-size:inherit;font-family:inherit;margin-bottom:1em}div.svelte-8i8o6j{display:flex;justify-content:center;align-items:center;font-size:inherit;font-family:inherit;padding:0.6em;border-radius:30px;background:#eeeeee}h3.svelte-8i8o6j{font-weight:bold;font-size:1.33em;font-family:inherit;margin:0 0 0 0.5em}\";\n  append(document.head, style);\n}\n\nfunction create_fragment$2(ctx) {\n  var header;\n  var div;\n  var t0;\n  var h3;\n  var t1;\n  return {\n    c: function c() {\n      header = element(\"header\");\n      div = element(\"div\");\n      t0 = space();\n      h3 = element(\"h3\");\n      t1 = text(\n      /*heading*/\n      ctx[0]);\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header-icon svelte-8i8o6j\");\n      toggle_class(div, \"bn-onboard-dark-mode-background\",\n      /*$app*/\n      ctx[2].darkMode);\n      attr(h3, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header-heading svelte-8i8o6j\");\n      attr(header, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header svelte-8i8o6j\");\n    },\n    m: function m(target, anchor) {\n      insert(target, header, anchor);\n      append(header, div);\n      div.innerHTML =\n      /*icon*/\n      ctx[1];\n      append(header, t0);\n      append(header, h3);\n      append(h3, t1);\n    },\n    p: function p(ctx, _ref14) {\n      var _ref15 = _slicedToArray(_ref14, 1),\n          dirty = _ref15[0];\n\n      if (dirty &\n      /*icon*/\n      2) div.innerHTML =\n      /*icon*/\n      ctx[1];\n\n      if (dirty &\n      /*$app*/\n      4) {\n        toggle_class(div, \"bn-onboard-dark-mode-background\",\n        /*$app*/\n        ctx[2].darkMode);\n      }\n\n      if (dirty &\n      /*heading*/\n      1) set_data(t1,\n      /*heading*/\n      ctx[0]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(header);\n    }\n  };\n}\n\nfunction instance$2($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(2, $app = $$value);\n  });\n  var heading = $$props.heading;\n  var icon = $$props.icon;\n\n  $$self.$set = function ($$props) {\n    if (\"heading\" in $$props) $$invalidate(0, heading = $$props.heading);\n    if (\"icon\" in $$props) $$invalidate(1, icon = $$props.icon);\n  };\n\n  return [heading, icon, $app];\n}\n\nvar ModalHeader = /*#__PURE__*/function (_SvelteComponent3) {\n  _inherits(ModalHeader, _SvelteComponent3);\n\n  var _super3 = _createSuper(ModalHeader);\n\n  function ModalHeader(options) {\n    var _this3;\n\n    _classCallCheck(this, ModalHeader);\n\n    _this3 = _super3.call(this);\n    if (!document.getElementById(\"svelte-8i8o6j-style\")) add_css$2();\n    init(_assertThisInitialized(_this3), options, instance$2, create_fragment$2, safe_not_equal, {\n      heading: 0,\n      icon: 1\n    });\n    return _this3;\n  }\n\n  return ModalHeader;\n}(SvelteComponent);\n/* src/elements/Button.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$3() {\n  var style = element(\"style\");\n  style.id = \"svelte-r5g1v4-style\";\n  style.textContent = \"button.svelte-r5g1v4{background:inherit;font-size:0.889em;font-family:inherit;border:1px solid #4a90e2;border-radius:40px;padding:0.55em 1.4em;cursor:pointer;color:#4a90e2;font-family:inherit;transition:background 150ms ease-in-out;line-height:1.15}button.svelte-r5g1v4:focus{outline:none}button.svelte-r5g1v4:hover{background:#ecf3fc}.bn-onboard-prepare-button-right.svelte-r5g1v4{position:absolute;right:0}.bn-onboard-prepare-button-left.svelte-r5g1v4{position:absolute;left:0}\";\n  append(document.head, style);\n}\n\nfunction create_fragment$3(ctx) {\n  var button;\n  var current;\n  var mounted;\n  var dispose;\n  var default_slot_template =\n  /*$$slots*/\n  ctx[4][\"default\"];\n  var default_slot = create_slot(default_slot_template, ctx,\n  /*$$scope*/\n  ctx[3], null);\n  return {\n    c: function c() {\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"bn-onboard-custom bn-onboard-prepare-button svelte-r5g1v4\");\n      toggle_class(button, \"bn-onboard-prepare-button-right\",\n      /*position*/\n      ctx[1] === \"right\");\n      toggle_class(button, \"bn-onboard-prepare-button-left\",\n      /*position*/\n      ctx[1] === \"left\");\n      toggle_class(button, \"bn-onboard-prepare-button-center\",\n      /*position*/\n      ctx[1] !== \"left\" &&\n      /*position*/\n      ctx[1] !== \"right\");\n      toggle_class(button, \"bn-onboard-dark-mode-link\",\n      /*$app*/\n      ctx[2].darkMode);\n      toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n      /*$app*/\n      ctx[2].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, button, anchor);\n\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(button, \"click\", function () {\n          if (is_function(\n          /*onclick*/\n          ctx[0]))\n            /*onclick*/\n            ctx[0].apply(this, arguments);\n        });\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref16) {\n      var _ref17 = _slicedToArray(_ref16, 1),\n          dirty = _ref17[0];\n\n      ctx = new_ctx;\n\n      if (default_slot) {\n        if (default_slot.p && dirty &\n        /*$$scope*/\n        8) {\n          update_slot(default_slot, default_slot_template, ctx,\n          /*$$scope*/\n          ctx[3], dirty, null, null);\n        }\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-right\",\n        /*position*/\n        ctx[1] === \"right\");\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-left\",\n        /*position*/\n        ctx[1] === \"left\");\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-center\",\n        /*position*/\n        ctx[1] !== \"left\" &&\n        /*position*/\n        ctx[1] !== \"right\");\n      }\n\n      if (dirty &\n      /*$app*/\n      4) {\n        toggle_class(button, \"bn-onboard-dark-mode-link\",\n        /*$app*/\n        ctx[2].darkMode);\n      }\n\n      if (dirty &\n      /*$app*/\n      4) {\n        toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n        /*$app*/\n        ctx[2].darkMode);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(button);\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\nfunction instance$3($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(2, $app = $$value);\n  });\n  var _$$props$onclick = $$props.onclick,\n      onclick = _$$props$onclick === void 0 ? function () {} : _$$props$onclick;\n  var position = $$props.position;\n  var _$$props$$$slots2 = $$props.$$slots,\n      $$slots = _$$props$$$slots2 === void 0 ? {} : _$$props$$$slots2,\n      $$scope = $$props.$$scope;\n\n  $$self.$set = function ($$props) {\n    if (\"onclick\" in $$props) $$invalidate(0, onclick = $$props.onclick);\n    if (\"position\" in $$props) $$invalidate(1, position = $$props.position);\n    if (\"$$scope\" in $$props) $$invalidate(3, $$scope = $$props.$$scope);\n  };\n\n  return [onclick, position, $app, $$scope, $$slots];\n}\n\nvar Button = /*#__PURE__*/function (_SvelteComponent4) {\n  _inherits(Button, _SvelteComponent4);\n\n  var _super4 = _createSuper(Button);\n\n  function Button(options) {\n    var _this4;\n\n    _classCallCheck(this, Button);\n\n    _this4 = _super4.call(this);\n    if (!document.getElementById(\"svelte-r5g1v4-style\")) add_css$3();\n    init(_assertThisInitialized(_this4), options, instance$3, create_fragment$3, safe_not_equal, {\n      onclick: 0,\n      position: 1\n    });\n    return _this4;\n  }\n\n  return Button;\n}(SvelteComponent);\n/* src/elements/Spinner.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$4() {\n  var style = element(\"style\");\n  style.id = \"svelte-16ghk2h-style\";\n  style.textContent = \".bn-onboard-loading-container.svelte-16ghk2h{display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:inherit;font-size:inherit;color:inherit}span.svelte-16ghk2h{font-family:inherit;font-size:0.889em;margin-top:1rem}.bn-onboard-loading{display:inline-block;position:relative;width:2em;height:2em}.bn-onboard-loading div{box-sizing:border-box;font-size:inherit;display:block;position:absolute;width:2em;height:2em;border:3px solid;border-radius:50%;animation:bn-onboard-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.bn-onboard-loading .bn-onboard-loading-first{animation-delay:-0.45s}.bn-onboard-loading .bn-onboard-loading-second{animation-delay:-0.3s}.bn-onboard-loading .bn-onboard-loading-third{animation-delay:-0.15s}@keyframes bn-onboard-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\";\n  append(document.head, style);\n} // (65:2) {#if description}\n\n\nfunction create_if_block$2(ctx) {\n  var span;\n  var t;\n  return {\n    c: function c() {\n      span = element(\"span\");\n      t = text(\n      /*description*/\n      ctx[0]);\n      attr(span, \"class\", \"svelte-16ghk2h\");\n    },\n    m: function m(target, anchor) {\n      insert(target, span, anchor);\n      append(span, t);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*description*/\n      1) set_data(t,\n      /*description*/\n      ctx[0]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n}\n\nfunction create_fragment$4(ctx) {\n  var div4;\n  var div3;\n  var t2;\n  var if_block =\n  /*description*/\n  ctx[0] && create_if_block$2(ctx);\n  return {\n    c: function c() {\n      div4 = element(\"div\");\n      div3 = element(\"div\");\n      div3.innerHTML = \"<div class=\\\"bn-onboard-loading-first\\\"></div> \\n    <div class=\\\"bn-onboard-loading-second\\\"></div> \\n    <div class=\\\"bn-onboard-loading-third\\\"></div>\";\n      t2 = space();\n      if (if_block) if_block.c();\n      attr(div3, \"class\", \"bn-onboard-custom bn-onboard-loading\");\n      attr(div4, \"class\", \"bn-onboard-loading-container svelte-16ghk2h\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div4, anchor);\n      append(div4, div3);\n      append(div4, t2);\n      if (if_block) if_block.m(div4, null);\n    },\n    p: function p(ctx, _ref18) {\n      var _ref19 = _slicedToArray(_ref18, 1),\n          dirty = _ref19[0];\n\n      if (\n      /*description*/\n      ctx[0]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$2(ctx);\n          if_block.c();\n          if_block.m(div4, null);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div4);\n      if (if_block) if_block.d();\n    }\n  };\n}\n\nfunction instance$4($$self, $$props, $$invalidate) {\n  var description = $$props.description;\n\n  $$self.$set = function ($$props) {\n    if (\"description\" in $$props) $$invalidate(0, description = $$props.description);\n  };\n\n  return [description];\n}\n\nvar Spinner = /*#__PURE__*/function (_SvelteComponent5) {\n  _inherits(Spinner, _SvelteComponent5);\n\n  var _super5 = _createSuper(Spinner);\n\n  function Spinner(options) {\n    var _this5;\n\n    _classCallCheck(this, Spinner);\n\n    _this5 = _super5.call(this);\n    if (!document.getElementById(\"svelte-16ghk2h-style\")) add_css$4();\n    init(_assertThisInitialized(_this5), options, instance$4, create_fragment$4, safe_not_equal, {\n      description: 0\n    });\n    return _this5;\n  }\n\n  return Spinner;\n}(SvelteComponent);\n/* src/elements/IconButton.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$5() {\n  var style = element(\"style\");\n  style.id = \"svelte-1skxsnk-style\";\n  style.textContent = \"button.svelte-1skxsnk{display:flex;align-items:center;border:none;margin:0.33em 0;background:inherit;font-size:inherit;width:18em;padding:0.625em 1.25em;transition:box-shadow 150ms ease-in-out, background 200ms ease-in-out;border-radius:40px;cursor:pointer;color:inherit;line-height:1.15;font-family:inherit}button.svelte-1skxsnk:hover{box-shadow:0 2px 10px 0 rgba(0, 0, 0, 0.1)}button.svelte-1skxsnk:focus{outline:none}div.svelte-1skxsnk{display:flex;justify-content:center;align-items:center;text-align:center;height:40px;width:40px;line-height:40px;font-family:inherit}img.svelte-1skxsnk{max-height:100%;max-width:100%;vertical-align:middle}span.svelte-1skxsnk{width:100%;display:flex;justify-content:space-between;align-items:center;font-size:inherit;margin-left:0.66em;font-weight:bold;text-align:left;font-family:inherit}i.svelte-1skxsnk{font-size:0.8rem;font-weight:lighter;color:inherit;text-decoration:underline}@media only screen and (max-width: 450px){button.svelte-1skxsnk{width:100%}}.bn-onboard-selected-wallet.svelte-1skxsnk{background:#c3c3c3}\";\n  append(document.head, style);\n} // (96:4) {:else}\n\n\nfunction create_else_block$1(ctx) {\n  var img;\n  var img_src_value;\n  return {\n    c: function c() {\n      img = element(\"img\");\n      if (img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) attr(img, \"src\", img_src_value);\n      attr(img, \"srcset\",\n      /*iconSrcSet*/\n      ctx[1]);\n      attr(img, \"alt\",\n      /*text*/\n      ctx[4]);\n      attr(img, \"class\", \"svelte-1skxsnk\");\n    },\n    m: function m(target, anchor) {\n      insert(target, img, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*iconSrc*/\n      1 && img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) {\n        attr(img, \"src\", img_src_value);\n      }\n\n      if (dirty &\n      /*iconSrcSet*/\n      2) {\n        attr(img, \"srcset\",\n        /*iconSrcSet*/\n        ctx[1]);\n      }\n\n      if (dirty &\n      /*text*/\n      16) {\n        attr(img, \"alt\",\n        /*text*/\n        ctx[4]);\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(img);\n    }\n  };\n} // (94:18) \n\n\nfunction create_if_block_2(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*svg*/\n      ctx[2], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*svg*/\n      4) html_tag.p(\n      /*svg*/\n      ctx[2]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n} // (92:4) {#if loadingWallet === text}\n\n\nfunction create_if_block_1$1(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({});\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (102:4) {#if currentlySelected}\n\n\nfunction create_if_block$3(ctx) {\n  var i;\n  return {\n    c: function c() {\n      i = element(\"i\");\n      i.textContent = \"selected\";\n      attr(i, \"class\", \"svelte-1skxsnk\");\n    },\n    m: function m(target, anchor) {\n      insert(target, i, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(i);\n    }\n  };\n}\n\nfunction create_fragment$5(ctx) {\n  var button;\n  var div;\n  var current_block_type_index;\n  var if_block0;\n  var t0;\n  var span;\n  var t1;\n  var t2;\n  var current;\n  var mounted;\n  var dispose;\n  var if_block_creators = [create_if_block_1$1, create_if_block_2, create_else_block$1];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*loadingWallet*/\n    ctx[5] ===\n    /*text*/\n    ctx[4]) return 0;\n    if (\n    /*svg*/\n    ctx[2]) return 1;\n    return 2;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  var if_block1 =\n  /*currentlySelected*/\n  ctx[6] && create_if_block$3();\n  return {\n    c: function c() {\n      button = element(\"button\");\n      div = element(\"div\");\n      if_block0.c();\n      t0 = space();\n      span = element(\"span\");\n      t1 = text(\n      /*text*/\n      ctx[4]);\n      t2 = space();\n      if (if_block1) if_block1.c();\n      attr(div, \"class\", \"svelte-1skxsnk\");\n      attr(span, \"class\", \"svelte-1skxsnk\");\n      attr(button, \"class\", \"bn-onboard-custom bn-onboard-icon-button svelte-1skxsnk\");\n      toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n      /*$app*/\n      ctx[7].darkMode);\n      toggle_class(button, \"bn-onboard-selected-wallet\",\n      /*currentlySelected*/\n      ctx[6]);\n    },\n    m: function m(target, anchor) {\n      insert(target, button, anchor);\n      append(button, div);\n      if_blocks[current_block_type_index].m(div, null);\n      append(button, t0);\n      append(button, span);\n      append(span, t1);\n      append(span, t2);\n      if (if_block1) if_block1.m(span, null);\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(button, \"click\", function () {\n          if (is_function(\n          /*onclick*/\n          ctx[3]))\n            /*onclick*/\n            ctx[3].apply(this, arguments);\n        });\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref20) {\n      var _ref21 = _slicedToArray(_ref20, 1),\n          dirty = _ref21[0];\n\n      ctx = new_ctx;\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block0 = if_blocks[current_block_type_index];\n\n        if (!if_block0) {\n          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block0.c();\n        }\n\n        transition_in(if_block0, 1);\n        if_block0.m(div, null);\n      }\n\n      if (!current || dirty &\n      /*text*/\n      16) set_data(t1,\n      /*text*/\n      ctx[4]);\n\n      if (\n      /*currentlySelected*/\n      ctx[6]) {\n        if (if_block1) ;else {\n          if_block1 = create_if_block$3();\n          if_block1.c();\n          if_block1.m(span, null);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (dirty &\n      /*$app*/\n      128) {\n        toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n        /*$app*/\n        ctx[7].darkMode);\n      }\n\n      if (dirty &\n      /*currentlySelected*/\n      64) {\n        toggle_class(button, \"bn-onboard-selected-wallet\",\n        /*currentlySelected*/\n        ctx[6]);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(button);\n      if_blocks[current_block_type_index].d();\n      if (if_block1) if_block1.d();\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\nfunction instance$5($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(7, $app = $$value);\n  });\n  var iconSrc = $$props.iconSrc;\n  var iconSrcSet = $$props.iconSrcSet;\n  var svg = $$props.svg;\n  var _$$props$onclick2 = $$props.onclick,\n      onclick = _$$props$onclick2 === void 0 ? function () {} : _$$props$onclick2;\n  var text = $$props.text;\n  var loadingWallet = $$props.loadingWallet;\n  var _$$props$currentlySel = $$props.currentlySelected,\n      currentlySelected = _$$props$currentlySel === void 0 ? false : _$$props$currentlySel;\n\n  $$self.$set = function ($$props) {\n    if (\"iconSrc\" in $$props) $$invalidate(0, iconSrc = $$props.iconSrc);\n    if (\"iconSrcSet\" in $$props) $$invalidate(1, iconSrcSet = $$props.iconSrcSet);\n    if (\"svg\" in $$props) $$invalidate(2, svg = $$props.svg);\n    if (\"onclick\" in $$props) $$invalidate(3, onclick = $$props.onclick);\n    if (\"text\" in $$props) $$invalidate(4, text = $$props.text);\n    if (\"loadingWallet\" in $$props) $$invalidate(5, loadingWallet = $$props.loadingWallet);\n    if (\"currentlySelected\" in $$props) $$invalidate(6, currentlySelected = $$props.currentlySelected);\n  };\n\n  return [iconSrc, iconSrcSet, svg, onclick, text, loadingWallet, currentlySelected, $app];\n}\n\nvar IconButton = /*#__PURE__*/function (_SvelteComponent6) {\n  _inherits(IconButton, _SvelteComponent6);\n\n  var _super6 = _createSuper(IconButton);\n\n  function IconButton(options) {\n    var _this6;\n\n    _classCallCheck(this, IconButton);\n\n    _this6 = _super6.call(this);\n    if (!document.getElementById(\"svelte-1skxsnk-style\")) add_css$5();\n    init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n      iconSrc: 0,\n      iconSrcSet: 1,\n      svg: 2,\n      onclick: 3,\n      text: 4,\n      loadingWallet: 5,\n      currentlySelected: 6\n    });\n    return _this6;\n  }\n\n  return IconButton;\n}(SvelteComponent);\n/* src/components/Wallets.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$6() {\n  var style = element(\"style\");\n  style.id = \"svelte-q1527-style\";\n  style.textContent = \"ul.svelte-q1527.svelte-q1527{display:flex;flex-flow:row wrap;align-items:center;list-style-type:none;margin:1.25em 0;padding:0;font-family:inherit;font-size:inherit;line-height:1.15;box-sizing:border-box}ul.svelte-q1527 li.svelte-q1527{padding:0 0.25em}div.svelte-q1527.svelte-q1527{width:100%;display:flex;font-size:inherit;font-family:inherit;justify-content:center;margin-top:1.25em}.svelte-q1527.svelte-q1527::-webkit-scrollbar{display:none}@media only screen and (max-width: 450px){ul.svelte-q1527 li.svelte-q1527{width:100%}ul.svelte-q1527.svelte-q1527{max-height:66vh;overflow-y:scroll}}\";\n  append(document.head, style);\n}\n\nfunction get_each_context(ctx, list, i) {\n  var child_ctx = ctx.slice();\n  child_ctx[9] = list[i];\n  child_ctx[11] = i;\n  return child_ctx;\n}\n\nfunction get_each_context_1(ctx, list, i) {\n  var child_ctx = ctx.slice();\n  child_ctx[9] = list[i];\n  child_ctx[11] = i;\n  return child_ctx;\n} // (61:2) {#each modalData.primaryWallets as wallet, i (wallet.name)}\n\n\nfunction create_each_block_1(key_1, ctx) {\n  var li;\n  var iconbutton;\n  var current;\n\n  function func() {\n    var _ctx;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return (\n      /*func*/\n      (_ctx = ctx)[6].apply(_ctx, [\n      /*wallet*/\n      ctx[9]].concat(args))\n    );\n  }\n\n  iconbutton = new IconButton({\n    props: {\n      onclick: func,\n      iconSrc:\n      /*wallet*/\n      ctx[9].iconSrc,\n      iconSrcSet:\n      /*wallet*/\n      ctx[9].iconSrcSet,\n      svg:\n      /*wallet*/\n      ctx[9].svg,\n      text:\n      /*wallet*/\n      ctx[9].name,\n      currentlySelected:\n      /*wallet*/\n      ctx[9].name ===\n      /*selectedWallet*/\n      ctx[5].name,\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[2]\n    }\n  });\n  return {\n    key: key_1,\n    first: null,\n    c: function c() {\n      li = element(\"li\");\n      create_component(iconbutton.$$.fragment);\n      attr(li, \"class\", \"svelte-q1527\");\n      this.first = li;\n    },\n    m: function m(target, anchor) {\n      insert(target, li, anchor);\n      mount_component(iconbutton, li, null);\n      current = true;\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n      var iconbutton_changes = {};\n      if (dirty &\n      /*handleWalletSelect, modalData*/\n      3) iconbutton_changes.onclick = func;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrc =\n      /*wallet*/\n      ctx[9].iconSrc;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrcSet =\n      /*wallet*/\n      ctx[9].iconSrcSet;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.svg =\n      /*wallet*/\n      ctx[9].svg;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.text =\n      /*wallet*/\n      ctx[9].name;\n      if (dirty &\n      /*modalData, selectedWallet*/\n      33) iconbutton_changes.currentlySelected =\n      /*wallet*/\n      ctx[9].name ===\n      /*selectedWallet*/\n      ctx[5].name;\n      if (dirty &\n      /*loadingWallet*/\n      4) iconbutton_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[2];\n      iconbutton.$set(iconbutton_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(iconbutton.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(iconbutton.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(li);\n      destroy_component(iconbutton);\n    }\n  };\n} // (74:2) {#if modalData.secondaryWallets && modalData.secondaryWallets.length && !showingAllWalletModules}\n\n\nfunction create_if_block_1$2(ctx) {\n  var div;\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      onclick:\n      /*showAllWallets*/\n      ctx[4],\n      $$slots: {\n        \"default\": [create_default_slot]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      div = element(\"div\");\n      create_component(button.$$.fragment);\n      attr(div, \"class\", \"svelte-q1527\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      mount_component(button, div, null);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*showAllWallets*/\n      16) button_changes.onclick =\n      /*showAllWallets*/\n      ctx[4];\n\n      if (dirty &\n      /*$$scope*/\n      8192) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      destroy_component(button);\n    }\n  };\n} // (76:6) <Button onclick={showAllWallets}>\n\n\nfunction create_default_slot(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Show More\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (80:2) {#if showingAllWalletModules}\n\n\nfunction create_if_block$4(ctx) {\n  var each_blocks = [];\n  var each_1_lookup = new Map();\n  var each_1_anchor;\n  var current;\n  var each_value =\n  /*modalData*/\n  ctx[0].secondaryWallets;\n\n  var get_key = function get_key(ctx) {\n    return (\n      /*wallet*/\n      ctx[9].name\n    );\n  };\n\n  for (var i = 0; i < each_value.length; i += 1) {\n    var child_ctx = get_each_context(ctx, each_value, i);\n    var key = get_key(child_ctx);\n    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));\n  }\n\n  return {\n    c: function c() {\n      for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n        each_blocks[_i3].c();\n      }\n\n      each_1_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {\n        each_blocks[_i4].m(target, anchor);\n      }\n\n      insert(target, each_1_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*handleWalletSelect, modalData, selectedWallet, loadingWallet*/\n      39) {\n        var _each_value =\n        /*modalData*/\n        ctx[0].secondaryWallets;\n        group_outros();\n        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, _each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n\n      for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n        transition_in(each_blocks[_i5]);\n      }\n\n      current = true;\n    },\n    o: function o(local) {\n      for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n        transition_out(each_blocks[_i6]);\n      }\n\n      current = false;\n    },\n    d: function d(detaching) {\n      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {\n        each_blocks[_i7].d(detaching);\n      }\n\n      if (detaching) detach(each_1_anchor);\n    }\n  };\n} // (81:4) {#each modalData.secondaryWallets as wallet, i (wallet.name)}\n\n\nfunction create_each_block(key_1, ctx) {\n  var li;\n  var iconbutton;\n  var t;\n  var current;\n\n  function func_1() {\n    var _ctx2;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return (\n      /*func_1*/\n      (_ctx2 = ctx)[7].apply(_ctx2, [\n      /*wallet*/\n      ctx[9]].concat(args))\n    );\n  }\n\n  iconbutton = new IconButton({\n    props: {\n      onclick: func_1,\n      iconSrc:\n      /*wallet*/\n      ctx[9].iconSrc,\n      iconSrcSet:\n      /*wallet*/\n      ctx[9].iconSrcSet,\n      svg:\n      /*wallet*/\n      ctx[9].svg,\n      text:\n      /*wallet*/\n      ctx[9].name,\n      currentlySelected:\n      /*wallet*/\n      ctx[9].name ===\n      /*selectedWallet*/\n      ctx[5].name,\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[2]\n    }\n  });\n  return {\n    key: key_1,\n    first: null,\n    c: function c() {\n      li = element(\"li\");\n      create_component(iconbutton.$$.fragment);\n      t = space();\n      attr(li, \"class\", \"svelte-q1527\");\n      this.first = li;\n    },\n    m: function m(target, anchor) {\n      insert(target, li, anchor);\n      mount_component(iconbutton, li, null);\n      append(li, t);\n      current = true;\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n      var iconbutton_changes = {};\n      if (dirty &\n      /*handleWalletSelect, modalData*/\n      3) iconbutton_changes.onclick = func_1;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrc =\n      /*wallet*/\n      ctx[9].iconSrc;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrcSet =\n      /*wallet*/\n      ctx[9].iconSrcSet;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.svg =\n      /*wallet*/\n      ctx[9].svg;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.text =\n      /*wallet*/\n      ctx[9].name;\n      if (dirty &\n      /*modalData, selectedWallet*/\n      33) iconbutton_changes.currentlySelected =\n      /*wallet*/\n      ctx[9].name ===\n      /*selectedWallet*/\n      ctx[5].name;\n      if (dirty &\n      /*loadingWallet*/\n      4) iconbutton_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[2];\n      iconbutton.$set(iconbutton_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(iconbutton.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(iconbutton.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(li);\n      destroy_component(iconbutton);\n    }\n  };\n}\n\nfunction create_fragment$6(ctx) {\n  var ul;\n  var each_blocks = [];\n  var each_1_lookup = new Map();\n  var t0;\n  var t1;\n  var current;\n  var each_value_1 =\n  /*modalData*/\n  ctx[0].primaryWallets;\n\n  var get_key = function get_key(ctx) {\n    return (\n      /*wallet*/\n      ctx[9].name\n    );\n  };\n\n  for (var i = 0; i < each_value_1.length; i += 1) {\n    var child_ctx = get_each_context_1(ctx, each_value_1, i);\n    var key = get_key(child_ctx);\n    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));\n  }\n\n  var if_block0 =\n  /*modalData*/\n  ctx[0].secondaryWallets &&\n  /*modalData*/\n  ctx[0].secondaryWallets.length && !\n  /*showingAllWalletModules*/\n  ctx[3] && create_if_block_1$2(ctx);\n  var if_block1 =\n  /*showingAllWalletModules*/\n  ctx[3] && create_if_block$4(ctx);\n  return {\n    c: function c() {\n      ul = element(\"ul\");\n\n      for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {\n        each_blocks[_i8].c();\n      }\n\n      t0 = space();\n      if (if_block0) if_block0.c();\n      t1 = space();\n      if (if_block1) if_block1.c();\n      attr(ul, \"class\", \"bn-onboard-custom bn-onboard-modal-select-wallets svelte-q1527\");\n    },\n    m: function m(target, anchor) {\n      insert(target, ul, anchor);\n\n      for (var _i9 = 0; _i9 < each_blocks.length; _i9 += 1) {\n        each_blocks[_i9].m(ul, null);\n      }\n\n      append(ul, t0);\n      if (if_block0) if_block0.m(ul, null);\n      append(ul, t1);\n      if (if_block1) if_block1.m(ul, null);\n      current = true;\n    },\n    p: function p(ctx, _ref22) {\n      var _ref23 = _slicedToArray(_ref22, 1),\n          dirty = _ref23[0];\n\n      if (dirty &\n      /*handleWalletSelect, modalData, selectedWallet, loadingWallet*/\n      39) {\n        var _each_value_ =\n        /*modalData*/\n        ctx[0].primaryWallets;\n        group_outros();\n        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, _each_value_, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1, t0, get_each_context_1);\n        check_outros();\n      }\n\n      if (\n      /*modalData*/\n      ctx[0].secondaryWallets &&\n      /*modalData*/\n      ctx[0].secondaryWallets.length && !\n      /*showingAllWalletModules*/\n      ctx[3]) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*modalData, showingAllWalletModules*/\n          9) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_1$2(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(ul, t1);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*showingAllWalletModules*/\n      ctx[3]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*showingAllWalletModules*/\n          8) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block$4(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(ul, null);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n\n      for (var _i10 = 0; _i10 < each_value_1.length; _i10 += 1) {\n        transition_in(each_blocks[_i10]);\n      }\n\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      for (var _i11 = 0; _i11 < each_blocks.length; _i11 += 1) {\n        transition_out(each_blocks[_i11]);\n      }\n\n      transition_out(if_block0);\n      transition_out(if_block1);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(ul);\n\n      for (var _i12 = 0; _i12 < each_blocks.length; _i12 += 1) {\n        each_blocks[_i12].d();\n      }\n\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n    }\n  };\n}\n\nfunction instance$6($$self, $$props, $$invalidate) {\n  var modalData = $$props.modalData;\n  var handleWalletSelect = $$props.handleWalletSelect;\n  var loadingWallet = $$props.loadingWallet;\n  var _$$props$showingAllWa = $$props.showingAllWalletModules,\n      showingAllWalletModules = _$$props$showingAllWa === void 0 ? false : _$$props$showingAllWa;\n  var showAllWallets = $$props.showAllWallets;\n  var selectedWallet;\n  var unsubscribe = wallet.subscribe(function (wallet) {\n    return $$invalidate(5, selectedWallet = wallet);\n  });\n  onDestroy(function () {\n    return unsubscribe();\n  });\n\n  var func = function func(wallet) {\n    return handleWalletSelect(wallet);\n  };\n\n  var func_1 = function func_1(wallet) {\n    return handleWalletSelect(wallet);\n  };\n\n  $$self.$set = function ($$props) {\n    if (\"modalData\" in $$props) $$invalidate(0, modalData = $$props.modalData);\n    if (\"handleWalletSelect\" in $$props) $$invalidate(1, handleWalletSelect = $$props.handleWalletSelect);\n    if (\"loadingWallet\" in $$props) $$invalidate(2, loadingWallet = $$props.loadingWallet);\n    if (\"showingAllWalletModules\" in $$props) $$invalidate(3, showingAllWalletModules = $$props.showingAllWalletModules);\n    if (\"showAllWallets\" in $$props) $$invalidate(4, showAllWallets = $$props.showAllWallets);\n  };\n\n  return [modalData, handleWalletSelect, loadingWallet, showingAllWalletModules, showAllWallets, selectedWallet, func, func_1];\n}\n\nvar Wallets = /*#__PURE__*/function (_SvelteComponent7) {\n  _inherits(Wallets, _SvelteComponent7);\n\n  var _super7 = _createSuper(Wallets);\n\n  function Wallets(options) {\n    var _this7;\n\n    _classCallCheck(this, Wallets);\n\n    _this7 = _super7.call(this);\n    if (!document.getElementById(\"svelte-q1527-style\")) add_css$6();\n    init(_assertThisInitialized(_this7), options, instance$6, create_fragment$6, safe_not_equal, {\n      modalData: 0,\n      handleWalletSelect: 1,\n      loadingWallet: 2,\n      showingAllWalletModules: 3,\n      showAllWallets: 4\n    });\n    return _this7;\n  }\n\n  return Wallets;\n}(SvelteComponent);\n/* src/elements/IconDisplay.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$7() {\n  var style = element(\"style\");\n  style.id = \"svelte-18zts4b-style\";\n  style.textContent = \"div.svelte-18zts4b{display:flex;align-items:center;border:none;margin:0;font-size:inherit;font-family:inherit;background:inherit;padding:0;width:18em;border-radius:40px;color:inherit}img.svelte-18zts4b{width:auto;height:3em}span.svelte-18zts4b{margin-left:0.66em;font-weight:bold;font-size:inherit;font-family:inherit;opacity:0.7;text-align:left}\";\n  append(document.head, style);\n} // (41:2) {:else}\n\n\nfunction create_else_block$2(ctx) {\n  var img;\n  var img_src_value;\n  return {\n    c: function c() {\n      img = element(\"img\");\n      if (img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) attr(img, \"src\", img_src_value);\n      attr(img, \"srcset\",\n      /*iconSrcSet*/\n      ctx[1]);\n      attr(img, \"alt\",\n      /*text*/\n      ctx[2]);\n      attr(img, \"class\", \"svelte-18zts4b\");\n    },\n    m: function m(target, anchor) {\n      insert(target, img, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*iconSrc*/\n      1 && img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) {\n        attr(img, \"src\", img_src_value);\n      }\n\n      if (dirty &\n      /*iconSrcSet*/\n      2) {\n        attr(img, \"srcset\",\n        /*iconSrcSet*/\n        ctx[1]);\n      }\n\n      if (dirty &\n      /*text*/\n      4) {\n        attr(img, \"alt\",\n        /*text*/\n        ctx[2]);\n      }\n    },\n    d: function d(detaching) {\n      if (detaching) detach(img);\n    }\n  };\n} // (39:2) {#if svg}\n\n\nfunction create_if_block$5(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*svg*/\n      ctx[3], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*svg*/\n      8) html_tag.p(\n      /*svg*/\n      ctx[3]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n}\n\nfunction create_fragment$7(ctx) {\n  var div;\n  var t0;\n  var span;\n  var t1;\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*svg*/\n    ctx[3]) return create_if_block$5;\n    return create_else_block$2;\n  }\n\n  var current_block_type = select_block_type(ctx);\n  var if_block = current_block_type(ctx);\n  return {\n    c: function c() {\n      div = element(\"div\");\n      if_block.c();\n      t0 = space();\n      span = element(\"span\");\n      t1 = text(\n      /*text*/\n      ctx[2]);\n      attr(span, \"class\", \"svelte-18zts4b\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-icon-display svelte-18zts4b\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      if_block.m(div, null);\n      append(div, t0);\n      append(div, span);\n      append(span, t1);\n    },\n    p: function p(ctx, _ref24) {\n      var _ref25 = _slicedToArray(_ref24, 1),\n          dirty = _ref25[0];\n\n      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {\n        if_block.p(ctx, dirty);\n      } else {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n\n        if (if_block) {\n          if_block.c();\n          if_block.m(div, t0);\n        }\n      }\n\n      if (dirty &\n      /*text*/\n      4) set_data(t1,\n      /*text*/\n      ctx[2]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      if_block.d();\n    }\n  };\n}\n\nfunction instance$7($$self, $$props, $$invalidate) {\n  var iconSrc = $$props.iconSrc;\n  var iconSrcSet = $$props.iconSrcSet;\n  var text = $$props.text;\n  var svg = $$props.svg;\n\n  $$self.$set = function ($$props) {\n    if (\"iconSrc\" in $$props) $$invalidate(0, iconSrc = $$props.iconSrc);\n    if (\"iconSrcSet\" in $$props) $$invalidate(1, iconSrcSet = $$props.iconSrcSet);\n    if (\"text\" in $$props) $$invalidate(2, text = $$props.text);\n    if (\"svg\" in $$props) $$invalidate(3, svg = $$props.svg);\n  };\n\n  return [iconSrc, iconSrcSet, text, svg];\n}\n\nvar IconDisplay = /*#__PURE__*/function (_SvelteComponent8) {\n  _inherits(IconDisplay, _SvelteComponent8);\n\n  var _super8 = _createSuper(IconDisplay);\n\n  function IconDisplay(options) {\n    var _this8;\n\n    _classCallCheck(this, IconDisplay);\n\n    _this8 = _super8.call(this);\n    if (!document.getElementById(\"svelte-18zts4b-style\")) add_css$7();\n    init(_assertThisInitialized(_this8), options, instance$7, create_fragment$7, safe_not_equal, {\n      iconSrc: 0,\n      iconSrcSet: 1,\n      text: 2,\n      svg: 3\n    });\n    return _this8;\n  }\n\n  return IconDisplay;\n}(SvelteComponent);\n/* src/components/SelectedWallet.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$8() {\n  var style = element(\"style\");\n  style.id = \"svelte-mi6ahc-style\";\n  style.textContent = \"section.svelte-mi6ahc{color:inherit;font-size:inherit;font-family:inherit;display:block}footer.svelte-mi6ahc{display:flex;font-size:inherit;font-family:inherit;justify-content:space-between}\";\n  append(document.head, style);\n} // (33:2) {#if installMessage}\n\n\nfunction create_if_block$6(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*installMessage*/\n      ctx[2], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*installMessage*/\n      4) html_tag.p(\n      /*installMessage*/\n      ctx[2]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n} // (42:6) <Button>\n\n\nfunction create_default_slot_1(ctx) {\n  var t0;\n  var t1_value =\n  /*selectedWalletModule*/\n  ctx[0].name + \"\";\n  var t1;\n  return {\n    c: function c() {\n      t0 = text(\"Open or install \");\n      t1 = text(t1_value);\n    },\n    m: function m(target, anchor) {\n      insert(target, t0, anchor);\n      insert(target, t1, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*selectedWalletModule*/\n      1 && t1_value !== (t1_value =\n      /*selectedWalletModule*/\n      ctx[0].name + \"\")) set_data(t1, t1_value);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t0);\n      if (detaching) detach(t1);\n    }\n  };\n} // (44:4) <Button onclick={onBack}>\n\n\nfunction create_default_slot$1(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Back\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n}\n\nfunction create_fragment$8(ctx) {\n  var section;\n  var icondisplay;\n  var t0;\n  var t1;\n  var footer;\n  var a;\n  var button0;\n  var a_href_value;\n  var t2;\n  var button1;\n  var section_intro;\n  var current;\n  icondisplay = new IconDisplay({\n    props: {\n      iconSrc:\n      /*selectedWalletModule*/\n      ctx[0].iconSrc,\n      iconSrcSet:\n      /*selectedWalletModule*/\n      ctx[0].iconSrcSet,\n      svg:\n      /*selectedWalletModule*/\n      ctx[0].svg,\n      text:\n      /*selectedWalletModule*/\n      ctx[0].name\n    }\n  });\n  var if_block =\n  /*installMessage*/\n  ctx[2] && create_if_block$6(ctx);\n  button0 = new Button({\n    props: {\n      $$slots: {\n        \"default\": [create_default_slot_1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  button1 = new Button({\n    props: {\n      onclick:\n      /*onBack*/\n      ctx[1],\n      $$slots: {\n        \"default\": [create_default_slot$1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      section = element(\"section\");\n      create_component(icondisplay.$$.fragment);\n      t0 = space();\n      if (if_block) if_block.c();\n      t1 = space();\n      footer = element(\"footer\");\n      a = element(\"a\");\n      create_component(button0.$$.fragment);\n      t2 = space();\n      create_component(button1.$$.fragment);\n      attr(a, \"href\", a_href_value =\n      /*selectedWalletModule*/\n      ctx[0].link);\n      attr(a, \"rel\", \"noreferrer noopener\");\n      attr(a, \"target\", \"_blank\");\n      attr(footer, \"class\", \"bn-onboard-custom bn-onboard-modal-selected-wallet-footer svelte-mi6ahc\");\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-modal-selected-wallet svelte-mi6ahc\");\n    },\n    m: function m(target, anchor) {\n      insert(target, section, anchor);\n      mount_component(icondisplay, section, null);\n      append(section, t0);\n      if (if_block) if_block.m(section, null);\n      append(section, t1);\n      append(section, footer);\n      append(footer, a);\n      mount_component(button0, a, null);\n      append(footer, t2);\n      mount_component(button1, footer, null);\n      current = true;\n    },\n    p: function p(ctx, _ref26) {\n      var _ref27 = _slicedToArray(_ref26, 1),\n          dirty = _ref27[0];\n\n      var icondisplay_changes = {};\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.iconSrc =\n      /*selectedWalletModule*/\n      ctx[0].iconSrc;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.iconSrcSet =\n      /*selectedWalletModule*/\n      ctx[0].iconSrcSet;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.svg =\n      /*selectedWalletModule*/\n      ctx[0].svg;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.text =\n      /*selectedWalletModule*/\n      ctx[0].name;\n      icondisplay.$set(icondisplay_changes);\n\n      if (\n      /*installMessage*/\n      ctx[2]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$6(ctx);\n          if_block.c();\n          if_block.m(section, t1);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n\n      var button0_changes = {};\n\n      if (dirty &\n      /*$$scope, selectedWalletModule*/\n      9) {\n        button0_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button0.$set(button0_changes);\n\n      if (!current || dirty &\n      /*selectedWalletModule*/\n      1 && a_href_value !== (a_href_value =\n      /*selectedWalletModule*/\n      ctx[0].link)) {\n        attr(a, \"href\", a_href_value);\n      }\n\n      var button1_changes = {};\n      if (dirty &\n      /*onBack*/\n      2) button1_changes.onclick =\n      /*onBack*/\n      ctx[1];\n\n      if (dirty &\n      /*$$scope*/\n      8) {\n        button1_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button1.$set(button1_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(icondisplay.$$.fragment, local);\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n\n      if (!section_intro) {\n        add_render_callback(function () {\n          section_intro = create_in_transition(section, fade, {});\n          section_intro.start();\n        });\n      }\n\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(icondisplay.$$.fragment, local);\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(section);\n      destroy_component(icondisplay);\n      if (if_block) if_block.d();\n      destroy_component(button0);\n      destroy_component(button1);\n    }\n  };\n}\n\nfunction instance$8($$self, $$props, $$invalidate) {\n  var selectedWalletModule = $$props.selectedWalletModule;\n  var onBack = $$props.onBack;\n  var installMessage = $$props.installMessage;\n\n  $$self.$set = function ($$props) {\n    if (\"selectedWalletModule\" in $$props) $$invalidate(0, selectedWalletModule = $$props.selectedWalletModule);\n    if (\"onBack\" in $$props) $$invalidate(1, onBack = $$props.onBack);\n    if (\"installMessage\" in $$props) $$invalidate(2, installMessage = $$props.installMessage);\n  };\n\n  return [selectedWalletModule, onBack, installMessage];\n}\n\nvar SelectedWallet = /*#__PURE__*/function (_SvelteComponent9) {\n  _inherits(SelectedWallet, _SvelteComponent9);\n\n  var _super9 = _createSuper(SelectedWallet);\n\n  function SelectedWallet(options) {\n    var _this9;\n\n    _classCallCheck(this, SelectedWallet);\n\n    _this9 = _super9.call(this);\n    if (!document.getElementById(\"svelte-mi6ahc-style\")) add_css$8();\n    init(_assertThisInitialized(_this9), options, instance$8, create_fragment$8, safe_not_equal, {\n      selectedWalletModule: 0,\n      onBack: 1,\n      installMessage: 2\n    });\n    return _this9;\n  }\n\n  return SelectedWallet;\n}(SvelteComponent);\n\nvar walletIcon = \"\\n<svg\\nheight=\\\"18\\\"\\nviewBox=\\\"0 0 19 18\\\"\\nwidth=\\\"19\\\"\\nxmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<g fill=\\\"currentColor\\\" fill-rule=\\\"evenodd\\\">\\n\\t<path\\n\\t\\td=\\\"m15.7721618.00006623h-13.27469839c-.86762065\\n\\t\\t0-1.48592681.3078086-1.89741046.76113193-.40615823.44745064-.60839063\\n\\t\\t1.04661988-.59978974\\n\\t\\t1.64464107.00029187.005124.00040335.01025653.00033423.01538822v3.66899811c.06682404-.11685776.14162507-.22938827.22533894-.33628895.36778845-.46959466.90812952-.82116145\\n\\t\\t1.61866132-.95623339v-.59093422c0-.55214353.17649657-1.05790163.47278173-1.43388645.29630745-.37596275.72292065-.62513272\\n\\t\\t1.19969088-.62513272h11.23546239c.4765474 0 .9032497.24850764\\n\\t\\t1.199624.62424961.2963743.37574196.4728709.88161045.4728709\\n\\t\\t1.43476956v.4652895c.5235626-.11047728.9266682-.35445897\\n\\t\\t1.2246022-.6733727.4116397-.44060653.6210469-1.03392515.6210469-1.63015804s-.2094072-1.18955151-.6210469-1.63018011c-.4116396-.44060653-1.0238627-.73834765-1.877468-.73834765z\\\" />\\n\\t<path\\n\\t\\td=\\\"m14.6096047 2.57151734h-11.21914267c-.32073002\\n\\t\\t0-.6185428.16561433-.84722564.45769739s-.37782286.70763901-.37782286\\n\\t\\t1.16808814v.53953924c.06265527-.0036172.12640078-.00570319.19125878-.00616921.00518482-.00032924.01037961-.00047727.01557482-.00044383h.01326084\\n\\t\\t13.24215593c.0706652 0\\n\\t\\t.1395281-.00228571.2069226-.00630235v-.52671262c0-.46164746-.1491623-.87711464-.3777561-1.16884264-.2286161-.29175019-.5263622-.45694289-.8473147-.45694289z\\\" />\\n\\t<path\\n\\t\\td=\\\"m18.2706767\\n\\t\\t3.92481203c-.0857195.13278047-.1837832.25906993-.2945478.376829-.495466.52680184-1.2439236.87400468-2.2045296.87400468h-13.26144765c-.93286471\\n\\t\\t0-1.53628777.33766369-1.93268731.8403655s-.57746434\\n\\t\\t1.18877443-.57746434\\n\\t\\t1.87212785v.41252951c.13725808.14817467.29229732.20450824.50016754.23211693.21170276.02811305.46814809.01403459.74212947.02170977h5.25979191c.94146564\\n\\t\\t0 1.67588548.36084271 2.15878435.90341155.48289887.54259078.7188669\\n\\t\\t1.25649138.7188669 1.96738768s-.23596803 1.4247969-.7188669\\n\\t\\t1.9673877c-.48289887.5425689-1.21731871.9033896-2.15878435.9033896h-5.25979191c-.25038458\\n\\t\\t0-.55749953-.0171046-.84908381-.0866198-.13520812-.0322576-.27003744-.0756114-.3932132-.1380653v1.5302318c0\\n\\t\\t1.3201295 1.09561358 2.3983815 2.43697706\\n\\t\\t2.3983815h13.39672254c1.3413635 0 2.4369771-1.078252\\n\\t\\t2.4369771-2.3983815z\\\" />\\n\\t<path\\n\\t\\td=\\\"m0\\n\\t\\t8.79699248c.14260628.06959022.29864665.11050376.44557501.1299645.2753208.03649163.54484912.01335327.79368049.02057717.002302.00003506.00460441.00003506.00690641\\n\\t\\t0h5.25640383c.82827939 0 1.4220972.30156492\\n\\t\\t1.8240727.75248941.40199777.45094634.60569239 1.06221954.60569239\\n\\t\\t1.67601014 0 .6137467-.20369462 1.2250637-.60569239\\n\\t\\t1.6759882-.4019755.4509463-.99579331.7524894-1.8240727.7524894h-5.25640383c-.22831264\\n\\t\\t0-.50846792-.0188259-.74493458-.075238-.23646666-.0563245-.41416197-.1517676-.48734767-.2599728-.00440013-.0047203-.00900883-.0092487-.01387966-.0135722v-4.65860448zm6.42601595\\n\\t\\t1.42288912c-.62979799 0-1.14873693.5024111-1.14873693 1.1218933 0\\n\\t\\t.6211677.51893894 1.128745 1.14873693 1.128745.62984256 0\\n\\t\\t1.14178597-.5082122 1.14178597-1.128745\\n\\t\\t0-.6188692-.51194341-1.1218933-1.14178597-1.1218933z\\\" />\\n</g>\\n</svg>\\n\\t\";\n/* src/views/WalletSelect.svelte generated by Svelte v3.24.0 */\n\nfunction add_css$9() {\n  var style = element(\"style\");\n  style.id = \"svelte-rj3fpa-style\";\n  style.textContent = \"p.svelte-rj3fpa.svelte-rj3fpa{font-size:0.889em;margin:1.6em 0 0 0;font-family:inherit}div.svelte-rj3fpa.svelte-rj3fpa{display:flex;font-size:inherit;font-family:inherit;justify-content:space-between}div.svelte-rj3fpa span.svelte-rj3fpa{color:#4a90e2;font-size:inherit;font-family:inherit;margin-top:0.66em;cursor:pointer}\";\n  append(document.head, style);\n} // (180:0) {#if modalData}\n\n\nfunction create_if_block$7(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeModal:\n      /*func_2*/\n      ctx[15],\n      $$slots: {\n        \"default\": [create_default_slot$2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modal_changes = {};\n\n      if (dirty &\n      /*$$scope, modalData, showWalletDefinition, loadingWallet, showingAllWalletModules, selectedWalletModule, walletAlreadyInstalled, installMessage*/\n      33554559) {\n        modal_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      modal.$set(modal_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (210:4) {:else}\n\n\nfunction create_else_block$3(ctx) {\n  var selectedwallet;\n  var current;\n  selectedwallet = new SelectedWallet({\n    props: {\n      selectedWalletModule:\n      /*selectedWalletModule*/\n      ctx[4],\n      onBack:\n      /*func_1*/\n      ctx[14],\n      installMessage:\n      /*installMessage*/\n      ctx[3]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(selectedwallet.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(selectedwallet, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var selectedwallet_changes = {};\n      if (dirty &\n      /*selectedWalletModule*/\n      16) selectedwallet_changes.selectedWalletModule =\n      /*selectedWalletModule*/\n      ctx[4];\n      if (dirty &\n      /*selectedWalletModule, walletAlreadyInstalled*/\n      20) selectedwallet_changes.onBack =\n      /*func_1*/\n      ctx[14];\n      if (dirty &\n      /*installMessage*/\n      8) selectedwallet_changes.installMessage =\n      /*installMessage*/\n      ctx[3];\n      selectedwallet.$set(selectedwallet_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(selectedwallet.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(selectedwallet.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(selectedwallet, detaching);\n    }\n  };\n} // (183:4) {#if !selectedWalletModule}\n\n\nfunction create_if_block_1$3(ctx) {\n  var _p;\n\n  var raw_value =\n  /*modalData*/\n  ctx[0].description + \"\";\n  var t0;\n  var wallets_1;\n  var t1;\n  var div;\n  var span;\n  var t3;\n  var t4;\n  var if_block1_anchor;\n  var current;\n  var mounted;\n  var dispose;\n  wallets_1 = new Wallets({\n    props: {\n      modalData:\n      /*modalData*/\n      ctx[0],\n      handleWalletSelect:\n      /*handleWalletSelect*/\n      ctx[9],\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[5],\n      showingAllWalletModules:\n      /*showingAllWalletModules*/\n      ctx[6],\n      showAllWallets:\n      /*showAllWallets*/\n      ctx[8]\n    }\n  });\n  var if_block0 =\n  /*mobileDevice*/\n  ctx[7] && create_if_block_3(ctx);\n  var if_block1 =\n  /*showWalletDefinition*/\n  ctx[1] && create_if_block_2$1(ctx);\n  return {\n    c: function c() {\n      _p = element(\"p\");\n      t0 = space();\n      create_component(wallets_1.$$.fragment);\n      t1 = space();\n      div = element(\"div\");\n      span = element(\"span\");\n      span.textContent = \"What is a wallet?\";\n      t3 = space();\n      if (if_block0) if_block0.c();\n      t4 = space();\n      if (if_block1) if_block1.c();\n      if_block1_anchor = empty();\n      attr(_p, \"class\", \"bn-onboard-custom bn-onboard-select-description svelte-rj3fpa\");\n      attr(span, \"class\", \"bn-onboard-custom bn-onboard-select-wallet-info svelte-rj3fpa\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-select-info-container svelte-rj3fpa\");\n    },\n    m: function m(target, anchor) {\n      insert(target, _p, anchor);\n      _p.innerHTML = raw_value;\n      insert(target, t0, anchor);\n      mount_component(wallets_1, target, anchor);\n      insert(target, t1, anchor);\n      insert(target, div, anchor);\n      append(div, span);\n      append(div, t3);\n      if (if_block0) if_block0.m(div, null);\n      insert(target, t4, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(span, \"click\",\n        /*click_handler*/\n        ctx[12]);\n        mounted = true;\n      }\n    },\n    p: function p(ctx, dirty) {\n      if ((!current || dirty &\n      /*modalData*/\n      1) && raw_value !== (raw_value =\n      /*modalData*/\n      ctx[0].description + \"\")) _p.innerHTML = raw_value;\n      var wallets_1_changes = {};\n      if (dirty &\n      /*modalData*/\n      1) wallets_1_changes.modalData =\n      /*modalData*/\n      ctx[0];\n      if (dirty &\n      /*loadingWallet*/\n      32) wallets_1_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[5];\n      if (dirty &\n      /*showingAllWalletModules*/\n      64) wallets_1_changes.showingAllWalletModules =\n      /*showingAllWalletModules*/\n      ctx[6];\n      wallets_1.$set(wallets_1_changes);\n      if (\n      /*mobileDevice*/\n      ctx[7]) if_block0.p(ctx, dirty);\n\n      if (\n      /*showWalletDefinition*/\n      ctx[1]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*showWalletDefinition*/\n          2) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block_2$1(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(wallets_1.$$.fragment, local);\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(wallets_1.$$.fragment, local);\n      transition_out(if_block0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(_p);\n      if (detaching) detach(t0);\n      destroy_component(wallets_1, detaching);\n      if (detaching) detach(t1);\n      if (detaching) detach(div);\n      if (if_block0) if_block0.d();\n      if (detaching) detach(t4);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(if_block1_anchor);\n      mounted = false;\n      dispose();\n    }\n  };\n} // (199:8) {#if mobileDevice}\n\n\nfunction create_if_block_3(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      onclick:\n      /*func*/\n      ctx[13],\n      $$slots: {\n        \"default\": [create_default_slot_1$1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n\n      if (dirty &\n      /*$$scope*/\n      33554432) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (200:10) <Button onclick={() => finish({ completed: false })}>\n\n\nfunction create_default_slot_1$1(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Dismiss\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (203:6) {#if showWalletDefinition}\n\n\nfunction create_if_block_2$1(ctx) {\n  var _p2;\n\n  var raw_value =\n  /*modalData*/\n  ctx[0].explanation + \"\";\n  var p_intro;\n  return {\n    c: function c() {\n      _p2 = element(\"p\");\n      attr(_p2, \"class\", \"bn-onboard-custom bn-onboard-select-wallet-definition svelte-rj3fpa\");\n    },\n    m: function m(target, anchor) {\n      insert(target, _p2, anchor);\n      _p2.innerHTML = raw_value;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*modalData*/\n      1 && raw_value !== (raw_value =\n      /*modalData*/\n      ctx[0].explanation + \"\")) _p2.innerHTML = raw_value;\n    },\n    i: function i(local) {\n      if (!p_intro) {\n        add_render_callback(function () {\n          p_intro = create_in_transition(_p2, fade, {});\n          p_intro.start();\n        });\n      }\n    },\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(_p2);\n    }\n  };\n} // (181:2) <Modal closeModal={() => finish({ completed: false })}>\n\n\nfunction create_default_slot$2(ctx) {\n  var modalheader;\n  var t;\n  var current_block_type_index;\n  var if_block;\n  var if_block_anchor;\n  var current;\n  modalheader = new ModalHeader({\n    props: {\n      icon: walletIcon,\n      heading:\n      /*modalData*/\n      ctx[0].heading\n    }\n  });\n  var if_block_creators = [create_if_block_1$3, create_else_block$3];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (!\n    /*selectedWalletModule*/\n    ctx[4]) return 0;\n    return 1;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  return {\n    c: function c() {\n      create_component(modalheader.$$.fragment);\n      t = space();\n      if_block.c();\n      if_block_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      mount_component(modalheader, target, anchor);\n      insert(target, t, anchor);\n      if_blocks[current_block_type_index].m(target, anchor);\n      insert(target, if_block_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modalheader_changes = {};\n      if (dirty &\n      /*modalData*/\n      1) modalheader_changes.heading =\n      /*modalData*/\n      ctx[0].heading;\n      modalheader.$set(modalheader_changes);\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block = if_blocks[current_block_type_index];\n\n        if (!if_block) {\n          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block.c();\n        }\n\n        transition_in(if_block, 1);\n        if_block.m(if_block_anchor.parentNode, if_block_anchor);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modalheader.$$.fragment, local);\n      transition_in(if_block);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modalheader.$$.fragment, local);\n      transition_out(if_block);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modalheader, detaching);\n      if (detaching) detach(t);\n      if_blocks[current_block_type_index].d(detaching);\n      if (detaching) detach(if_block_anchor);\n    }\n  };\n}\n\nfunction create_fragment$9(ctx) {\n  var if_block_anchor;\n  var current;\n  var if_block =\n  /*modalData*/\n  ctx[0] && create_if_block$7(ctx);\n  return {\n    c: function c() {\n      if (if_block) if_block.c();\n      if_block_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block) if_block.m(target, anchor);\n      insert(target, if_block_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, _ref28) {\n      var _ref29 = _slicedToArray(_ref28, 1),\n          dirty = _ref29[0];\n\n      if (\n      /*modalData*/\n      ctx[0]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n\n          if (dirty &\n          /*modalData*/\n          1) {\n            transition_in(if_block, 1);\n          }\n        } else {\n          if_block = create_if_block$7(ctx);\n          if_block.c();\n          transition_in(if_block, 1);\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      } else if (if_block) {\n        group_outros();\n        transition_out(if_block, 1, 1, function () {\n          if_block = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block) if_block.d(detaching);\n      if (detaching) detach(if_block_anchor);\n    }\n  };\n}\n\nfunction lockScroll() {\n  window.scrollTo(0, 0);\n}\n\nfunction instance$9($$self, $$props, $$invalidate) {\n  var _$$props$module = $$props.module,\n      module = _$$props$module === void 0 ? {\n    heading: \"\",\n    description: \"\",\n    wallets: []\n  } : _$$props$module;\n  var modalData;\n  var showWalletDefinition;\n  var walletAlreadyInstalled;\n  var installMessage;\n  var selectedWalletModule;\n\n  var _get_store_value2 = get_store_value(app),\n      mobileDevice = _get_store_value2.mobileDevice,\n      os = _get_store_value2.os;\n\n  var _module = module,\n      heading = _module.heading,\n      description = _module.description,\n      explanation = _module.explanation,\n      wallets = _module.wallets;\n  var primaryWallets;\n  var secondaryWallets;\n  var loadingWallet = undefined;\n  var showingAllWalletModules = false;\n\n  var showAllWallets = function showAllWallets() {\n    return $$invalidate(6, showingAllWalletModules = true);\n  };\n\n  var originalOverflowValue;\n  onMount(function () {\n    originalOverflowValue = window.document.body.style.overflow;\n    window.document.body.style.overflow = \"hidden\";\n    window.addEventListener(\"scroll\", lockScroll);\n  });\n  onDestroy(function () {\n    window.removeEventListener(\"scroll\", lockScroll);\n    window.document.body.style.overflow = originalOverflowValue;\n  });\n  renderWalletSelect();\n\n  function renderWalletSelect() {\n    return _renderWalletSelect.apply(this, arguments);\n  }\n\n  function _renderWalletSelect() {\n    _renderWalletSelect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n      var appState, deviceWallets, _module2;\n\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              appState = get_store_value(app);\n              _context3.next = 3;\n              return wallets;\n\n            case 3:\n              wallets = _context3.sent;\n              deviceWallets = wallets.filter(function (wallet) {\n                return wallet[mobileDevice ? \"mobile\" : \"desktop\"];\n              }).filter(function (wallet) {\n                var _wallet$osExclusions = wallet.osExclusions,\n                    osExclusions = _wallet$osExclusions === void 0 ? [] : _wallet$osExclusions;\n                return !osExclusions.includes(os.name);\n              });\n\n              if (deviceWallets.find(function (wallet) {\n                return wallet.preferred;\n              })) {\n                // if preferred wallets, then split in to preferred and not preferred\n                primaryWallets = deviceWallets.filter(function (wallet) {\n                  return wallet.preferred;\n                });\n                secondaryWallets = deviceWallets.filter(function (wallet) {\n                  return !wallet.preferred;\n                });\n              } else {\n                // otherwise make the first 4 wallets preferred\n                primaryWallets = deviceWallets.slice(0, 4);\n                secondaryWallets = deviceWallets.length > 4 ? deviceWallets.slice(4) : undefined;\n              }\n\n              if (!appState.autoSelectWallet) {\n                _context3.next = 12;\n                break;\n              }\n\n              _module2 = deviceWallets.find(function (m) {\n                return m.name === appState.autoSelectWallet;\n              });\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  autoSelectWallet: \"\"\n                });\n              });\n\n              if (!_module2) {\n                _context3.next = 12;\n                break;\n              }\n\n              handleWalletSelect(_module2, true);\n              return _context3.abrupt(\"return\");\n\n            case 12:\n              $$invalidate(0, modalData = {\n                heading: heading,\n                description: description,\n                explanation: explanation,\n                primaryWallets: primaryWallets,\n                secondaryWallets: secondaryWallets\n              });\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  walletSelectDisplayedUI: true\n                });\n              });\n\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _renderWalletSelect.apply(this, arguments);\n  }\n\n  function handleWalletSelect(_x4, _x5) {\n    return _handleWalletSelect.apply(this, arguments);\n  }\n\n  function _handleWalletSelect() {\n    _handleWalletSelect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(module, autoSelected) {\n      var currentWalletInterface, _get_store_value3, browser, os, _yield$module$wallet, provider, selectedWalletInterface, instance;\n\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              currentWalletInterface = get_store_value(walletInterface);\n              _get_store_value3 = get_store_value(app), browser = _get_store_value3.browser, os = _get_store_value3.os;\n\n              if (!(currentWalletInterface && currentWalletInterface.name === module.name)) {\n                _context4.next = 5;\n                break;\n              }\n\n              finish({\n                completed: true\n              });\n              return _context4.abrupt(\"return\");\n\n            case 5:\n              $$invalidate(5, loadingWallet = module.name);\n              _context4.next = 8;\n              return module.wallet({\n                getProviderName: getProviderName,\n                createLegacyProviderInterface: createLegacyProviderInterface,\n                createModernProviderInterface: createModernProviderInterface,\n                BigNumber: bignumber_js__WEBPACK_IMPORTED_MODULE_1___default.a,\n                getNetwork: getNetwork,\n                getAddress: getAddress,\n                getBalance: getBalance,\n                resetWalletState: resetWalletState,\n                networkName: networkName,\n                browser: browser,\n                os: os\n              });\n\n            case 8:\n              _yield$module$wallet = _context4.sent;\n              provider = _yield$module$wallet.provider;\n              selectedWalletInterface = _yield$module$wallet[\"interface\"];\n              instance = _yield$module$wallet.instance;\n              $$invalidate(5, loadingWallet = undefined); // if no interface then the user does not have the wallet they selected installed or available\n\n              if (selectedWalletInterface) {\n                _context4.next = 19;\n                break;\n              }\n\n              $$invalidate(4, selectedWalletModule = module);\n              $$invalidate(2, walletAlreadyInstalled = provider && getProviderName(provider));\n              $$invalidate(3, installMessage = module.installMessage && module.installMessage({\n                currentWallet: walletAlreadyInstalled,\n                selectedWallet: selectedWalletModule.name\n              })); // if it was autoSelected then we need to add modalData to show the modal\n\n              if (autoSelected) {\n                $$invalidate(0, modalData = {\n                  heading: heading,\n                  description: description,\n                  explanation: explanation,\n                  primaryWallets: primaryWallets,\n                  secondaryWallets: secondaryWallets\n                });\n                app.update(function (store) {\n                  return _objectSpread(_objectSpread({}, store), {}, {\n                    walletSelectDisplayedUI: true\n                  });\n                });\n              }\n\n              return _context4.abrupt(\"return\");\n\n            case 19:\n              walletInterface.update(function (currentInterface) {\n                if (currentInterface && currentInterface.disconnect) {\n                  currentInterface.disconnect();\n                }\n\n                return selectedWalletInterface;\n              });\n              wallet.set({\n                provider: provider,\n                instance: instance,\n                dashboard: selectedWalletInterface.dashboard,\n                name: module.name,\n                connect: selectedWalletInterface.connect,\n                type: module.type\n              });\n              finish({\n                completed: true\n              });\n\n            case 22:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _handleWalletSelect.apply(this, arguments);\n  }\n\n  function finish(options) {\n    $$invalidate(0, modalData = null);\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), {}, {\n        walletSelectInProgress: false,\n        walletSelectCompleted: options.completed\n      });\n    });\n  }\n\n  var click_handler = function click_handler() {\n    return $$invalidate(1, showWalletDefinition = !showWalletDefinition);\n  };\n\n  var func = function func() {\n    return finish({\n      completed: false\n    });\n  };\n\n  var func_1 = function func_1() {\n    $$invalidate(4, selectedWalletModule = null);\n    $$invalidate(2, walletAlreadyInstalled = null);\n  };\n\n  var func_2 = function func_2() {\n    return finish({\n      completed: false\n    });\n  };\n\n  $$self.$set = function ($$props) {\n    if (\"module\" in $$props) $$invalidate(11, module = $$props.module);\n  };\n\n  return [modalData, showWalletDefinition, walletAlreadyInstalled, installMessage, selectedWalletModule, loadingWallet, showingAllWalletModules, mobileDevice, showAllWallets, handleWalletSelect, finish, module, click_handler, func, func_1, func_2];\n}\n\nvar WalletSelect = /*#__PURE__*/function (_SvelteComponent10) {\n  _inherits(WalletSelect, _SvelteComponent10);\n\n  var _super10 = _createSuper(WalletSelect);\n\n  function WalletSelect(options) {\n    var _this10;\n\n    _classCallCheck(this, WalletSelect);\n\n    _this10 = _super10.call(this);\n    if (!document.getElementById(\"svelte-rj3fpa-style\")) add_css$9();\n    init(_assertThisInitialized(_this10), options, instance$9, create_fragment$9, safe_not_equal, {\n      module: 11\n    });\n    return _this10;\n  }\n\n  return WalletSelect;\n}(SvelteComponent);\n/* src/views/WalletCheck.svelte generated by Svelte v3.24.0 */\n\n\nfunction add_css$a() {\n  var style = element(\"style\");\n  style.id = \"svelte-zrvscw-style\";\n  style.textContent = \"p.svelte-zrvscw{font-size:0.889em;font-family:inherit;margin:1em 0}span.svelte-zrvscw{color:#e2504a;font-size:0.889em;font-family:inherit;display:block;margin-bottom:0.75em;padding:0.5em;border:1px solid #e2504a;border-radius:5px}div.svelte-zrvscw{display:flex;justify-content:center;align-items:center;min-height:2.5rem;position:relative}section.svelte-zrvscw{display:flex;justify-content:center;flex-direction:column;align-items:center;margin-bottom:1rem}\";\n  append(document.head, style);\n} // (239:0) {#if loadingModal}\n\n\nfunction create_if_block_6(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeable: false,\n      $$slots: {\n        \"default\": [create_default_slot_4]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (240:2) <Modal closeable={false}>\n\n\nfunction create_default_slot_4(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({\n    props: {\n      description: \"Checking wallet\"\n    }\n  });\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (245:0) {#if activeModal}\n\n\nfunction create_if_block$8(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeModal:\n      /*func_1*/\n      ctx[10],\n      $$slots: {\n        \"default\": [create_default_slot$3]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modal_changes = {};\n\n      if (dirty &\n      /*$$scope, loading, activeModal, errorMsg, $app*/\n      16777239) {\n        modal_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      modal.$set(modal_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (251:4) {#if errorMsg}\n\n\nfunction create_if_block_5(ctx) {\n  var span;\n  var t;\n  var span_intro;\n  return {\n    c: function c() {\n      span = element(\"span\");\n      t = text(\n      /*errorMsg*/\n      ctx[1]);\n      attr(span, \"class\", \"bn-onboard-custom bn-onboard-prepare-error svelte-zrvscw\");\n      toggle_class(span, \"bn-onboard-dark-mode-background\",\n      /*$app*/\n      ctx[4].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, span, anchor);\n      append(span, t);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*errorMsg*/\n      2) set_data(t,\n      /*errorMsg*/\n      ctx[1]);\n\n      if (dirty &\n      /*$app*/\n      16) {\n        toggle_class(span, \"bn-onboard-dark-mode-background\",\n        /*$app*/\n        ctx[4].darkMode);\n      }\n    },\n    i: function i(local) {\n      if (!span_intro) {\n        add_render_callback(function () {\n          span_intro = create_in_transition(span, fade, {});\n          span_intro.start();\n        });\n      }\n    },\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n} // (260:4) {#if activeModal.html}\n\n\nfunction create_if_block_4(ctx) {\n  var section;\n  var raw_value =\n  /*activeModal*/\n  ctx[0].html + \"\";\n  return {\n    c: function c() {\n      section = element(\"section\");\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-wallet-check-section svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      insert(target, section, anchor);\n      section.innerHTML = raw_value;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*activeModal*/\n      1 && raw_value !== (raw_value =\n      /*activeModal*/\n      ctx[0].html + \"\")) section.innerHTML = raw_value;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(section);\n    }\n  };\n} // (267:6) {#if activeModal.button}\n\n\nfunction create_if_block_3$1(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      position: \"left\",\n      onclick:\n      /*activeModal*/\n      ctx[0].button.onclick,\n      $$slots: {\n        \"default\": [create_default_slot_3]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) button_changes.onclick =\n      /*activeModal*/\n      ctx[0].button.onclick;\n\n      if (dirty &\n      /*$$scope, activeModal*/\n      16777217) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (268:8) <Button position=\"left\" onclick={activeModal.button.onclick}>\n\n\nfunction create_default_slot_3(ctx) {\n  var t_value =\n  /*activeModal*/\n  ctx[0].button.text + \"\";\n  var t;\n  return {\n    c: function c() {\n      t = text(t_value);\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*activeModal*/\n      1 && t_value !== (t_value =\n      /*activeModal*/\n      ctx[0].button.text + \"\")) set_data(t, t_value);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (276:6) {:else}\n\n\nfunction create_else_block$4(ctx) {\n  var div;\n  return {\n    c: function c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div);\n    }\n  };\n} // (272:6) {#if errorMsg}\n\n\nfunction create_if_block_2$2(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      position: !\n      /*activeModal*/\n      ctx[0].button && \"left\",\n      onclick:\n      /*doAction*/\n      ctx[5],\n      $$slots: {\n        \"default\": [create_default_slot_2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) button_changes.position = !\n      /*activeModal*/\n      ctx[0].button && \"left\";\n\n      if (dirty &\n      /*$$scope*/\n      16777216) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (273:8) <Button position={!activeModal.button && 'left'} onclick={doAction}>\n\n\nfunction create_default_slot_2(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Try Again\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (279:6) {#if loading}\n\n\nfunction create_if_block_1$4(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({});\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (282:6) <Button position=\"right\" onclick={() => handleExit(false)}>\n\n\nfunction create_default_slot_1$2(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Dismiss\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (246:2) <Modal closeModal={() => handleExit()}>\n\n\nfunction create_default_slot$3(ctx) {\n  var modalheader;\n  var t0;\n\n  var _p3;\n\n  var raw_value =\n  /*activeModal*/\n  ctx[0].description + \"\";\n  var t1;\n  var t2;\n  var t3;\n  var div;\n  var t4;\n  var current_block_type_index;\n  var if_block3;\n  var t5;\n  var t6;\n  var button;\n  var current;\n  modalheader = new ModalHeader({\n    props: {\n      icon:\n      /*activeModal*/\n      ctx[0].icon,\n      heading:\n      /*activeModal*/\n      ctx[0].heading\n    }\n  });\n  var if_block0 =\n  /*errorMsg*/\n  ctx[1] && create_if_block_5(ctx);\n  var if_block1 =\n  /*activeModal*/\n  ctx[0].html && create_if_block_4(ctx);\n  var if_block2 =\n  /*activeModal*/\n  ctx[0].button && create_if_block_3$1(ctx);\n  var if_block_creators = [create_if_block_2$2, create_else_block$4];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*errorMsg*/\n    ctx[1]) return 0;\n    return 1;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  var if_block4 =\n  /*loading*/\n  ctx[2] && create_if_block_1$4();\n  button = new Button({\n    props: {\n      position: \"right\",\n      onclick:\n      /*func*/\n      ctx[9],\n      $$slots: {\n        \"default\": [create_default_slot_1$2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modalheader.$$.fragment);\n      t0 = space();\n      _p3 = element(\"p\");\n      t1 = space();\n      if (if_block0) if_block0.c();\n      t2 = space();\n      if (if_block1) if_block1.c();\n      t3 = space();\n      div = element(\"div\");\n      if (if_block2) if_block2.c();\n      t4 = space();\n      if_block3.c();\n      t5 = space();\n      if (if_block4) if_block4.c();\n      t6 = space();\n      create_component(button.$$.fragment);\n      attr(_p3, \"class\", \"bn-onboard-custom bn-onboard-prepare-description svelte-zrvscw\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-prepare-button-container svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      mount_component(modalheader, target, anchor);\n      insert(target, t0, anchor);\n      insert(target, _p3, anchor);\n      _p3.innerHTML = raw_value;\n      insert(target, t1, anchor);\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t2, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, t3, anchor);\n      insert(target, div, anchor);\n      if (if_block2) if_block2.m(div, null);\n      append(div, t4);\n      if_blocks[current_block_type_index].m(div, null);\n      append(div, t5);\n      if (if_block4) if_block4.m(div, null);\n      append(div, t6);\n      mount_component(button, div, null);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modalheader_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) modalheader_changes.icon =\n      /*activeModal*/\n      ctx[0].icon;\n      if (dirty &\n      /*activeModal*/\n      1) modalheader_changes.heading =\n      /*activeModal*/\n      ctx[0].heading;\n      modalheader.$set(modalheader_changes);\n      if ((!current || dirty &\n      /*activeModal*/\n      1) && raw_value !== (raw_value =\n      /*activeModal*/\n      ctx[0].description + \"\")) _p3.innerHTML = raw_value;\n\n      if (\n      /*errorMsg*/\n      ctx[1]) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*errorMsg*/\n          2) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_5(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t2.parentNode, t2);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0].html) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n        } else {\n          if_block1 = create_if_block_4(ctx);\n          if_block1.c();\n          if_block1.m(t3.parentNode, t3);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0].button) {\n        if (if_block2) {\n          if_block2.p(ctx, dirty);\n\n          if (dirty &\n          /*activeModal*/\n          1) {\n            transition_in(if_block2, 1);\n          }\n        } else {\n          if_block2 = create_if_block_3$1(ctx);\n          if_block2.c();\n          transition_in(if_block2, 1);\n          if_block2.m(div, t4);\n        }\n      } else if (if_block2) {\n        group_outros();\n        transition_out(if_block2, 1, 1, function () {\n          if_block2 = null;\n        });\n        check_outros();\n      }\n\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block3 = if_blocks[current_block_type_index];\n\n        if (!if_block3) {\n          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block3.c();\n        }\n\n        transition_in(if_block3, 1);\n        if_block3.m(div, t5);\n      }\n\n      if (\n      /*loading*/\n      ctx[2]) {\n        if (if_block4) {\n          if (dirty &\n          /*loading*/\n          4) {\n            transition_in(if_block4, 1);\n          }\n        } else {\n          if_block4 = create_if_block_1$4();\n          if_block4.c();\n          transition_in(if_block4, 1);\n          if_block4.m(div, t6);\n        }\n      } else if (if_block4) {\n        group_outros();\n        transition_out(if_block4, 1, 1, function () {\n          if_block4 = null;\n        });\n        check_outros();\n      }\n\n      var button_changes = {};\n\n      if (dirty &\n      /*$$scope*/\n      16777216) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modalheader.$$.fragment, local);\n      transition_in(if_block0);\n      transition_in(if_block2);\n      transition_in(if_block3);\n      transition_in(if_block4);\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modalheader.$$.fragment, local);\n      transition_out(if_block2);\n      transition_out(if_block3);\n      transition_out(if_block4);\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modalheader, detaching);\n      if (detaching) detach(t0);\n      if (detaching) detach(_p3);\n      if (detaching) detach(t1);\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t2);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(t3);\n      if (detaching) detach(div);\n      if (if_block2) if_block2.d();\n      if_blocks[current_block_type_index].d();\n      if (if_block4) if_block4.d();\n      destroy_component(button);\n    }\n  };\n}\n\nfunction create_fragment$a(ctx) {\n  var t;\n  var if_block1_anchor;\n  var current;\n  var if_block0 =\n  /*loadingModal*/\n  ctx[3] && create_if_block_6(ctx);\n  var if_block1 =\n  /*activeModal*/\n  ctx[0] && create_if_block$8(ctx);\n  return {\n    c: function c() {\n      if (if_block0) if_block0.c();\n      t = space();\n      if (if_block1) if_block1.c();\n      if_block1_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, _ref30) {\n      var _ref31 = _slicedToArray(_ref30, 1),\n          dirty = _ref31[0];\n\n      if (\n      /*loadingModal*/\n      ctx[3]) {\n        if (if_block0) {\n          if (dirty &\n          /*loadingModal*/\n          8) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_6(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t.parentNode, t);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*activeModal*/\n          1) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block$8(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      transition_out(if_block1);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(if_block1_anchor);\n    }\n  };\n}\n\nfunction lockScroll$1() {\n  window.scrollTo(0, 0);\n}\n\nfunction isCheckModal(val) {\n  return val.heading !== undefined;\n}\n\nfunction instance$a($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(4, $app = $$value);\n  });\n  var walletSelect = $$props.walletSelect;\n  var modules = $$props.modules;\n  var blocknative = getBlocknative();\n  var currentState;\n  var activeModal = undefined;\n  var currentModule = undefined;\n  var errorMsg;\n  var pollingInterval;\n  var checkingModule = false;\n  var actionResolved = undefined;\n  var loading = false;\n  var loadingModal = false;\n  var unsubscribe = walletInterface.subscribe(function (currentInterface) {\n    if (currentInterface === null) {\n      handleExit();\n      unsubscribe();\n    }\n  });\n  var originalOverflowValue;\n  var unsubscribeCurrentState = state.subscribe(function (store) {\n    return currentState = store;\n  });\n  onMount(function () {\n    originalOverflowValue = window.document.body.style.overflow;\n    window.document.body.style.overflow = \"hidden\";\n    window.addEventListener(\"scroll\", lockScroll$1);\n  });\n  onDestroy(function () {\n    unsubscribeCurrentState();\n    window.removeEventListener(\"scroll\", lockScroll$1);\n    window.document.body.style.overflow = originalOverflowValue;\n  });\n\n  function renderModule() {\n    return _renderModule.apply(this, arguments);\n  }\n\n  function _renderModule() {\n    _renderModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n      var checkModules, currentWallet;\n      return regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              $$invalidate(14, checkingModule = true);\n              checkModules = modules || get_store_value(app).checkModules;\n\n              if (!isPromise(checkModules)) {\n                _context7.next = 8;\n                break;\n              }\n\n              _context7.next = 5;\n              return checkModules;\n\n            case 5:\n              checkModules = _context7.sent;\n              checkModules.forEach(validateWalletCheckModule);\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  checkModules: checkModules\n                });\n              });\n\n            case 8:\n              currentWallet = get_store_value(wallet).name; // loop through and run each module to check if a modal needs to be shown\n\n              runModules(checkModules).then(function (result) {\n                // no result then user has passed all conditions\n                if (!result.modal) {\n                  blocknative && blocknative.event({\n                    categoryCode: \"onboard\",\n                    eventCode: \"onboardingCompleted\"\n                  });\n                  handleExit(true);\n                  return;\n                } // set that UI has been displayed, so that timeouts can be added for UI transitions\n\n\n                app.update(function (store) {\n                  return _objectSpread(_objectSpread({}, store), {}, {\n                    walletCheckDisplayedUI: true\n                  });\n                });\n                $$invalidate(0, activeModal = result.modal);\n                currentModule = result.module; // log the event code for this module\n\n                blocknative && blocknative.event({\n                  eventCode: activeModal.eventCode,\n                  categoryCode: \"onboard\"\n                }); // run any actions that module require as part of this step\n\n                if (activeModal.action) {\n                  doAction();\n                } // poll to automatically to check if condition has been met\n\n\n                pollingInterval = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n                  var _result;\n\n                  return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                    while (1) {\n                      switch (_context6.prev = _context6.next) {\n                        case 0:\n                          if (!currentModule) {\n                            _context6.next = 5;\n                            break;\n                          }\n\n                          _context6.next = 3;\n                          return invalidState(currentModule, get_store_value(state));\n\n                        case 3:\n                          _result = _context6.sent;\n\n                          if (!_result && actionResolved !== false) {\n                            resetState(); // delayed for animations\n\n                            setTimeout(function () {\n                              $$invalidate(14, checkingModule = false);\n                            }, 250);\n                          } else {\n                            $$invalidate(0, activeModal = _result && _result.modal ? _result.modal : activeModal);\n                          }\n\n                        case 5:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }\n                  }, _callee6);\n                })), 100);\n              });\n\n            case 10:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n    return _renderModule.apply(this, arguments);\n  }\n\n  function doAction() {\n    actionResolved = false;\n    $$invalidate(2, loading = true);\n    activeModal && activeModal.action && activeModal.action().then(function () {\n      actionResolved = true;\n      $$invalidate(2, loading = false);\n    })[\"catch\"](function (err) {\n      $$invalidate(1, errorMsg = err.message);\n      $$invalidate(2, loading = false);\n    });\n  }\n\n  function handleExit(completed) {\n    resetState();\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), {}, {\n        walletCheckInProgress: false,\n        walletCheckCompleted: completed ? completed : false,\n        accountSelectInProgress: false\n      });\n    });\n  }\n\n  function resetState() {\n    clearInterval(pollingInterval);\n    $$invalidate(1, errorMsg = \"\");\n    actionResolved = undefined;\n    $$invalidate(0, activeModal = undefined);\n    currentModule = undefined;\n  }\n\n  function runModules(modules) {\n    return new Promise( /*#__PURE__*/function () {\n      var _ref32 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve) {\n        var _iterator, _step, module, result;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(modules);\n                _context5.prev = 1;\n\n                _iterator.s();\n\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                module = _step.value;\n                _context5.next = 7;\n                return invalidState(module, currentState);\n\n              case 7:\n                result = _context5.sent;\n\n                if (!result) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", resolve(result));\n\n              case 10:\n                _context5.next = 3;\n                break;\n\n              case 12:\n                _context5.next = 17;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t0 = _context5[\"catch\"](1);\n\n                _iterator.e(_context5.t0);\n\n              case 17:\n                _context5.prev = 17;\n\n                _iterator.f();\n\n                return _context5.finish(17);\n\n              case 20:\n                return _context5.abrupt(\"return\", resolve({\n                  modal: undefined,\n                  module: undefined\n                }));\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[1, 14, 17, 20]]);\n      }));\n\n      return function (_x6) {\n        return _ref32.apply(this, arguments);\n      };\n    }());\n  }\n\n  function invalidState(_x7, _x8) {\n    return _invalidState.apply(this, arguments);\n  }\n\n  function _invalidState() {\n    _invalidState = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(module, state) {\n      var result, modal;\n      return regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              result = module(_objectSpread(_objectSpread({}, state), {}, {\n                BigNumber: bignumber_js__WEBPACK_IMPORTED_MODULE_1___default.a,\n                walletSelect: walletSelect,\n                exit: handleExit,\n                wallet: get_store_value(wallet),\n                stateSyncStatus: stateSyncStatus,\n                stateStore: {\n                  address: address,\n                  network: network,\n                  balance: balance\n                }\n              }));\n\n              if (!result) {\n                _context8.next = 12;\n                break;\n              }\n\n              if (!isCheckModal(result)) {\n                _context8.next = 7;\n                break;\n              }\n\n              validateModal(result);\n              return _context8.abrupt(\"return\", {\n                module: module,\n                modal: result\n              });\n\n            case 7:\n              _context8.next = 9;\n              return new Promise(function (resolve) {\n                var completed = false;\n                result.then(function (res) {\n                  $$invalidate(3, loadingModal = false);\n                  completed = true;\n                  modal = res;\n                  resolve();\n                });\n                setTimeout(function () {\n                  if (!completed) {\n                    $$invalidate(3, loadingModal = true);\n                  }\n                }, 650);\n              });\n\n            case 9:\n              if (!modal) {\n                _context8.next = 12;\n                break;\n              }\n\n              validateModal(modal);\n              return _context8.abrupt(\"return\", {\n                module: module,\n                modal: modal\n              });\n\n            case 12:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _invalidState.apply(this, arguments);\n  }\n\n  var func = function func() {\n    return handleExit(false);\n  };\n\n  var func_1 = function func_1() {\n    return handleExit();\n  };\n\n  $$self.$set = function ($$props) {\n    if (\"walletSelect\" in $$props) $$invalidate(7, walletSelect = $$props.walletSelect);\n    if (\"modules\" in $$props) $$invalidate(8, modules = $$props.modules);\n  };\n\n  $$self.$$.update = function () {\n    if ($$self.$$.dirty &\n    /*activeModal, checkingModule*/\n    16385) {\n      // recheck modules if below conditions\n      if (!activeModal && !checkingModule) {\n        renderModule();\n      }\n    }\n  };\n\n  return [activeModal, errorMsg, loading, loadingModal, $app, doAction, handleExit, walletSelect, modules, func, func_1];\n}\n\nvar WalletCheck = /*#__PURE__*/function (_SvelteComponent11) {\n  _inherits(WalletCheck, _SvelteComponent11);\n\n  var _super11 = _createSuper(WalletCheck);\n\n  function WalletCheck(options) {\n    var _this11;\n\n    _classCallCheck(this, WalletCheck);\n\n    _this11 = _super11.call(this);\n    if (!document.getElementById(\"svelte-zrvscw-style\")) add_css$a();\n    init(_assertThisInitialized(_this11), options, instance$a, create_fragment$a, safe_not_equal, {\n      walletSelect: 7,\n      modules: 8\n    });\n    return _this11;\n  }\n\n  return WalletCheck;\n}(SvelteComponent);\n\nvar usbIcon = \"\\n\\t<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 512 512\\\" style=\\\"enable-background:new 0 0 512 512;\\\" xml:space=\\\"preserve\\\" width=\\\"18px\\\" height=\\\"18px\\\">\\n\\t<g>\\n\\t<g>\\n\\t<path fill=\\\"currentColor\\\" d=\\\"M314.468,157.197v103.942h31.553v2.312c0,9.888-4.815,19.205-12.881,24.924l-56.652,40.171V109.939h44.546L257.634,0\\n\\t\\tl-66.527,109.939h45.404V358.25l-56.652-40.171c-8.066-5.719-12.881-15.037-12.881-24.924v-8.489\\n\\t\\tc20.19-7.815,34.552-27.427,34.552-50.342c0-29.759-24.211-53.97-53.97-53.97c-29.76,0-53.97,24.211-53.97,53.97\\n\\t\\tc0,22.482,13.821,41.789,33.41,49.891v8.94c0,22.824,11.116,44.333,29.735,57.536l66.895,47.434\\n\\t\\tc4.255,3.016,7.593,7.04,9.809,11.615c-17.713,8.862-29.909,27.173-29.909,48.29c0,29.76,24.211,53.97,53.97,53.97\\n\\t\\tc29.759,0,53.97-24.211,53.97-53.97c0-23.078-14.564-42.81-34.981-50.511v-14.174c0-9.888,4.815-19.205,12.881-24.924\\n\\t\\tl66.895-47.434c18.619-13.202,29.735-34.711,29.735-57.536v-2.312h32.411V157.197H314.468z M147.56,248.316\\n\\t\\tc-7.716,0-13.992-6.277-13.992-13.992c0-7.716,6.276-13.992,13.992-13.992c7.716,0,13.992,6.276,13.992,13.992\\n\\t\\tC161.552,242.04,155.276,248.316,147.56,248.316z M257.499,472.022c-7.716,0-13.992-6.276-13.992-13.992\\n\\t\\tc0-7.716,6.277-13.992,13.992-13.992c7.716,0,13.992,6.276,13.992,13.992C271.491,465.746,265.215,472.022,257.499,472.022z\\n\\t\\tM378.432,221.161h-23.987v-23.987h23.987V221.161z\\\"/>\\n\\t</g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t</svg>\\t  \\n\";\nvar connectIcon = \"\\n\\t<svg height=\\\"14\\\" viewBox=\\\"0 0 18 14\\\" width=\\\"18\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t<g fill=\\\"currentColor\\\">\\n\\t\\t\\t<path d=\\\"m10.29375 4.05351563c0-.04921875 0-.09140625 0-.13007813 0-1.0546875 0-2.109375 0-3.1640625 0-.43945312.3480469-.76992188.7804688-.7453125.2003906.01054688.3585937.10546875.4992187.24609375.5800781.58359375 1.1566406 1.16367188 1.7367187 1.74023438 1.4695313 1.46953125 2.9390625 2.93906249 4.4050782 4.40859375.1335937.13359375.2425781.27421875.2707031.46757812.0351562.20742188-.0246094.421875-.1652344.58007813-.0246094.028125-.0492187.05273437-.0738281.08085937-2.0601563 2.06367188-4.1203125 4.1238281-6.1804688 6.1875-.2109375.2109375-.4570312.3023438-.7453125.2179688-.2707031-.0808594-.4464843-.2707032-.5132812-.5484375-.0140625-.0738282-.0175781-.1441407-.0140625-.2179688 0-1.0335937 0-2.0707031 0-3.1042969 0-.0386719 0-.08085935 0-.13359372h-5.06953125c-.49570313 0-.80507813-.309375-.80507813-.80859375 0-1.42382813 0-2.84414063 0-4.26796875 0-.49570313.30585938-.8015625.8015625-.8015625h4.93593748z\\\"/>\\n\\t\\t\\t<path d=\\\"m5.69882812 13.978125h-4.01132812c-.928125 0-1.6875-.8753906-1.6875-1.9511719v-10.06171872c0-1.07578125.75585938-1.95117188 1.6875-1.95117188h4.01132812c.34101563 0 .61523438.31992188.61523438.71015625 0 .39023438-.27421875.71015625-.61523438.71015625h-4.01132812c-.253125 0-.45703125.23554688-.45703125.52734375v10.06171875c0 .2917969.20390625.5273437.45703125.5273437h4.01132812c.34101563 0 .61523438.3199219.61523438.7101563s-.27773438.7171875-.61523438.7171875z\\\"/>\\n\\t\\t</g>\\n\\t</svg>\\n\";\nvar balanceIcon = \"\\n\\t<svg height=\\\"18\\\" viewBox=\\\"0 0 429 695\\\" width=\\\"18\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t<g fill=\\\"currentColor\\\" fill-rule=\\\"evenodd\\\">\\n\\t\\t\\t<path d=\\\"m0 394 213 126.228516 214-126.228516-214 301z\\\"/>\\n\\t\\t\\t<path d=\\\"m0 353.962264 213.5-353.962264 213.5 353.962264-213.5 126.037736z\\\"/>\\n\\t\\t</g>\\n\\t</svg>\\n\";\nvar msgStyles = \"\\n  display: block;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  color: inherit;\\n  margin-top: 0.5rem;\\n\";\n\nfunction accountSelect() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var heading = options.heading,\n      description = options.description,\n      icon = options.icon;\n  var completed = false;\n  var loadingAccounts = false;\n  var accountsAndBalances = [];\n\n  function checkModule(_x9) {\n    return _checkModule.apply(this, arguments);\n  }\n\n  function _checkModule() {\n    _checkModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(stateAndHelpers) {\n      var wallet, BigNumber, provider, type, _accounts, deleteWindowProperties, loadMoreAccounts, _accountSelect;\n\n      return regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              wallet = stateAndHelpers.wallet, BigNumber = stateAndHelpers.BigNumber;\n              provider = wallet.provider, type = wallet.type;\n\n              if (!(type === 'hardware' && !completed && !provider.isCustomPath())) {\n                _context10.next = 18;\n                break;\n              }\n\n              if (!(accountsAndBalances.length === 0)) {\n                _context10.next = 12;\n                break;\n              }\n\n              loadingAccounts = true;\n              _context10.next = 7;\n              return provider.enable();\n\n            case 7:\n              _accounts = _context10.sent;\n              _context10.next = 10;\n              return provider.getBalances(_accounts);\n\n            case 10:\n              accountsAndBalances = _context10.sent;\n              loadingAccounts = false;\n\n            case 12:\n              deleteWindowProperties = function deleteWindowProperties() {\n                delete window.accountSelect;\n                delete window.loadMoreAccounts;\n              };\n\n              loadMoreAccounts = /*#__PURE__*/function () {\n                var _ref34 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {\n                  return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                    while (1) {\n                      switch (_context9.prev = _context9.next) {\n                        case 0:\n                          loadingAccounts = true;\n                          _context9.next = 3;\n                          return provider.getMoreAccounts();\n\n                        case 3:\n                          accountsAndBalances = _context9.sent;\n                          loadingAccounts = false;\n\n                        case 5:\n                        case \"end\":\n                          return _context9.stop();\n                      }\n                    }\n                  }, _callee9);\n                }));\n\n                return function loadMoreAccounts() {\n                  return _ref34.apply(this, arguments);\n                };\n              }();\n\n              _accountSelect = function _accountSelect() {\n                var accountIndex = document.getElementById('account-select').selectedIndex;\n                provider.setPrimaryAccount(accountsAndBalances[accountIndex].address);\n              };\n\n              window.accountSelect = _accountSelect;\n              window.loadMoreAccounts = loadMoreAccounts;\n              return _context10.abrupt(\"return\", {\n                heading: heading || 'Select Account',\n                description: description || \"Please select which account you would like to use with this Dapp:\",\n                eventCode: 'accountSelect',\n                html: loadingAccounts ? \"<div class=\\\"bn-onboard-custom bn-onboard-loading\\\">\\n              <div class=\\\"bn-onboard-loading-first\\\"></div>\\n              <div class=\\\"bn-onboard-loading-second\\\"></div>\\n              <div class=\\\"bn-onboard-loading-third\\\"></div>\\n            </div>\\n            <span style=\\\"\".concat(msgStyles, \"\\\">Loading More Accounts...</span>\\n            \") : \"\\n          <div style=\\\"display: flex; align-items: center;\\\">\\n            <select id=\\\"account-select\\\" onchange=\\\"window.accountSelect();\\\" class=\\\"bn-onboard-custom bn-onboard-account-select>\\n              \".concat(accountsAndBalances.map(function (account) {\n                  return \"<option>\".concat(account.address, \" --- \").concat(account.balance != null ? new BigNumber(account.balance).div('1000000000000000000').toFixed(3) : '0', \" ETH</option>\");\n                }), \"\\n            </select>\\n            <button style=\\\"display: flex; align-items: center; text-align: center; height: 1.5rem; background: transparent; margin: 0 0.25rem; padding: 0 0.5rem; border-radius: 40px; cursor: pointer; color: inherit; border-color: inherit; border-width: 1px; border-style: solid;\\\" onclick=\\\"window.loadMoreAccounts()\\\">Load More</button>\\n          </div>\\n        \"),\n                button: {\n                  onclick: function onclick() {\n                    deleteWindowProperties();\n                    completed = true;\n                  },\n                  text: 'Done'\n                },\n                icon: icon || usbIcon\n              });\n\n            case 18:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n    return _checkModule.apply(this, arguments);\n  }\n\n  checkModule.reset = function () {\n    completed = false;\n    accountsAndBalances = [];\n    loadingAccounts = false;\n  };\n\n  return checkModule;\n}\n\nvar accounts = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': accountSelect\n});\nvar derivationPaths = {\n  Ledger: [{\n    path: \"m/44'/60'/0'\",\n    label: 'Ethereum'\n  }, {\n    path: \"m/44'/60'\",\n    label: 'Ethereum Ledger Live'\n  }],\n  Trezor: [{\n    path: \"m/44'/60'/0'/0\",\n    label: 'Ethereum'\n  }],\n  Lattice: [{\n    path: \"m/44'/60'/0'/0\",\n    label: 'Ethereum'\n  }]\n};\nvar styles = \"\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: center;\\n\";\nvar baseStyles = \"\\n  background: inherit;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  border-width: 1px;\\n  border-style: solid;\\n  border-color: inherit;\\n  border-radius: 40px;\\n  margin-top: 0.5rem;\\n  padding: 0.55em 1.4em;\\n  text-align: center;\\n  color: inherit;\\n  font-family: inherit;\\n  transition: background 150ms ease-in-out;\\n  line-height: 1.15;\\n\";\nvar buttonStyles = \"\\n  cursor: pointer;\\n\";\nvar selectedStyles = \"\\n  border: 1px solid #4a90e2;\\n\";\nvar errorStyles = \"\\n  border: 1px solid #e2504a;\\n\";\nvar msgStyles$1 = \"\\n  display: block;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  color: inherit;\\n  margin-top: 0.5rem;\\n\";\nvar errorMsgStyles = \"\\n  color: #e2504a;\\n\";\n\nfunction derivationPath() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var heading = options.heading,\n      description = options.description,\n      icon = options.icon;\n  var state = {\n    completed: false,\n    showCustomInput: false,\n    dPath: '',\n    loading: false,\n    error: ''\n  };\n\n  var customInputHtmlString = function customInputHtmlString(error) {\n    return \"\\n      <input \\n        id=\\\"custom-derivation-input\\\" \\n        style=\\\"\".concat(baseStyles + selectedStyles + (error ? errorStyles : ''), \"\\\" \\n        type=\\\"text\\\" \\n        value=\\\"\").concat(state.dPath, \"\\\"\\n        placeholder=\\\"custom derivation path\\\" \\n        onchange=\\\"window.handleCustomInput(this.value)\\\" />\\n      \");\n  };\n\n  function derivationSelectHtmlString(walletName) {\n    return \"\\n      <div id=\\\"derivation-select\\\" style=\\\"\".concat(styles, \"\\\">\\n        \").concat(derivationPaths[walletName].map(function (derivation) {\n      var path = derivation.path,\n          label = derivation.label;\n      return \"\\n              <button style=\\\"\".concat(baseStyles + buttonStyles + (state.dPath === path && !state.showCustomInput ? selectedStyles : ''), \"\\\" onclick=\\\"window.handleDerivationClick(this)\\\" data-path=\\\"\").concat(path, \"\\\">\\n                \").concat(label, \" - \").concat(path, \"\\n              </button>\\n            \");\n    }).join(' '), \"\\n        \").concat(state.showCustomInput ? customInputHtmlString(state.error) : \"<button style=\\\"\".concat(baseStyles + buttonStyles, \"\\\" onclick=\\\"window.handleDerivationClick(this)\\\" data-path=\\\"custom\\\">Custom Path</button>\"), \"\\n        \").concat(state.loading ? \"<div class=\\\"bn-onboard-custom bn-onboard-loading\\\" style=\\\"margin-top: 1rem;\\\">\\n                <div class=\\\"bn-onboard-loading-first\\\"></div>\\n                <div class=\\\"bn-onboard-loading-second\\\"></div>\\n                <div class=\\\"bn-onboard-loading-third\\\"></div>\\n              </div>\\n              <span style=\\\"\".concat(msgStyles$1, \"\\\">Loading Accounts...</span>\\n              \") : state.error ? \"<span style=\\\"\".concat(msgStyles$1 + errorMsgStyles, \"\\\">\").concat(state.error, \"</span>\") : '', \"\\n      </div>\\n    \");\n  }\n\n  function resetState() {\n    state.completed = false;\n    state.showCustomInput = false;\n    state.dPath = '';\n    state.loading = false;\n    state.error = '';\n  }\n\n  function checkModule(stateAndHelpers) {\n    var wallet = stateAndHelpers.wallet;\n\n    if (wallet && wallet.type === 'hardware' && !state.completed) {\n      var handleCustomInput = function handleCustomInput() {\n        var input = document.getElementById('custom-derivation-input');\n        state.dPath = input && input.value;\n        state.error = '';\n      };\n\n      var handleDerivationClick = function handleDerivationClick(button) {\n        var selectedPath = button.dataset.path;\n\n        if (selectedPath === 'custom') {\n          state.showCustomInput = true;\n          setTimeout(function () {\n            var input = document.getElementById('custom-derivation-input');\n            input && input.focus();\n          }, 100);\n        } else {\n          state.error = '';\n          state.showCustomInput = false;\n          state.dPath = selectedPath;\n        }\n      };\n\n      var deleteWindowProperties = function deleteWindowProperties() {\n        delete window.handleCustomInput;\n        delete window.handleDerivationSelect;\n      };\n\n      window.handleCustomInput = handleCustomInput;\n      window.handleDerivationClick = handleDerivationClick;\n      return {\n        heading: heading || 'Hardware Wallet Connect',\n        description: description || \"Make sure your \".concat(wallet.name, \" is plugged in, \").concat(wallet.name === 'Ledger' ? 'and the Ethereum app is open, ' : '', \"then select a derivation path to connect your accounts:\"),\n        eventCode: 'derivationPath',\n        html: derivationSelectHtmlString(wallet.name),\n        button: {\n          text: 'Connect',\n          onclick: function () {\n            var _onclick = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {\n              var path, validPath;\n              return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                while (1) {\n                  switch (_context11.prev = _context11.next) {\n                    case 0:\n                      state.loading = true;\n                      path = state.dPath || derivationPaths[wallet.name][0].path;\n                      _context11.prev = 2;\n                      _context11.next = 5;\n                      return wallet.provider.setPath(path, state.showCustomInput);\n\n                    case 5:\n                      validPath = _context11.sent;\n\n                      if (validPath) {\n                        _context11.next = 10;\n                        break;\n                      }\n\n                      state.error = \"\".concat(path, \" is not a valid derivation path\");\n                      state.loading = false;\n                      return _context11.abrupt(\"return\");\n\n                    case 10:\n                      _context11.next = 17;\n                      break;\n\n                    case 12:\n                      _context11.prev = 12;\n                      _context11.t0 = _context11[\"catch\"](2);\n                      state.error = _context11.t0;\n                      state.loading = false;\n                      return _context11.abrupt(\"return\");\n\n                    case 17:\n                      state.error = '';\n\n                      if (wallet.connect) {\n                        wallet.connect().then(function () {\n                          deleteWindowProperties();\n                          state.loading = false;\n                          state.completed = true;\n                        })[\"catch\"](function (error) {\n                          state.error = error.message;\n                          state.loading = false;\n                        });\n                      }\n\n                    case 19:\n                    case \"end\":\n                      return _context11.stop();\n                  }\n                }\n              }, _callee11, null, [[2, 12]]);\n            }));\n\n            function onclick() {\n              return _onclick.apply(this, arguments);\n            }\n\n            return onclick;\n          }()\n        },\n        icon: icon || usbIcon\n      };\n    }\n  }\n\n  checkModule.reset = resetState;\n  return checkModule;\n}\n\nvar derivationPath$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': derivationPath\n});\n/* src/views/Onboard.svelte generated by Svelte v3.24.0 */\n\nfunction add_css$b() {\n  var style = element(\"style\");\n  style.id = \"svelte-1yxy612-style\";\n  style.textContent = \".bn-onboard-custom.bn-onboard-dark-mode{background:#283944;color:#ffffff}.bn-onboard-custom.bn-onboard-dark-mode-background-hover:hover, .bn-onboard-custom.bn-onboard-dark-mode-background{background:#0e212a}.bn-onboard-clickable{text-decoration:none}.bn-onboard-clickable:hover{cursor:pointer;text-decoration:underline}.bn-onboard-custom.bn-onboard-dark-mode-link{color:#91bced;border-color:#91bced}.bn-onboard-wallet-check-section select{padding:0.5rem}\";\n  append(document.head, style);\n} // (40:0) {#if $app.walletSelectInProgress}\n\n\nfunction create_if_block_2$3(ctx) {\n  var walletselect;\n  var current;\n  walletselect = new WalletSelect({\n    props: {\n      module:\n      /*walletSelectModule*/\n      ctx[0]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletselect.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletselect, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var walletselect_changes = {};\n      if (dirty &\n      /*walletSelectModule*/\n      1) walletselect_changes.module =\n      /*walletSelectModule*/\n      ctx[0];\n      walletselect.$set(walletselect_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletselect.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletselect.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletselect, detaching);\n    }\n  };\n} // (44:0) {#if $app.walletCheckInProgress}\n\n\nfunction create_if_block_1$5(ctx) {\n  var walletcheck;\n  var current;\n  walletcheck = new WalletCheck({\n    props: {\n      walletSelect:\n      /*walletSelect*/\n      ctx[1]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletcheck.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletcheck, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var walletcheck_changes = {};\n      if (dirty &\n      /*walletSelect*/\n      2) walletcheck_changes.walletSelect =\n      /*walletSelect*/\n      ctx[1];\n      walletcheck.$set(walletcheck_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletcheck.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletcheck.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletcheck, detaching);\n    }\n  };\n} // (48:0) {#if $app.accountSelectInProgress}\n\n\nfunction create_if_block$9(ctx) {\n  var walletcheck;\n  var current;\n  walletcheck = new WalletCheck({\n    props: {\n      modules: [derivationPath(), accountSelect()]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletcheck.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletcheck, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletcheck.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletcheck.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletcheck, detaching);\n    }\n  };\n}\n\nfunction create_fragment$b(ctx) {\n  var t0;\n  var t1;\n  var if_block2_anchor;\n  var current;\n  var if_block0 =\n  /*$app*/\n  ctx[2].walletSelectInProgress && create_if_block_2$3(ctx);\n  var if_block1 =\n  /*$app*/\n  ctx[2].walletCheckInProgress && create_if_block_1$5(ctx);\n  var if_block2 =\n  /*$app*/\n  ctx[2].accountSelectInProgress && create_if_block$9();\n  return {\n    c: function c() {\n      if (if_block0) if_block0.c();\n      t0 = space();\n      if (if_block1) if_block1.c();\n      t1 = space();\n      if (if_block2) if_block2.c();\n      if_block2_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t0, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, t1, anchor);\n      if (if_block2) if_block2.m(target, anchor);\n      insert(target, if_block2_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, _ref35) {\n      var _ref36 = _slicedToArray(_ref35, 1),\n          dirty = _ref36[0];\n\n      if (\n      /*$app*/\n      ctx[2].walletSelectInProgress) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          4) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_2$3(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t0.parentNode, t0);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*$app*/\n      ctx[2].walletCheckInProgress) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          4) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block_1$5(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(t1.parentNode, t1);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*$app*/\n      ctx[2].accountSelectInProgress) {\n        if (if_block2) {\n          if_block2.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          4) {\n            transition_in(if_block2, 1);\n          }\n        } else {\n          if_block2 = create_if_block$9();\n          if_block2.c();\n          transition_in(if_block2, 1);\n          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);\n        }\n      } else if (if_block2) {\n        group_outros();\n        transition_out(if_block2, 1, 1, function () {\n          if_block2 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      transition_in(if_block1);\n      transition_in(if_block2);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      transition_out(if_block1);\n      transition_out(if_block2);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t0);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(t1);\n      if (if_block2) if_block2.d(detaching);\n      if (detaching) detach(if_block2_anchor);\n    }\n  };\n}\n\nfunction instance$b($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(2, $app = $$value);\n  });\n  var walletSelectModule = $$props.walletSelectModule;\n  var walletSelect = $$props.walletSelect;\n\n  $$self.$set = function ($$props) {\n    if (\"walletSelectModule\" in $$props) $$invalidate(0, walletSelectModule = $$props.walletSelectModule);\n    if (\"walletSelect\" in $$props) $$invalidate(1, walletSelect = $$props.walletSelect);\n  };\n\n  return [walletSelectModule, walletSelect, $app];\n}\n\nvar Onboard = /*#__PURE__*/function (_SvelteComponent12) {\n  _inherits(Onboard, _SvelteComponent12);\n\n  var _super12 = _createSuper(Onboard);\n\n  function Onboard(options) {\n    var _this12;\n\n    _classCallCheck(this, Onboard);\n\n    _this12 = _super12.call(this);\n    if (!document.getElementById(\"svelte-1yxy612-style\")) add_css$b();\n    init(_assertThisInitialized(_this12), options, instance$b, create_fragment$b, safe_not_equal, {\n      walletSelectModule: 0,\n      walletSelect: 1\n    });\n    return _this12;\n  }\n\n  return Onboard;\n}(SvelteComponent);\n\nvar version = \"1.16.0\"; // wallets that qualify for default wallets need to have no\n// init parameters that are required for full functionality\n\nvar defaultWalletNames = ['web3Wallet', 'metamask', 'dapper', 'coinbase', 'trust', 'authereum', 'torus', 'opera', 'operaTouch', 'status', 'hyperpay', 'unilogin', 'tokenpocket', 'dcent'];\n\nfunction select(wallets, networkId) {\n  if (wallets) {\n    return Promise.all(wallets.map(function (wallet) {\n      if (isWalletInit(wallet)) {\n        var walletName = wallet.walletName,\n            initParams = _objectWithoutProperties(wallet, [\"walletName\"]);\n\n        var module = getModule(walletName);\n\n        if (!module) {\n          throw new Error(\"\".concat(walletName, \" is not a valid walletName.\"));\n        }\n\n        return module && module.then(function (m) {\n          return m[\"default\"](_objectSpread(_objectSpread({}, initParams), {}, {\n            networkId: networkId\n          }));\n        });\n      }\n\n      return Promise.resolve(wallet);\n    }));\n  }\n\n  return Promise.all(defaultWalletNames.map(function (walletName) {\n    var module = getModule(walletName);\n\n    if (module) {\n      return module.then(function (m) {\n        return m[\"default\"]({\n          networkId: networkId\n        });\n      });\n    }\n  }));\n}\n\nfunction getModule(name) {\n  switch (name) {\n    case 'meetone':\n      return __webpack_require__.e(/*! import() */ 19).then(__webpack_require__.bind(null, /*! ./meetone-498d5b39.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/meetone-498d5b39.js\"));\n\n    case 'metamask':\n      return __webpack_require__.e(/*! import() */ 20).then(__webpack_require__.bind(null, /*! ./metamask-df918ac9.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/metamask-df918ac9.js\"));\n\n    case 'dapper':\n      return __webpack_require__.e(/*! import() */ 14).then(__webpack_require__.bind(null, /*! ./dapper-be95b0e6.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/dapper-be95b0e6.js\"));\n\n    case 'portis':\n      return __webpack_require__.e(/*! import() */ 37).then(__webpack_require__.bind(null, /*! ./portis-cbb53753.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/portis-cbb53753.js\"));\n\n    case 'fortmatic':\n      return __webpack_require__.e(/*! import() */ 33).then(__webpack_require__.bind(null, /*! ./fortmatic-225507d1.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/fortmatic-225507d1.js\"));\n\n    case 'squarelink':\n      return __webpack_require__.e(/*! import() */ 38).then(__webpack_require__.bind(null, /*! ./squarelink-150a9d83.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/squarelink-150a9d83.js\"));\n\n    case 'authereum':\n      return __webpack_require__.e(/*! import() */ 30).then(__webpack_require__.bind(null, /*! ./authereum-57ae3381.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/authereum-57ae3381.js\"));\n\n    case 'trust':\n      return __webpack_require__.e(/*! import() */ 26).then(__webpack_require__.bind(null, /*! ./trust-67e47ffa.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/trust-67e47ffa.js\"));\n\n    case 'coinbase':\n      return __webpack_require__.e(/*! import() */ 13).then(__webpack_require__.bind(null, /*! ./coinbase-c0bb4449.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/coinbase-c0bb4449.js\"));\n\n    case 'walletConnect':\n      return __webpack_require__.e(/*! import() */ 42).then(__webpack_require__.bind(null, /*! ./wallet-connect-74bfa317.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/wallet-connect-74bfa317.js\"));\n\n    case 'opera':\n      return __webpack_require__.e(/*! import() */ 22).then(__webpack_require__.bind(null, /*! ./opera-c8be8526.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/opera-c8be8526.js\"));\n\n    case 'operaTouch':\n      return __webpack_require__.e(/*! import() */ 23).then(__webpack_require__.bind(null, /*! ./opera-touch-36d44122.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/opera-touch-36d44122.js\"));\n\n    case 'torus':\n      return __webpack_require__.e(/*! import() */ 39).then(__webpack_require__.bind(null, /*! ./torus-0dbcded9.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/torus-0dbcded9.js\"));\n\n    case 'status':\n      return __webpack_require__.e(/*! import() */ 24).then(__webpack_require__.bind(null, /*! ./status-17aacc06.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/status-17aacc06.js\"));\n\n    case 'trezor':\n      return __webpack_require__.e(/*! import() */ 40).then(__webpack_require__.bind(null, /*! ./trezor-05345fcc.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/trezor-05345fcc.js\"));\n\n    case 'lattice':\n      return __webpack_require__.e(/*! import() */ 34).then(__webpack_require__.bind(null, /*! ./lattice-63e72a8f.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/lattice-63e72a8f.js\"));\n\n    case 'ledger':\n      return __webpack_require__.e(/*! import() */ 35).then(__webpack_require__.bind(null, /*! ./ledger-71657cc6.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/ledger-71657cc6.js\"));\n\n    case 'walletLink':\n      return __webpack_require__.e(/*! import() */ 28).then(__webpack_require__.bind(null, /*! ./wallet-link-a4e44053.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/wallet-link-a4e44053.js\"));\n\n    case 'imToken':\n      return __webpack_require__.e(/*! import() */ 18).then(__webpack_require__.bind(null, /*! ./imtoken-df621d5a.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/imtoken-df621d5a.js\"));\n\n    case 'unilogin':\n      return __webpack_require__.e(/*! import() */ 41).then(__webpack_require__.bind(null, /*! ./unilogin-fc5d8386.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/unilogin-fc5d8386.js\"));\n\n    case 'mykey':\n      return __webpack_require__.e(/*! import() */ 21).then(__webpack_require__.bind(null, /*! ./mykey-f9a238ed.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/mykey-f9a238ed.js\"));\n\n    case 'web3Wallet':\n      return __webpack_require__.e(/*! import() */ 43).then(__webpack_require__.bind(null, /*! ./web3Wallet-c61c4963.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/web3Wallet-c61c4963.js\"));\n\n    case 'huobiwallet':\n      return __webpack_require__.e(/*! import() */ 16).then(__webpack_require__.bind(null, /*! ./huobiwallet-119ccc28.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/huobiwallet-119ccc28.js\"));\n\n    case 'wallet.io':\n      return __webpack_require__.e(/*! import() */ 27).then(__webpack_require__.bind(null, /*! ./wallet-io-ad35ae77.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/wallet-io-ad35ae77.js\"));\n\n    case 'hyperpay':\n      return __webpack_require__.e(/*! import() */ 17).then(__webpack_require__.bind(null, /*! ./hyperpay-da3865b4.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/hyperpay-da3865b4.js\"));\n\n    case 'tokenpocket':\n      return __webpack_require__.e(/*! import() */ 25).then(__webpack_require__.bind(null, /*! ./tokenpocket-6fce6bc5.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/tokenpocket-6fce6bc5.js\"));\n\n    case 'dcent':\n      return __webpack_require__.e(/*! import() */ 15).then(__webpack_require__.bind(null, /*! ./dcent-eb76b95d.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/dcent-eb76b95d.js\"));\n\n    default:\n      return;\n  }\n}\n\nvar defaultChecks = ['connect', 'network'];\n\nfunction check(_x10, _x11) {\n  return _check.apply(this, arguments);\n}\n\nfunction _check() {\n  _check = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(walletChecks, networkId) {\n    var checks;\n    return regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            if (!walletChecks) {\n              _context12.next = 3;\n              break;\n            }\n\n            checks = walletChecks.map(function (checkOrModule) {\n              if (!isWalletCheckModule(checkOrModule)) {\n                var checkName = checkOrModule.checkName,\n                    otherParams = _objectWithoutProperties(checkOrModule, [\"checkName\"]);\n\n                var module = getModule$1(checkName);\n                return module && module.then(function (m) {\n                  return m[\"default\"](_objectSpread(_objectSpread({}, otherParams), {}, {\n                    networkId: networkId\n                  }));\n                });\n              }\n\n              return Promise.resolve(checkOrModule);\n            });\n            return _context12.abrupt(\"return\", Promise.all(checks));\n\n          case 3:\n            return _context12.abrupt(\"return\", Promise.all(defaultChecks.map(function (checkName) {\n              var module = getModule$1(checkName);\n              return module && module.then(function (m) {\n                return m[\"default\"]({\n                  networkId: networkId\n                });\n              });\n            })));\n\n          case 4:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _check.apply(this, arguments);\n}\n\nfunction getModule$1(name) {\n  switch (name) {\n    case 'connect':\n      return __webpack_require__.e(/*! import() */ 32).then(__webpack_require__.bind(null, /*! ./connect-42f86a38.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/connect-42f86a38.js\"));\n\n    case 'network':\n      return __webpack_require__.e(/*! import() */ 36).then(__webpack_require__.bind(null, /*! ./network-2c6412a5.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/network-2c6412a5.js\"));\n\n    case 'balance':\n      return __webpack_require__.e(/*! import() */ 31).then(__webpack_require__.bind(null, /*! ./balance-37a9ab0e.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/balance-37a9ab0e.js\"));\n\n    case 'accounts':\n      return Promise.resolve().then(function () {\n        return accounts;\n      });\n\n    case 'derivationPath':\n      return Promise.resolve().then(function () {\n        return derivationPath$1;\n      });\n\n    default:\n      throw new Error(\"invalid module name: \".concat(name));\n  }\n}\n\nvar defaultHeading = 'Select a Wallet';\nvar defaultDescription = 'Please select a wallet to connect to this dapp:';\nvar defaultWalletExplanation = \"Wallets are used to send, receive, and store digital assets like Ether. Wallets come in many forms. They are either built into your browser, an extension added to your browser, a piece of hardware plugged into your computer or even an app on your phone. For more information about wallets, see <a style=\\\"color: #4a90e2; font-size: 0.889rem; font-family: inherit;\\\" class=\\\"bn-onboard-clickable\\\" href=\\\"https://docs.ethhub.io/using-ethereum/wallets/intro-to-ethereum-wallets/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">this explanation</a>.\";\n\nfunction initializeModules(networkId, walletSelect, walletCheck) {\n  var wallets = select(walletSelect && walletSelect.wallets, networkId);\n  return {\n    walletSelect: {\n      heading: walletSelect && walletSelect.heading || defaultHeading,\n      description: walletSelect && walletSelect.description || defaultDescription,\n      wallets: wallets,\n      explanation: walletSelect && walletSelect.explanation || defaultWalletExplanation\n    },\n    walletCheck: check(walletCheck, networkId)\n  };\n}\n\nvar onboard;\n\nfunction init$1(initialization) {\n  if (onboard) {\n    console.warn('onboard has already been initialized');\n    onboard.$destroy();\n  }\n\n  validateInit(initialization);\n  var subscriptions = initialization.subscriptions,\n      dappId = initialization.dappId,\n      networkId = initialization.networkId,\n      darkMode = initialization.darkMode,\n      apiUrl = initialization.apiUrl,\n      hideBranding = initialization.hideBranding;\n\n  var _getDeviceInfo = getDeviceInfo(),\n      os = _getDeviceInfo.os,\n      browser = _getDeviceInfo.browser,\n      isMobile = _getDeviceInfo.isMobile;\n\n  var initializedModules = initializeModules(networkId, initialization.walletSelect, initialization.walletCheck);\n  var displayBranding;\n\n  if (dappId) {\n    if (hideBranding !== false) {\n      displayBranding = false;\n    } else {\n      displayBranding = true;\n    }\n  } else {\n    if (hideBranding !== true) {\n      displayBranding = true;\n    } else {\n      displayBranding = false;\n    }\n  }\n\n  app.update(function (store) {\n    return _objectSpread(_objectSpread({}, store), {}, {\n      dappId: dappId,\n      networkId: networkId,\n      version: version,\n      mobileDevice: isMobile,\n      os: os,\n      browser: browser,\n      darkMode: darkMode,\n      displayBranding: displayBranding,\n      checkModules: initializedModules.walletCheck\n    });\n  });\n  initializeStores();\n\n  if (dappId) {\n    initializeBlocknative(dappId, networkId, apiUrl);\n  }\n\n  onboard = new Onboard({\n    target: document.body,\n    props: {\n      walletSelectModule: initializedModules.walletSelect,\n      walletSelect: walletSelect\n    }\n  }); // register subscriptions\n\n  if (subscriptions) {\n    if (subscriptions.address) {\n      address.subscribe(function (address) {\n        if (address !== null) {\n          subscriptions.address && subscriptions.address(address);\n        }\n      });\n    }\n\n    if (subscriptions.network) {\n      network.subscribe(function (networkId) {\n        if (networkId !== null) {\n          subscriptions.network && subscriptions.network(networkId);\n        }\n      });\n    }\n\n    if (subscriptions.balance) {\n      balance.subscribe(function (balance) {\n        if (balance !== null) {\n          subscriptions.balance && subscriptions.balance(balance);\n        }\n      });\n    }\n\n    if (subscriptions.wallet) {\n      wallet.subscribe(function (wallet) {\n        if (wallet.provider !== null) {\n          subscriptions.wallet && subscriptions.wallet(wallet);\n        }\n      });\n    }\n  }\n\n  function walletSelect(autoSelectWallet) {\n    return new Promise(function (resolve) {\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          walletSelectInProgress: true,\n          autoSelectWallet: typeof autoSelectWallet === 'string' && autoSelectWallet\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var walletSelectInProgress = store.walletSelectInProgress,\n            walletSelectCompleted = store.walletSelectCompleted,\n            walletSelectDisplayedUI = store.walletSelectDisplayedUI;\n\n        if (walletSelectInProgress === false) {\n          appUnsubscribe(); // timeout for UI transitions if it was displayed\n\n          walletSelectDisplayedUI ? setTimeout(function () {\n            resolve(walletSelectCompleted);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(walletSelectCompleted);\n        }\n      });\n    });\n  }\n\n  function walletCheck() {\n    return new Promise(function (resolve) {\n      if (!get_store_value(walletInterface)) {\n        throw new Error('walletSelect must be called before walletCheck');\n      }\n\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          walletCheckInProgress: true\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var walletCheckInProgress = store.walletCheckInProgress,\n            walletCheckCompleted = store.walletCheckCompleted,\n            walletCheckDisplayedUI = store.walletCheckDisplayedUI;\n\n        if (walletCheckInProgress === false) {\n          appUnsubscribe();\n          walletCheckDisplayedUI ? setTimeout(function () {\n            resolve(walletCheckCompleted);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(walletCheckCompleted);\n        }\n      });\n    });\n  }\n\n  function walletReset() {\n    resetWalletState();\n  }\n\n  function accountSelect() {\n    return new Promise(function (resolve) {\n      var _get_store_value4 = get_store_value(wallet),\n          type = _get_store_value4.type;\n\n      if (type !== 'hardware') {\n        resolve(false);\n      }\n\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          accountSelectInProgress: true\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var accountSelectInProgress = store.accountSelectInProgress,\n            walletSelectDisplayedUI = store.walletSelectDisplayedUI;\n\n        if (accountSelectInProgress === false) {\n          appUnsubscribe();\n          walletSelectDisplayedUI ? setTimeout(function () {\n            resolve(true);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(true);\n        }\n      });\n    });\n  }\n\n  function config(options) {\n    validateConfig(options);\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), options);\n    });\n  }\n\n  function getState() {\n    return get_store_value(state);\n  }\n\n  return {\n    walletSelect: walletSelect,\n    walletCheck: walletCheck,\n    walletReset: walletReset,\n    config: config,\n    getState: getState,\n    accountSelect: accountSelect\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb29sdG9nZXRoZXIvYm5jLW9uYm9hcmQvZGlzdC9lc20vb25ib2FyZC0xOTdlZTYwOC5qcz8zNzI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVyK0IsMENBQTBDLCtEQUErRCwyRUFBMkUsRUFBRSx5RUFBeUUsZUFBZSxzREFBc0QsRUFBRSxFQUFFLHVEQUF1RDs7QUFFL1gsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZ0NBQWdDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQseURBQXlELEVBQUUsT0FBTyx1Q0FBdUMsRUFBRSxpREFBaUQsR0FBRzs7QUFFdmEsaURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLHNDQUFzQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLHdFQUF3RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFbFUsNkJBQTZCLGdHQUFnRyxnREFBZ0QsR0FBRywyQkFBMkI7O0FBRTNNLDBDQUEwQyxnQ0FBZ0Msb0NBQW9D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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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L0M7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNkNBQU07QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsOENBQThDOzs7QUFHOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLDZDQUE2Qzs7O0FBRzdDLGtEQUFrRDs7O0FBR2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7OztBQUdiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYSxtQkFBbUIsbUJBQW1CLHFCQUFxQixnQkFBZ0IsVUFBVSxvQkFBb0Isa0JBQWtCLGlCQUFpQixzQkFBc0IsZ0NBQWdDLGlCQUFpQiw4QkFBOEIsV0FBVyxhQUFhLGtCQUFrQixvQkFBb0IsdUJBQXVCLGtCQUFrQiw4Q0FBOEMsYUFBYSwwQ0FBMEMsZ0NBQWdDLFdBQVcsNkJBQTZCLGdCQUFnQixtQkFBbUI7QUFDem1CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7OztBQUdiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsZUFBZTs7O0FBRzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QixPQUFPOzs7QUFHcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsbUJBQW1CLG9CQUFvQixnQ0FBZ0MsYUFBYSxrQkFBa0Isb0JBQW9CLDhCQUE4QixxQ0FBcUMsY0FBYyxrQkFBa0Isb0JBQW9CLGtCQUFrQixlQUFlO0FBQ3pWO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QixjQUFjLG1CQUFtQixFQUFFOzs7QUFHbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLGNBQWMsbUJBQW1CLEVBQUU7OztBQUduRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZDQUE2QywyQkFBMkI7OztBQUd6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLDhCQUE4QixVQUFVLFNBQVM7OztBQUdoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDLHdCQUF3Qjs7O0FBR3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLG1CQUFtQjs7O0FBR25EO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTs7QUFFZjtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7OztBQUdqQjtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7O0FBRW5CO0FBQ0E7QUFDQSxpQkFBaUI7OztBQUdqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEUsMkJBQTJCLG1EQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGdNQUFnTTtBQUNoTTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1Qix5QkFBeUIsbUJBQW1CLHVCQUF1Qjs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwYkFBMGIscUJBQXFCLGlGQUFpRjtBQUNoaUI7QUFDQSxpQkFBaUIsdUVBQXVFLHFCQUFxQixvQkFBb0IsZ0JBQWdCLHlCQUF5QixtQkFBbUIsbUJBQW1CLHFCQUFxQixpQkFBaUIsZ0JBQWdCLHVCQUF1QixtQkFBbUIscUJBQXFCO0FBQ3JVO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLDJCQUEyQix3QkFBd0IsNEJBQTRCO0FBQy9HLDBDQUEwQyx1QkFBdUIseUJBQXlCLHNCQUFzQix3QkFBd0IsMEJBQTBCLHdCQUF3Qix1QkFBdUIsMEJBQTBCLHVCQUF1QixtQkFBbUIseUJBQXlCLDZDQUE2QyxzQkFBc0I7QUFDalgsd0NBQXdDO0FBQ3hDLG9EQUFvRDtBQUNwRCxpREFBaUQ7QUFDakQsc0NBQXNDLHVCQUF1Qix5QkFBeUIsbUJBQW1CLHVCQUF1QjtBQUNoSSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdVdBQXVXO0FBQzVXOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxtQkFBbUIsY0FBYyxtSEFBbUgsbUJBQW1CLHNCQUFzQixxQkFBcUIsNEJBQTRCLGVBQWUsMEJBQTBCLDZDQUE2QyxjQUFjLHFCQUFxQix3Q0FBd0MsZUFBZTtBQUM3ZDtBQUNBLENBQUMsWUFBWTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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O0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bwb29sdG9nZXRoZXIvYm5jLW9uYm9hcmQvZGlzdC9lc20vb25ib2FyZC0xOTdlZTYwOC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCBCbG9ja25hdGl2ZUFwaSBmcm9tICdibmMtc2RrJztcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgIHRhcltrXSA9IHNyY1trXTtcbiAgfVxuXG4gIHJldHVybiB0YXI7XG59XG5cbmZ1bmN0aW9uIHJ1bihmbikge1xuICByZXR1cm4gZm4oKTtcbn1cblxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgZm5zLmZvckVhY2gocnVuKTtcbn1cblxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCBhICYmIF90eXBlb2YoYSkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUpIHtcbiAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjYWxsYmFja3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNhbGxiYWNrc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUuYXBwbHkoc3RvcmUsIGNhbGxiYWNrcyk7XG4gIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUoKTtcbiAgfSA6IHVuc3ViO1xufVxuXG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgdmFyIHZhbHVlO1xuICBzdWJzY3JpYmUoc3RvcmUsIGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIHZhbHVlID0gXztcbiAgfSkoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gIGlmIChkZWZpbml0aW9uKSB7XG4gICAgdmFyIHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpIDogJCRzY29wZS5jdHg7XG59XG5cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgdmFyIGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG5cbiAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbGV0cztcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihsZXRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cblxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgfVxuXG4gIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgdmFyIHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cbiAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgIHZhciBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICB9XG59XG5cbnZhciBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBub3cgPSBpc19jbGllbnQgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG52YXIgcmFmID0gaXNfY2xpZW50ID8gZnVuY3Rpb24gKGNiKSB7XG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xufSA6IG5vb3A7XG52YXIgdGFza3MgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgdGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgIHRhc2tzW1wiZGVsZXRlXCJdKHRhc2spO1xuICAgICAgdGFzay5mKCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHRhc2tzLnNpemUgIT09IDApIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5cblxuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICB2YXIgdGFzaztcbiAgaWYgKHRhc2tzLnNpemUgPT09IDApIHJhZihydW5fdGFza3MpO1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsKSB7XG4gICAgICB0YXNrcy5hZGQodGFzayA9IHtcbiAgICAgICAgYzogY2FsbGJhY2ssXG4gICAgICAgIGY6IGZ1bGZpbGxcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRhc2tzW1wiZGVsZXRlXCJdKHRhc2spO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cblxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gIHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gdGV4dCgnJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7ZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgZGF0YSA9ICcnICsgZGF0YTtcbiAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKSB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuXG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkZXRhaWwpO1xuICByZXR1cm4gZTtcbn1cblxudmFyIEh0bWxUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIdG1sVGFnKCkge1xuICAgIHZhciBhbmNob3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSHRtbFRhZyk7XG5cbiAgICB0aGlzLmEgPSBhbmNob3I7XG4gICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIdG1sVGFnLCBbe1xuICAgIGtleTogXCJtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG0oaHRtbCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYW5jaG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoKGh0bWwpIHtcbiAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaShhbmNob3IpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwKGh0bWwpIHtcbiAgICAgIHRoaXMuZCgpO1xuICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZCgpIHtcbiAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEh0bWxUYWc7XG59KCk7XG5cbnZhciBhY3RpdmVfZG9jcyA9IG5ldyBTZXQoKTtcbnZhciBhY3RpdmUgPSAwOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODE7XG4gIHZhciBpID0gc3RyLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4pIHtcbiAgdmFyIHVpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogMDtcbiAgdmFyIHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgdmFyIGtleWZyYW1lcyA9ICd7XFxuJztcblxuICBmb3IgKHZhciBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICB2YXIgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIFwiJXtcIi5jb25jYXQoZm4odCwgMSAtIHQpLCBcIn1cXG5cIik7XG4gIH1cblxuICB2YXIgcnVsZSA9IGtleWZyYW1lcyArIFwiMTAwJSB7XCIuY29uY2F0KGZuKGIsIDEgLSBiKSwgXCJ9XFxufVwiKTtcbiAgdmFyIG5hbWUgPSBcIl9fc3ZlbHRlX1wiLmNvbmNhdChoYXNoKHJ1bGUpLCBcIl9cIikuY29uY2F0KHVpZCk7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gIGFjdGl2ZV9kb2NzLmFkZChkb2MpO1xuICB2YXIgc3R5bGVzaGVldCA9IGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0IHx8IChkb2MuX19zdmVsdGVfc3R5bGVzaGVldCA9IGRvYy5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQoJ3N0eWxlJykpLnNoZWV0KTtcbiAgdmFyIGN1cnJlbnRfcnVsZXMgPSBkb2MuX19zdmVsdGVfcnVsZXMgfHwgKGRvYy5fX3N2ZWx0ZV9ydWxlcyA9IHt9KTtcblxuICBpZiAoIWN1cnJlbnRfcnVsZXNbbmFtZV0pIHtcbiAgICBjdXJyZW50X3J1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoXCJAa2V5ZnJhbWVzIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KHJ1bGUpLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gXCJcIi5jb25jYXQoYW5pbWF0aW9uID8gXCJcIi5jb25jYXQoYW5pbWF0aW9uLCBcIiwgXCIpIDogXCJcIikuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXMgbGluZWFyIFwiKS5jb25jYXQoZGVsYXksIFwibXMgMSBib3RoXCIpO1xuICBhY3RpdmUgKz0gMTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZSA/IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgcmV0dXJuIGFuaW0uaW5kZXhPZihuYW1lKSA8IDA7XG4gIH0gLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICA6IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgcmV0dXJuIGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTE7XG4gIH0gLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICApO1xuICB2YXIgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuXG4gIGlmIChkZWxldGVkKSB7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgaWYgKCFhY3RpdmUpIGNsZWFyX3J1bGVzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuICAgIGFjdGl2ZV9kb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldDtcbiAgICAgIHZhciBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgfVxuXG4gICAgICBkb2MuX19zdmVsdGVfcnVsZXMgPSB7fTtcbiAgICB9KTtcbiAgICBhY3RpdmVfZG9jcy5jbGVhcigpO1xuICB9KTtcbn1cblxudmFyIGN1cnJlbnRfY29tcG9uZW50O1xuXG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gIGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvblwiKTtcbiAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cblxudmFyIGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbnZhciBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xudmFyIHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbnZhciBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbnZhciByZXNvbHZlZF9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGlmIChmbHVzaGluZykgcmV0dXJuO1xuICBmbHVzaGluZyA9IHRydWU7XG5cbiAgZG8ge1xuICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ldO1xuICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICB9XG5cbiAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH0gLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IF9pICs9IDEpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbX2ldO1xuXG4gICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuXG4gIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gIH1cblxuICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gIGZsdXNoaW5nID0gZmFsc2U7XG4gIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAkJC51cGRhdGUoKTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIHZhciBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICB9XG59XG5cbnZhciBwcm9taXNlO1xuXG5mdW5jdGlvbiB3YWl0KCkge1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KFwiXCIuY29uY2F0KGRpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nKS5jb25jYXQoa2luZCkpKTtcbn1cblxudmFyIG91dHJvaW5nID0gbmV3IFNldCgpO1xudmFyIG91dHJvcztcblxuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICBvdXRyb3MgPSB7XG4gICAgcjogMCxcbiAgICBjOiBbXSxcbiAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICBpZiAoIW91dHJvcy5yKSB7XG4gICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gIH1cblxuICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICBvdXRyb2luZ1tcImRlbGV0ZVwiXShibG9jayk7XG4gICAgYmxvY2suaShsb2NhbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpIHJldHVybjtcbiAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgIG91dHJvcy5jLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgb3V0cm9pbmdbXCJkZWxldGVcIl0oYmxvY2spO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRldGFjaCkgYmxvY2suZCgxKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBibG9jay5vKGxvY2FsKTtcbiAgfVxufVxuXG52YXIgbnVsbF90cmFuc2l0aW9uID0ge1xuICBkdXJhdGlvbjogMFxufTtcblxuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICB2YXIgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgdmFyIHJ1bm5pbmcgPSBmYWxzZTtcbiAgdmFyIGFuaW1hdGlvbl9uYW1lO1xuICB2YXIgdGFzaztcbiAgdmFyIHVpZCA9IDA7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKCkge1xuICAgIHZhciBfcmVmID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbixcbiAgICAgICAgX3JlZiRkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICAgIGRlbGF5ID0gX3JlZiRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkZGVsYXksXG4gICAgICAgIF9yZWYkZHVyYXRpb24gPSBfcmVmLmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbiA9IF9yZWYkZHVyYXRpb24gPT09IHZvaWQgMCA/IDMwMCA6IF9yZWYkZHVyYXRpb24sXG4gICAgICAgIF9yZWYkZWFzaW5nID0gX3JlZi5lYXNpbmcsXG4gICAgICAgIGVhc2luZyA9IF9yZWYkZWFzaW5nID09PSB2b2lkIDAgPyBpZGVudGl0eSA6IF9yZWYkZWFzaW5nLFxuICAgICAgICBfcmVmJHRpY2sgPSBfcmVmLnRpY2ssXG4gICAgICAgIHRpY2sgPSBfcmVmJHRpY2sgPT09IHZvaWQgMCA/IG5vb3AgOiBfcmVmJHRpY2ssXG4gICAgICAgIGNzcyA9IF9yZWYuY3NzO1xuXG4gICAgaWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgdGljaygwLCAxKTtcbiAgICB2YXIgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgdmFyIGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgIGlmICh0YXNrKSB0YXNrLmFib3J0KCk7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgYWRkX3JlbmRlcl9jYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0Jyk7XG4gICAgfSk7XG4gICAgdGFzayA9IGxvb3AoZnVuY3Rpb24gKG5vdykge1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgdmFyIHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydW5uaW5nO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAoc3RhcnRlZCkgcmV0dXJuO1xuICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG5cbiAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW52YWxpZGF0ZTogZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gIHZhciBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICB2YXIgdCA9IGludHJvID8gMCA6IDE7XG4gIHZhciBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICB2YXIgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgdmFyIGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgaWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgdmFyIGQgPSBwcm9ncmFtLmIgLSB0O1xuICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgIHJldHVybiB7XG4gICAgICBhOiB0LFxuICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgZDogZCxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgdmFyIF9yZWYyID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbixcbiAgICAgICAgX3JlZjIkZGVsYXkgPSBfcmVmMi5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfcmVmMiRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJGRlbGF5LFxuICAgICAgICBfcmVmMiRkdXJhdGlvbiA9IF9yZWYyLmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbiA9IF9yZWYyJGR1cmF0aW9uID09PSB2b2lkIDAgPyAzMDAgOiBfcmVmMiRkdXJhdGlvbixcbiAgICAgICAgX3JlZjIkZWFzaW5nID0gX3JlZjIuZWFzaW5nLFxuICAgICAgICBlYXNpbmcgPSBfcmVmMiRlYXNpbmcgPT09IHZvaWQgMCA/IGlkZW50aXR5IDogX3JlZjIkZWFzaW5nLFxuICAgICAgICBfcmVmMiR0aWNrID0gX3JlZjIudGljayxcbiAgICAgICAgdGljayA9IF9yZWYyJHRpY2sgPT09IHZvaWQgMCA/IG5vb3AgOiBfcmVmMiR0aWNrLFxuICAgICAgICBjc3MgPSBfcmVmMi5jc3M7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IHtcbiAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgYjogYlxuICAgIH07XG5cbiAgICBpZiAoIWIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiKSB0aWNrKDAsIDEpO1xuICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpO1xuICAgICAgfSk7XG4gICAgICBsb29wKGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuXG4gICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgaWYgKCEgLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKGIpIHtcbiAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgZ28oYik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ28oYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICBsb29rdXBbXCJkZWxldGVcIl0oYmxvY2sua2V5KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gIHZhciBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gIHZhciBuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpID0gbztcbiAgdmFyIG9sZF9pbmRleGVzID0ge307XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gIH1cblxuICB2YXIgbmV3X2Jsb2NrcyA9IFtdO1xuICB2YXIgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgdmFyIGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgaSA9IG47XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgIHZhciBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgdmFyIGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXG4gICAgaWYgKCFibG9jaykge1xuICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICBibG9jay5jKCk7XG4gICAgfSBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgIH1cblxuICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgfVxuXG4gIHZhciB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgIG4tLTtcbiAgfVxuXG4gIHdoaWxlIChvICYmIG4pIHtcbiAgICB2YXIgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgdmFyIG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgIHZhciBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICB2YXIgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG5cbiAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICBvLS07XG4gICAgICBuLS07XG4gICAgfSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgby0tO1xuICAgIH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgfSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgIG8tLTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgIG8tLTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoby0tKSB7XG4gICAgdmFyIF9vbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgIGlmICghbmV3X2xvb2t1cC5oYXMoX29sZF9ibG9jay5rZXkpKSBkZXN0cm95KF9vbGRfYmxvY2ssIGxvb2t1cCk7XG4gIH1cblxuICB3aGlsZSAobikge1xuICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gIH1cblxuICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICBibG9jayAmJiBibG9jay5jKCk7XG59XG5cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG4gIHZhciBfY29tcG9uZW50JCQkID0gY29tcG9uZW50LiQkLFxuICAgICAgZnJhZ21lbnQgPSBfY29tcG9uZW50JCQkLmZyYWdtZW50LFxuICAgICAgb25fbW91bnQgPSBfY29tcG9uZW50JCQkLm9uX21vdW50LFxuICAgICAgb25fZGVzdHJveSA9IF9jb21wb25lbnQkJCQub25fZGVzdHJveSxcbiAgICAgIGFmdGVyX3VwZGF0ZSA9IF9jb21wb25lbnQkJCQuYWZ0ZXJfdXBkYXRlO1xuICBmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTsgLy8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXG4gIGFkZF9yZW5kZXJfY2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG5cbiAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgb25fZGVzdHJveS5wdXNoLmFwcGx5KG9uX2Rlc3Ryb3ksIF90b0NvbnN1bWFibGVBcnJheShuZXdfb25fZGVzdHJveSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgIC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcbiAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuICB9KTtcbiAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gIHZhciAkJCA9IGNvbXBvbmVudC4kJDtcblxuICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTsgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblxuICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgJCQuY3R4ID0gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgfVxuXG4gIGNvbXBvbmVudC4kJC5kaXJ0eVtpIC8gMzEgfCAwXSB8PSAxIDw8IGkgJSAzMTtcbn1cblxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMpIHtcbiAgdmFyIGRpcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBbLTFdO1xuICB2YXIgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgdmFyIHByb3BfdmFsdWVzID0gb3B0aW9ucy5wcm9wcyB8fCB7fTtcbiAgdmFyICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgIGZyYWdtZW50OiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICAvLyBzdGF0ZVxuICAgIHByb3BzOiBwcm9wcyxcbiAgICB1cGRhdGU6IG5vb3AsXG4gICAgbm90X2VxdWFsOiBub3RfZXF1YWwsXG4gICAgYm91bmQ6IGJsYW5rX29iamVjdCgpLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIG9uX21vdW50OiBbXSxcbiAgICBvbl9kZXN0cm95OiBbXSxcbiAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgIGNvbnRleHQ6IG5ldyBNYXAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSxcbiAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgIGRpcnR5OiBkaXJ0eVxuICB9O1xuICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgJCQuY3R4ID0gaW5zdGFuY2UgPyBpbnN0YW5jZShjb21wb25lbnQsIHByb3BfdmFsdWVzLCBmdW5jdGlvbiAoaSwgcmV0KSB7XG4gICAgdmFyIHZhbHVlID0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMikgPyBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0gOiByZXQ7XG5cbiAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgaWYgKCQkLmJvdW5kW2ldKSAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICBpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KSA6IFtdO1xuICAkJC51cGRhdGUoKTtcbiAgcmVhZHkgPSB0cnVlO1xuICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpOyAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblxuICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgdmFyIG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXG4gICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnRybykgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvcik7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxudmFyIFN2ZWx0ZUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN2ZWx0ZUNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ZlbHRlQ29tcG9uZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdmVsdGVDb21wb25lbnQsIFt7XG4gICAga2V5OiBcIiRkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRkZXN0cm95KCkge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiJG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCIkc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRzZXQoKSB7Ly8gb3ZlcnJpZGRlbiBieSBpbnN0YW5jZSwgaWYgaXQgaGFzIHByb3BzXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN2ZWx0ZUNvbXBvbmVudDtcbn0oKTtcblxudmFyIHN1YnNjcmliZXJfcXVldWUgPSBbXTtcbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKiBAcGFyYW0gdmFsdWUgaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcn1zdGFydCBzdGFydCBhbmQgc3RvcCBub3RpZmljYXRpb25zIGZvciBzdWJzY3JpcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHsqPX12YWx1ZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPX1zdGFydCBzdGFydCBhbmQgc3RvcCBub3RpZmljYXRpb25zIGZvciBzdWJzY3JpcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSkge1xuICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gIHZhciBzdG9wO1xuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcblxuICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG4gICAgaWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IG5ld192YWx1ZTtcblxuICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgLy8gc3RvcmUgaXMgcmVhZHlcbiAgICAgICAgdmFyIHJ1bl9xdWV1ZSA9ICFzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHMgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICBzWzFdKCk7XG4gICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHMsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydW5fcXVldWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWVbX2kyXVswXShzdWJzY3JpYmVyX3F1ZXVlW19pMiArIDFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICBzZXQoZm4odmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShydW4pIHtcbiAgICB2YXIgaW52YWxpZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICB2YXIgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuICAgIHN1YnNjcmliZXJzLnB1c2goc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQoc2V0KSB8fCBub29wO1xuICAgIH1cblxuICAgIHJ1bih2YWx1ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2Yoc3Vic2NyaWJlcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdG9wKCk7XG4gICAgICAgIHN0b3AgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNldDogc2V0LFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuICB2YXIgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcbiAgdmFyIHN0b3Jlc19hcnJheSA9IHNpbmdsZSA/IFtzdG9yZXNdIDogc3RvcmVzO1xuICB2YXIgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG4gIHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGluaXRlZCA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgdmFyIGNsZWFudXAgPSBub29wO1xuXG4gICAgdmFyIHN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbGVhbnVwKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQpO1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBzZXQocmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKGZ1bmN0aW9uIChzdG9yZSwgaSkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShzdG9yZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICBwZW5kaW5nICY9IH4oMSA8PCBpKTtcblxuICAgICAgICBpZiAoaW5pdGVkKSB7XG4gICAgICAgICAgc3luYygpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmcgfD0gMSA8PCBpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaW5pdGVkID0gdHJ1ZTtcbiAgICBzeW5jKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuICAgICAgY2xlYW51cCgpO1xuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmYWRlKG5vZGUsIF9yZWYzKSB7XG4gIHZhciBfcmVmMyRkZWxheSA9IF9yZWYzLmRlbGF5LFxuICAgICAgZGVsYXkgPSBfcmVmMyRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJGRlbGF5LFxuICAgICAgX3JlZjMkZHVyYXRpb24gPSBfcmVmMy5kdXJhdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX3JlZjMkZHVyYXRpb24gPT09IHZvaWQgMCA/IDQwMCA6IF9yZWYzJGR1cmF0aW9uLFxuICAgICAgX3JlZjMkZWFzaW5nID0gX3JlZjMuZWFzaW5nLFxuICAgICAgZWFzaW5nID0gX3JlZjMkZWFzaW5nID09PSB2b2lkIDAgPyBpZGVudGl0eSA6IF9yZWYzJGVhc2luZztcbiAgdmFyIG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICByZXR1cm4ge1xuICAgIGRlbGF5OiBkZWxheSxcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgZWFzaW5nOiBlYXNpbmcsXG4gICAgY3NzOiBmdW5jdGlvbiBjc3ModCkge1xuICAgICAgcmV0dXJuIFwib3BhY2l0eTogXCIuY29uY2F0KHQgKiBvKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBibG9ja25hdGl2ZTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUJsb2NrbmF0aXZlKGRhcHBJZCwgbmV0d29ya0lkLCBhcGlVcmwpIHtcbiAgYmxvY2tuYXRpdmUgPSBuZXcgQmxvY2tuYXRpdmVBcGkoe1xuICAgIGRhcHBJZDogZGFwcElkLFxuICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgIG5hbWU6ICdPbmJvYXJkJyxcbiAgICBhcGlVcmw6IGFwaVVybFxuICB9KTtcbiAgcmV0dXJuIGJsb2NrbmF0aXZlO1xufVxuXG5mdW5jdGlvbiBnZXRCbG9ja25hdGl2ZSgpIHtcbiAgcmV0dXJuIGJsb2NrbmF0aXZlO1xufVxuXG5mdW5jdGlvbiBnZXROZXR3b3JrKHByb3ZpZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIG1ldGhvZDogJ25ldF92ZXJzaW9uJyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBpZDogNDJcbiAgICB9OyAvLyB1c2UgTWV0YU1hc2sgcGFyYW1ldGVyIGlmIHRoZXJlXG5cbiAgICBpZiAocHJvdmlkZXIuY2hhaW5JZCkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoTnVtYmVyKHByb3ZpZGVyLmNoYWluSWQpKTtcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlLCByZXMpIHtcbiAgICAgIGUgJiYgcmVqZWN0KGUpO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlcyAmJiByZXMucmVzdWx0O1xuICAgICAgcmVzb2x2ZShyZXN1bHQgJiYgTnVtYmVyKHJlc3VsdCkpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyLnNlbmRBc3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm92aWRlci5zZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm92aWRlci5zZW5kKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBZGRyZXNzKHByb3ZpZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIG1ldGhvZDogJ2V0aF9hY2NvdW50cycsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgaWQ6IDQyXG4gICAgfTsgLy8gdXNlIE1ldGFNYXNrIHJlcXVlc3QgbWV0aG9kIGlmIHRoZXJlXG5cbiAgICBpZiAocHJvdmlkZXIucmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3Qob3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc1swXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlLCByZXMpIHtcbiAgICAgIGUgJiYgcmVqZWN0KGUpO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlcyAmJiByZXMucmVzdWx0ICYmIHJlcy5yZXN1bHRbMF07XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvdmlkZXIuc2VuZEFzeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm92aWRlci5zZW5kQXN5bmMob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3ZpZGVyLnNlbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3ZpZGVyLnNlbmQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEJhbGFuY2UocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBjdXJyZW50QWRkcmVzcywgb3B0aW9ucywgY2FsbGJhY2s7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gYWRkcmVzcztcblxuICAgICAgICAgICAgICBpZiAoX2NvbnRleHQudDApIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhwcm92aWRlcik7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGN1cnJlbnRBZGRyZXNzID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dldEJhbGFuY2UnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW2N1cnJlbnRBZGRyZXNzLCAnbGF0ZXN0J10sXG4gICAgICAgICAgICAgICAgaWQ6IDQyXG4gICAgICAgICAgICAgIH07IC8vIHVzZSBNZXRhTWFzayByZXF1ZXN0IG1ldGhvZCBpZiB0aGVyZVxuXG4gICAgICAgICAgICAgIGlmICghcHJvdmlkZXIucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJvdmlkZXIucmVxdWVzdChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzID8gbmV3IEJpZ051bWJlcihyZXMpLnRvU3RyaW5nKDEwKSA6IG51bGw7XG4gICAgICAgICAgICAgIH0pLnRoZW4ocmVzb2x2ZSkpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGUsIHJlcykge1xuICAgICAgICAgICAgICAgIGUgJiYgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXMgJiYgcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCAmJiBuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9TdHJpbmcoMTApKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyLnNlbmRBc3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNlbmRBc3luYyhvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3ZpZGVyLnNlbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zZW5kKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vZGVyblByb3ZpZGVySW50ZXJmYWNlKHByb3ZpZGVyKSB7XG4gIHByb3ZpZGVyLmF1dG9SZWZyZXNoT25OZXR3b3JrQ2hhbmdlID0gZmFsc2U7XG4gIHZhciBvbkZ1bmNFeGlzdHMgPSB0eXBlb2YgcHJvdmlkZXIub24gPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogb25GdW5jRXhpc3RzID8ge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZ1bmMpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGdldEFkZHJlc3MocHJvdmlkZXIpLnRoZW4oZnVuYyk7XG4gICAgICAgIHByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCBmdW5jdGlvbiAoYWNjb3VudHMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYyhhY2NvdW50cyAmJiBhY2NvdW50c1swXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmV0d29yazogb25GdW5jRXhpc3RzID8ge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZ1bmMpIHtcbiAgICAgICAgLy8gZ2V0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgZ2V0TmV0d29yayhwcm92aWRlcikudGhlbihmdW5jKTsgLy8gbmV0d29ya0NoYW5nZWQgZXZlbnQgaXMgZGVwcmVjYXRlZCBpbiBNTSwga2VlcCBmb3Igd2FsbGV0cyB0aGF0IG1heSBub3QgaGF2ZSB1cGRhdGVkXG5cbiAgICAgICAgcHJvdmlkZXIub24oJ25ldHdvcmtDaGFuZ2VkJywgZnVuY3Rpb24gKG5ldElkKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMobmV0SWQgJiYgTnVtYmVyKG5ldElkKSk7XG4gICAgICAgIH0pOyAvLyB1c2UgbmV3IGNoYWluQ2hhbmdlZCBldmVudCBmb3IgbmV0d29yayBjaGFuZ2VcblxuICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgZnVuY3Rpb24gKG5ldElkKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMobmV0SWQgJiYgTnVtYmVyKG5ldElkKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmFsYW5jZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCYWxhbmNlKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHByb3ZpZGVyLnJlcXVlc3QgPyBnZXRBZGRyZXNzKHByb3ZpZGVyKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZHJlc3MgPyBhZGRyZXNzIDogcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSA6IHByb3ZpZGVyLmVuYWJsZSgpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdC50aGVuKHJlc29sdmUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZWplY3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoaXMgZGFwcCBuZWVkcyBhY2Nlc3MgdG8geW91ciBhY2NvdW50IGluZm9ybWF0aW9uLidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG5hbWU6IGdldFByb3ZpZGVyTmFtZShwcm92aWRlcilcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGVnYWN5UHJvdmlkZXJJbnRlcmZhY2UocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmV0d29yazoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJhbGFuY2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0QmFsYW5jZShwcm92aWRlcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBnZXRQcm92aWRlck5hbWUocHJvdmlkZXIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFByb3ZpZGVyTmFtZShwcm92aWRlcikge1xuICBpZiAoIXByb3ZpZGVyKSByZXR1cm47XG5cbiAgaWYgKHByb3ZpZGVyLmlzV2FsbGV0SU8pIHtcbiAgICByZXR1cm4gJ3dhbGxldC5pbyc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNEY2VudFdhbGxldCkge1xuICAgIHJldHVybiAnRFxcJ0NFTlQnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzVG9rZW5Qb2NrZXQpIHtcbiAgICByZXR1cm4gJ1Rva2VuUG9ja2V0JztcbiAgfVxuXG4gIGlmIChwcm92aWRlci53YWxsZXQgPT09ICdNRUVUT05FJykge1xuICAgIHJldHVybiAnTUVFVE9ORSc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNUb3J1cykge1xuICAgIHJldHVybiAnVG9ydXMnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzSW1Ub2tlbikge1xuICAgIHJldHVybiAnaW1Ub2tlbic7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNEYXBwZXIpIHtcbiAgICByZXR1cm4gJ0RhcHBlcic7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNXYWxsZXRDb25uZWN0KSB7XG4gICAgcmV0dXJuICdXYWxsZXRDb25uZWN0JztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc1RydXN0KSB7XG4gICAgcmV0dXJuICdUcnVzdCc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNDb2luYmFzZVdhbGxldCkge1xuICAgIHJldHVybiAnQ29pbmJhc2UnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzVG9zaGkpIHtcbiAgICByZXR1cm4gJ1Rvc2hpJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0NpcGhlcikge1xuICAgIHJldHVybiAnQ2lwaGVyJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc09wZXJhKSB7XG4gICAgcmV0dXJuICdPcGVyYSc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNTdGF0dXMpIHtcbiAgICByZXR1cm4gJ1N0YXR1cyc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNNZXRhTWFzaykge1xuICAgIHJldHVybiAnTWV0YU1hc2snO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzTVlLRVkpIHtcbiAgICByZXR1cm4gJ01ZS0VZJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0hiV2FsbGV0KSB7XG4gICAgcmV0dXJuICdodW9iaXdhbGxldCc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNIeXBlclBheSkge1xuICAgIHJldHVybiAnSHlwZXJQYXknO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmhvc3QgJiYgcHJvdmlkZXIuaG9zdC5pbmRleE9mKCdsb2NhbGhvc3QnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gIH1cblxuICByZXR1cm4gJ3dlYjNXYWxsZXQnO1xufVxuXG5mdW5jdGlvbiBnZXREZXZpY2VJbmZvKCkge1xuICB2YXIgcGFyc2VkID0gYm93c2VyLmdldFBhcnNlcih3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBvcyA9IHBhcnNlZC5nZXRPUygpO1xuICB2YXIgYnJvd3NlciA9IHBhcnNlZC5nZXRCcm93c2VyKCk7XG5cbiAgdmFyIF9wYXJzZWQkZ2V0UGxhdGZvcm0gPSBwYXJzZWQuZ2V0UGxhdGZvcm0oKSxcbiAgICAgIHR5cGUgPSBfcGFyc2VkJGdldFBsYXRmb3JtLnR5cGU7XG5cbiAgcmV0dXJuIHtcbiAgICBpc01vYmlsZTogdHlwZSA/IHR5cGUgIT09ICdkZXNrdG9wJyA6IHdpbmRvdy5pbm5lcldpZHRoIDwgNjAwLFxuICAgIG9zOiBvcyxcbiAgICBicm93c2VyOiBicm93c2VyXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtOYW1lKGlkKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ21haW5uZXQnO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuICdyb3BzdGVuJztcblxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAncmlua2VieSc7XG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gJ2dvZXJsaSc7XG5cbiAgICBjYXNlIDQyOlxuICAgICAgcmV0dXJuICdrb3Zhbic7XG5cbiAgICBjYXNlIDEwMDpcbiAgICAgIHJldHVybiAneGRhaSc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICdsb2NhbCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV0d29ya1RvSWQobmV0d29yaykge1xuICBzd2l0Y2ggKG5ldHdvcmspIHtcbiAgICBjYXNlICdtYWlubmV0JzpcbiAgICAgIHJldHVybiAxO1xuXG4gICAgY2FzZSAncm9wc3Rlbic6XG4gICAgICByZXR1cm4gMztcblxuICAgIGNhc2UgJ3JpbmtlYnknOlxuICAgICAgcmV0dXJuIDQ7XG5cbiAgICBjYXNlICdnb2VybGknOlxuICAgICAgcmV0dXJuIDU7XG5cbiAgICBjYXNlICdrb3Zhbic6XG4gICAgICByZXR1cm4gNDI7XG5cbiAgICBjYXNlICd4ZGFpJzpcbiAgICAgIHJldHVybiAxMDA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FpdCQxKHRpbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2FuY2VsYWJsZShwcm9taXNlKSB7XG4gIHZhciByZWplY3RGbjtcbiAgdmFyIHdyYXBwZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdEZuID0gcmVqZWN0O1xuICAgIHByb21pc2UudGhlbihyZXNvbHZlKVtcImNhdGNoXCJdKHJlamVjdCk7XG4gIH0pO1xuXG4gIHdyYXBwZWRQcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWplY3RGbignY2FuY2VsZWQnKTtcbiAgfTtcblxuICByZXR1cm4gd3JhcHBlZFByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50ZXJ2YWwoZnVuYywgaW50ZXJ2YWwpIHtcbiAgdmFyIGlkID0gc2V0SW50ZXJ2YWwoZnVuYywgaW50ZXJ2YWwpO1xuICB2YXIgc3RhdHVzID0ge1xuICAgIGFjdGl2ZTogdHJ1ZVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogc3RhdHVzLFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgc3RhdHVzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlbkxpbmsodXJsKSB7XG4gIHdpbmRvdy5vcGVuKHVybCk7XG59XG5cbnZhciB2YWxpZFN1YnNjcmlwdGlvbktleXMgPSBbJ2FkZHJlc3MnLCAnbmV0d29yaycsICdiYWxhbmNlJywgJ3dhbGxldCddO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUob3B0aW9ucykge1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSxcbiAgICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZSxcbiAgICAgIHR5cGUgPSBvcHRpb25zLnR5cGUsXG4gICAgICBvcHRpb25hbCA9IG9wdGlvbnMub3B0aW9uYWw7XG5cbiAgaWYgKCFvcHRpb25hbCAmJiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgaXMgcmVxdWlyZWRcIikpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGUgPT09ICdhcnJheScgPyBBcnJheS5pc0FycmF5KHR5cGUpIDogX3R5cGVvZih2YWx1ZSkgIT09IHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgbXVzdCBiZSBvZiB0eXBlOiBcIikuY29uY2F0KHR5cGUsIFwiLCByZWNlaXZlZCB0eXBlOiBcIikuY29uY2F0KF90eXBlb2YodmFsdWUpLCBcIiBmcm9tIHZhbHVlOiBcIikuY29uY2F0KHZhbHVlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52YWxpZFBhcmFtcyhwYXJhbXMsIHZhbGlkUGFyYW1zLCBmdW5jdGlvbk5hbWUpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghdmFsaWRQYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyIGZvciBcIikuY29uY2F0KGZ1bmN0aW9uTmFtZSwgXCIsIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsaWQgcGFyYW1ldGVyczogXCIpLmNvbmNhdCh2YWxpZFBhcmFtcy5qb2luKCcsICcpKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbml0KGluaXQpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnaW5pdCcsXG4gICAgdmFsdWU6IGluaXQsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgdmFyIGRhcHBJZCA9IGluaXQuZGFwcElkLFxuICAgICAgbmV0d29ya0lkID0gaW5pdC5uZXR3b3JrSWQsXG4gICAgICBzdWJzY3JpcHRpb25zID0gaW5pdC5zdWJzY3JpcHRpb25zLFxuICAgICAgd2FsbGV0U2VsZWN0ID0gaW5pdC53YWxsZXRTZWxlY3QsXG4gICAgICB3YWxsZXRDaGVjayA9IGluaXQud2FsbGV0Q2hlY2ssXG4gICAgICBkYXJrTW9kZSA9IGluaXQuZGFya01vZGUsXG4gICAgICBhcGlVcmwgPSBpbml0LmFwaVVybCxcbiAgICAgIGhpZGVCcmFuZGluZyA9IGluaXQuaGlkZUJyYW5kaW5nLFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoaW5pdCwgW1wiZGFwcElkXCIsIFwibmV0d29ya0lkXCIsIFwic3Vic2NyaXB0aW9uc1wiLCBcIndhbGxldFNlbGVjdFwiLCBcIndhbGxldENoZWNrXCIsIFwiZGFya01vZGVcIiwgXCJhcGlVcmxcIiwgXCJoaWRlQnJhbmRpbmdcIl0pO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnZGFwcElkJywgJ25ldHdvcmtJZCcsICdzdWJzY3JpcHRpb25zJywgJ3dhbGxldFNlbGVjdCcsICd3YWxsZXRDaGVjaycsICdkYXJrTW9kZScsICdhcGlVcmwnLCAnaGlkZUJyYW5kaW5nJ10sICdpbml0Jyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcHBJZCcsXG4gICAgdmFsdWU6IGRhcHBJZCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29ya0lkJyxcbiAgICB2YWx1ZTogbmV0d29ya0lkLFxuICAgIHR5cGU6ICdudW1iZXInXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdkYXJrTW9kZScsXG4gICAgdmFsdWU6IGRhcmtNb2RlLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYXBpVXJsJyxcbiAgICB2YWx1ZTogYXBpVXJsLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdoaWRlQnJhbmRpbmcnLFxuICAgIHZhbHVlOiBoaWRlQnJhbmRpbmcsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zJyxcbiAgICB2YWx1ZTogc3Vic2NyaXB0aW9ucyxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgIHZhbGlkYXRlU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldFNlbGVjdCcsXG4gICAgdmFsdWU6IHdhbGxldFNlbGVjdCxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAod2FsbGV0U2VsZWN0KSB7XG4gICAgdmFsaWRhdGVXYWxsZXRTZWxlY3Qod2FsbGV0U2VsZWN0KTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldENoZWNrJyxcbiAgICB2YWx1ZTogd2FsbGV0Q2hlY2ssXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHdhbGxldENoZWNrKSB7XG4gICAgdmFsaWRhdGVXYWxsZXRDaGVjayh3YWxsZXRDaGVjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMpIHtcbiAgdmFyIGFkZHJlc3MgPSBzdWJzY3JpcHRpb25zLmFkZHJlc3MsXG4gICAgICBuZXR3b3JrID0gc3Vic2NyaXB0aW9ucy5uZXR3b3JrLFxuICAgICAgYmFsYW5jZSA9IHN1YnNjcmlwdGlvbnMuYmFsYW5jZSxcbiAgICAgIHdhbGxldCA9IHN1YnNjcmlwdGlvbnMud2FsbGV0LFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3Vic2NyaXB0aW9ucywgW1wiYWRkcmVzc1wiLCBcIm5ldHdvcmtcIiwgXCJiYWxhbmNlXCIsIFwid2FsbGV0XCJdKTtcblxuICBpbnZhbGlkUGFyYW1zKG90aGVyUGFyYW1zLCB2YWxpZFN1YnNjcmlwdGlvbktleXMsICdzdWJzY3JpcHRpb25zJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3N1YnNjcmlwdGlvbnMuYWRkcmVzcycsXG4gICAgdmFsdWU6IGFkZHJlc3MsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc3Vic2NyaXB0aW9ucy5uZXR3b3JrJyxcbiAgICB2YWx1ZTogbmV0d29yayxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zLmJhbGFuY2UnLFxuICAgIHZhbHVlOiBiYWxhbmNlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3N1YnNjcmlwdGlvbnMud2FsbGV0JyxcbiAgICB2YWx1ZTogd2FsbGV0LFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2FsbGV0U2VsZWN0KHdhbGxldFNlbGVjdCkge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRTZWxlY3QnLFxuICAgIHZhbHVlOiB3YWxsZXRTZWxlY3QsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgdmFyIGhlYWRpbmcgPSB3YWxsZXRTZWxlY3QuaGVhZGluZyxcbiAgICAgIGRlc2NyaXB0aW9uID0gd2FsbGV0U2VsZWN0LmRlc2NyaXB0aW9uLFxuICAgICAgZXhwbGFuYXRpb24gPSB3YWxsZXRTZWxlY3QuZXhwbGFuYXRpb24sXG4gICAgICB3YWxsZXRzID0gd2FsbGV0U2VsZWN0LndhbGxldHMsXG4gICAgICBvdGhlclBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyh3YWxsZXRTZWxlY3QsIFtcImhlYWRpbmdcIiwgXCJkZXNjcmlwdGlvblwiLCBcImV4cGxhbmF0aW9uXCIsIFwid2FsbGV0c1wiXSk7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydoZWFkaW5nJywgJ2Rlc2NyaXB0aW9uJywgJ2V4cGxhbmF0aW9uJywgJ3dhbGxldHMnXSwgJ3dhbGxldFNlbGVjdCcpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICB2YWx1ZTogaGVhZGluZyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBkZXNjcmlwdGlvbixcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZXhwbGFuYXRpb24nLFxuICAgIHZhbHVlOiBleHBsYW5hdGlvbixcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh3YWxsZXRzKSkge1xuICAgIHdhbGxldHMuZm9yRWFjaCh2YWxpZGF0ZVdhbGxldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNXYWxsZXRNb2R1bGUob2JqKSB7XG4gIHJldHVybiBvYmoud2FsbGV0ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzV2FsbGV0SW5pdChvYmopIHtcbiAgcmV0dXJuIG9iai53YWxsZXROYW1lICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2FsbGV0KG9iaikge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzZWxlY3RXYWxsZXQud2FsbGV0cyBpdGVtJyxcbiAgICB2YWx1ZTogb2JqLFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuXG4gIGlmIChpc1dhbGxldE1vZHVsZShvYmopKSB7XG4gICAgdmFyIG5hbWUgPSBvYmoubmFtZSxcbiAgICAgICAgaWNvblNyYyA9IG9iai5pY29uU3JjLFxuICAgICAgICBpY29uU3JjU2V0ID0gb2JqLmljb25TcmNTZXQsXG4gICAgICAgIHN2ZyA9IG9iai5zdmcsXG4gICAgICAgIF93YWxsZXQgPSBvYmoud2FsbGV0LFxuICAgICAgICBsaW5rID0gb2JqLmxpbmssXG4gICAgICAgIGluc3RhbGxNZXNzYWdlID0gb2JqLmluc3RhbGxNZXNzYWdlLFxuICAgICAgICBwcmVmZXJyZWQgPSBvYmoucHJlZmVycmVkLFxuICAgICAgICBkZXNrdG9wID0gb2JqLmRlc2t0b3AsXG4gICAgICAgIG1vYmlsZSA9IG9iai5tb2JpbGUsXG4gICAgICAgIHR5cGUgPSBvYmoudHlwZSxcbiAgICAgICAgb3NFeGNsdXNpb25zID0gb2JqLm9zRXhjbHVzaW9ucyxcbiAgICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBbXCJuYW1lXCIsIFwiaWNvblNyY1wiLCBcImljb25TcmNTZXRcIiwgXCJzdmdcIiwgXCJ3YWxsZXRcIiwgXCJsaW5rXCIsIFwiaW5zdGFsbE1lc3NhZ2VcIiwgXCJwcmVmZXJyZWRcIiwgXCJkZXNrdG9wXCIsIFwibW9iaWxlXCIsIFwidHlwZVwiLCBcIm9zRXhjbHVzaW9uc1wiXSk7XG5cbiAgICBpbnZhbGlkUGFyYW1zKG90aGVyUGFyYW1zLCBbJ25hbWUnLCAnaWNvblNyYycsICdpY29uU3JjU2V0JywgJ3N2ZycsICd3YWxsZXQnLCAndHlwZScsICdsaW5rJywgJ2luc3RhbGxNZXNzYWdlJywgJ3ByZWZlcnJlZCcsICdkZXNrdG9wJywgJ21vYmlsZScsICdvc0V4Y2x1c2lvbnMnXSwgJ3NlbGVjdFdhbGxldHMud2FsbGV0cyBpdGVtJyk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ3dhbGxldCcsXG4gICAgICB2YWx1ZTogX3dhbGxldCxcbiAgICAgIHR5cGU6ICdmdW5jdGlvbidcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ2ljb25TcmMnLFxuICAgICAgdmFsdWU6IGljb25TcmMsXG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdpY29uU3JjU2V0JyxcbiAgICAgIHZhbHVlOiBpY29uU3JjU2V0LFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnc3ZnJyxcbiAgICAgIHZhbHVlOiBzdmcsXG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdsaW5rJyxcbiAgICAgIHZhbHVlOiBsaW5rLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnaW5zdGFsbE1lc3NhZ2UnLFxuICAgICAgdmFsdWU6IGluc3RhbGxNZXNzYWdlLFxuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdwcmVmZXJyZWQnLFxuICAgICAgdmFsdWU6IHByZWZlcnJlZCxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdkZXNrdG9wJyxcbiAgICAgIHZhbHVlOiBkZXNrdG9wLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ21vYmlsZScsXG4gICAgICB2YWx1ZTogbW9iaWxlLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgdmFsdWU6IHR5cGUsXG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdvc0V4Y2x1c2lvbnMnLFxuICAgICAgdmFsdWU6IG9zRXhjbHVzaW9ucyxcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhbGlkYXRlV2FsbGV0SW5pdChvYmopO1xufVxuXG5mdW5jdGlvbiBpc1dhbGxldENoZWNrTW9kdWxlKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXYWxsZXRDaGVjayh3YWxsZXRDaGVjaykge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRDaGVjaycsXG4gICAgdmFsdWU6IHdhbGxldENoZWNrLFxuICAgIHR5cGU6ICdhcnJheSdcbiAgfSk7XG4gIHdhbGxldENoZWNrLmZvckVhY2goZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgaWYgKGlzV2FsbGV0Q2hlY2tNb2R1bGUoY2hlY2spKSB7XG4gICAgICB2YWxpZGF0ZVdhbGxldENoZWNrTW9kdWxlKGNoZWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ3dhbGxldENoZWNrIGl0ZW0nLFxuICAgICAgICB2YWx1ZTogY2hlY2ssXG4gICAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgICB9KTtcblxuICAgICAgdmFyIGNoZWNrTmFtZSA9IGNoZWNrLmNoZWNrTmFtZSxcbiAgICAgICAgICBoZWFkaW5nID0gY2hlY2suaGVhZGluZyxcbiAgICAgICAgICBkZXNjcmlwdGlvbiA9IGNoZWNrLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIG1pbmltdW1CYWxhbmNlID0gY2hlY2subWluaW11bUJhbGFuY2UsXG4gICAgICAgICAgaHRtbCA9IGNoZWNrLmh0bWwsXG4gICAgICAgICAgaWNvbiA9IGNoZWNrLmljb24sXG4gICAgICAgICAgYnV0dG9uID0gY2hlY2suYnV0dG9uLFxuICAgICAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNoZWNrLCBbXCJjaGVja05hbWVcIiwgXCJoZWFkaW5nXCIsIFwiZGVzY3JpcHRpb25cIiwgXCJtaW5pbXVtQmFsYW5jZVwiLCBcImh0bWxcIiwgXCJpY29uXCIsIFwiYnV0dG9uXCJdKTtcblxuICAgICAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydjaGVja05hbWUnLCAnaGVhZGluZycsICdkZXNjcmlwdGlvbicsICdodG1sJywgJ2ljb24nLCAnYnV0dG9uJywgJ21pbmltdW1CYWxhbmNlJ10sICd3YWxsZXRDaGVjayBpdGVtJyk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnY2hlY2tOYW1lJyxcbiAgICAgICAgdmFsdWU6IGNoZWNrTmFtZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmcnLFxuICAgICAgICB2YWx1ZTogaGVhZGluZyxcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdkZXNjcmlwdGlvbicsXG4gICAgICAgIHZhbHVlOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdodG1sJyxcbiAgICAgICAgdmFsdWU6IGh0bWwsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnaWNvbicsXG4gICAgICAgIHZhbHVlOiBpY29uLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ2J1dHRvbicsXG4gICAgICAgIHZhbHVlOiBidXR0b24sXG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnbWluaW11bUJhbGFuY2UnLFxuICAgICAgICB2YWx1ZTogbWluaW11bUJhbGFuY2UsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXYWxsZXRDaGVja01vZHVsZShtb2R1bGUpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0Q2hlY2sgbW9kdWxlJyxcbiAgICB2YWx1ZTogbW9kdWxlLFxuICAgIHR5cGU6ICdmdW5jdGlvbidcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnY29uZmlndXJhdGlvbicsXG4gICAgdmFsdWU6IGNvbmZpZ3VyYXRpb24sXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgdmFyIGRhcmtNb2RlID0gY29uZmlndXJhdGlvbi5kYXJrTW9kZSxcbiAgICAgIG5ldHdvcmtJZCA9IGNvbmZpZ3VyYXRpb24ubmV0d29ya0lkLFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoY29uZmlndXJhdGlvbiwgW1wiZGFya01vZGVcIiwgXCJuZXR3b3JrSWRcIl0pO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnZGFya01vZGUnLCAnbmV0d29ya0lkJ10sICdjb25maWd1cmF0aW9uJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcmtNb2RlJyxcbiAgICB2YWx1ZTogZGFya01vZGUsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrSWQnLFxuICAgIHZhbHVlOiBuZXR3b3JrSWQsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTW9kYWwobW9kYWwpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbW9kYWwnLFxuICAgIHZhbHVlOiBtb2RhbCxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcblxuICB2YXIgaGVhZGluZyA9IG1vZGFsLmhlYWRpbmcsXG4gICAgICBkZXNjcmlwdGlvbiA9IG1vZGFsLmRlc2NyaXB0aW9uLFxuICAgICAgYnV0dG9uID0gbW9kYWwuYnV0dG9uLFxuICAgICAgZXZlbnRDb2RlID0gbW9kYWwuZXZlbnRDb2RlLFxuICAgICAgYWN0aW9uID0gbW9kYWwuYWN0aW9uLFxuICAgICAgaWNvbiA9IG1vZGFsLmljb24sXG4gICAgICBodG1sID0gbW9kYWwuaHRtbCxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG1vZGFsLCBbXCJoZWFkaW5nXCIsIFwiZGVzY3JpcHRpb25cIiwgXCJidXR0b25cIiwgXCJldmVudENvZGVcIiwgXCJhY3Rpb25cIiwgXCJpY29uXCIsIFwiaHRtbFwiXSk7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydoZWFkaW5nJywgJ2Rlc2NyaXB0aW9uJywgJ2J1dHRvbicsICdldmVudENvZGUnLCAnYWN0aW9uJywgJ2ljb24nLCAnaHRtbCddLCAnbW9kYWwnKTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgdmFsdWU6IGhlYWRpbmcsXG4gICAgdHlwZTogJ3N0cmluZydcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZGVzY3JpcHRpb24sXG4gICAgdHlwZTogJ3N0cmluZydcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2V2ZW50Q29kZScsXG4gICAgdmFsdWU6IGV2ZW50Q29kZSxcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYWN0aW9uJyxcbiAgICB2YWx1ZTogYWN0aW9uLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2J1dHRvbicsXG4gICAgdmFsdWU6IGJ1dHRvbixcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnaHRtbCcsXG4gICAgdmFsdWU6IGh0bWwsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKGJ1dHRvbikge1xuICAgIHZhciBvbmNsaWNrID0gYnV0dG9uLm9uY2xpY2ssXG4gICAgICAgIF90ZXh0ID0gYnV0dG9uLnRleHQsXG4gICAgICAgIHJlc3RQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoYnV0dG9uLCBbXCJvbmNsaWNrXCIsIFwidGV4dFwiXSk7XG5cbiAgICBpbnZhbGlkUGFyYW1zKHJlc3RQYXJhbXMsIFsnb25jbGljaycsICd0ZXh0J10sICdidXR0b24nKTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ29uY2xpY2snLFxuICAgICAgdmFsdWU6IG9uY2xpY2ssXG4gICAgICB0eXBlOiAnZnVuY3Rpb24nXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgIHZhbHVlOiBfdGV4dCxcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdpY29uJyxcbiAgICB2YWx1ZTogaWNvbixcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXYWxsZXRJbnRlcmZhY2Uod2FsbGV0SW50ZXJmYWNlKSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldEludGVyZmFjZScsXG4gICAgdmFsdWU6IHdhbGxldEludGVyZmFjZSxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcblxuICB2YXIgbmFtZSA9IHdhbGxldEludGVyZmFjZS5uYW1lLFxuICAgICAgY29ubmVjdCA9IHdhbGxldEludGVyZmFjZS5jb25uZWN0LFxuICAgICAgZGlzY29ubmVjdCA9IHdhbGxldEludGVyZmFjZS5kaXNjb25uZWN0LFxuICAgICAgYWRkcmVzcyA9IHdhbGxldEludGVyZmFjZS5hZGRyZXNzLFxuICAgICAgbmV0d29yayA9IHdhbGxldEludGVyZmFjZS5uZXR3b3JrLFxuICAgICAgYmFsYW5jZSA9IHdhbGxldEludGVyZmFjZS5iYWxhbmNlLFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMod2FsbGV0SW50ZXJmYWNlLCBbXCJuYW1lXCIsIFwiY29ubmVjdFwiLCBcImRpc2Nvbm5lY3RcIiwgXCJhZGRyZXNzXCIsIFwibmV0d29ya1wiLCBcImJhbGFuY2VcIl0pO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnbmFtZScsICdjb25uZWN0JywgJ2Rpc2Nvbm5lY3QnLCAnYWRkcmVzcycsICduZXR3b3JrJywgJ2JhbGFuY2UnXSwgJ3dhbGxldEludGVyZmFjZScpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduYW1lJyxcbiAgICB2YWx1ZTogbmFtZSxcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnY29ubmVjdCcsXG4gICAgdmFsdWU6IGNvbm5lY3QsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZGlzY29ubmVjdCcsXG4gICAgdmFsdWU6IGRpc2Nvbm5lY3QsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYWRkcmVzcycsXG4gICAgdmFsdWU6IGFkZHJlc3MsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2FkZHJlc3MuZ2V0JyxcbiAgICB2YWx1ZTogYWRkcmVzcy5nZXQsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYWRkcmVzcy5vbkNoYW5nZScsXG4gICAgdmFsdWU6IGFkZHJlc3Mub25DaGFuZ2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29yaycsXG4gICAgdmFsdWU6IG5ldHdvcmssXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ25ldHdvcmsuZ2V0JyxcbiAgICB2YWx1ZTogbmV0d29yay5nZXQsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29yay5vbkNoYW5nZScsXG4gICAgdmFsdWU6IG5ldHdvcmsub25DaGFuZ2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYmFsYW5jZScsXG4gICAgdmFsdWU6IGJhbGFuY2UsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2JhbGFuY2UuZ2V0JyxcbiAgICB2YWx1ZTogYmFsYW5jZS5nZXQsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYmFsYW5jZS5vbkNoYW5nZScsXG4gICAgdmFsdWU6IGJhbGFuY2Uub25DaGFuZ2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXYWxsZXRJbml0KHdhbGxldEluaXQpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0SW5pdCcsXG4gICAgdmFsdWU6IHdhbGxldEluaXQsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgdmFyIHdhbGxldE5hbWUgPSB3YWxsZXRJbml0LndhbGxldE5hbWUsXG4gICAgICBwcmVmZXJyZWQgPSB3YWxsZXRJbml0LnByZWZlcnJlZCxcbiAgICAgIGxhYmVsID0gd2FsbGV0SW5pdC5sYWJlbCxcbiAgICAgIGljb25TcmMgPSB3YWxsZXRJbml0Lmljb25TcmMsXG4gICAgICBzdmcgPSB3YWxsZXRJbml0LnN2ZyxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHdhbGxldEluaXQsIFtcIndhbGxldE5hbWVcIiwgXCJwcmVmZXJyZWRcIiwgXCJsYWJlbFwiLCBcImljb25TcmNcIiwgXCJzdmdcIl0pO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnd2FsbGV0TmFtZScsICdhcGlLZXknLCAnbmV0d29ya0lkJywgJ2luZnVyYUtleScsICdycGMnLCAnYnJpZGdlJywgJ3ByZWZlcnJlZCcsICdsYWJlbCcsICdpY29uU3JjJywgJ3N2ZycsICdhcHBVcmwnLCAnZW1haWwnLCAncnBjVXJsJywgJ0xlZGdlclRyYW5zcG9ydCcsICdidWlsZEVudicsICdidXR0b25Qb3NpdGlvbicsICdlbmFibGVMb2dnaW5nJywgJ2xvZ2luTWV0aG9kJywgJ2xvZ2luQ29uZmlnJywgJ3Nob3dUb3J1c0J1dHRvbicsICdtb2RhbFppbmRleCcsICdpbnRlZ3JpdHknLCAnd2hpdGVMYWJlbCcsICdhcHBOYW1lJywgJ2FwcExvZ29VcmwnLCAnZW5hYmxlZFZlcmlmaWVycycsICdkaXNhYmxlTm90aWZpY2F0aW9ucycsICdycGNVcmknLCAnd2ViVXJpJywgJ3hzVXJpJywgJ2Jsb2NrZWRQb3B1cFJlZGlyZWN0J10sICd3YWxsZXRJbml0T2JqZWN0Jyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldEluaXQud2FsbGV0TmFtZScsXG4gICAgdmFsdWU6IHdhbGxldE5hbWUsXG4gICAgdHlwZTogJ3N0cmluZydcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldEluaXQucHJlZmVycmVkJyxcbiAgICB2YWx1ZTogcHJlZmVycmVkLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0SW5pdC5sYWJlbCcsXG4gICAgdmFsdWU6IGxhYmVsLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbml0Lmljb25TcmMnLFxuICAgIHZhbHVlOiBpY29uU3JjLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbml0LnN2ZycsXG4gICAgdmFsdWU6IHN2ZyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxudmFyIGFwcCA9IHdyaXRhYmxlKHtcbiAgZGFwcElkOiAnJyxcbiAgbmV0d29ya0lkOiAxLFxuICB2ZXJzaW9uOiAnJyxcbiAgbW9iaWxlRGV2aWNlOiBmYWxzZSxcbiAgb3M6ICcnLFxuICBkYXJrTW9kZTogZmFsc2UsXG4gIHdhbGxldFNlbGVjdEluUHJvZ3Jlc3M6IGZhbHNlLFxuICB3YWxsZXRTZWxlY3RDb21wbGV0ZWQ6IGZhbHNlLFxuICB3YWxsZXRDaGVja0luUHJvZ3Jlc3M6IGZhbHNlLFxuICB3YWxsZXRDaGVja0NvbXBsZXRlZDogZmFsc2UsXG4gIGFjY291bnRTZWxlY3RJblByb2dyZXNzOiBmYWxzZSxcbiAgYXV0b1NlbGVjdFdhbGxldDogJycsXG4gIGNoZWNrTW9kdWxlczogW10sXG4gIHdhbGxldFNlbGVjdERpc3BsYXllZFVJOiBmYWxzZSxcbiAgd2FsbGV0Q2hlY2tEaXNwbGF5ZWRVSTogZmFsc2UsXG4gIGRpc3BsYXlCcmFuZGluZzogZmFsc2Vcbn0pO1xudmFyIHN0YXRlU3luY1N0YXR1cyA9IHtcbiAgYmFsYW5jZTogbnVsbCxcbiAgYWRkcmVzczogbnVsbCxcbiAgbmV0d29yazogbnVsbFxufTtcbnZhciBhZGRyZXNzO1xudmFyIG5ldHdvcms7XG52YXIgYmFsYW5jZTtcbnZhciB3YWxsZXQ7XG52YXIgc3RhdGU7XG52YXIgd2FsbGV0SW50ZXJmYWNlO1xudmFyIGN1cnJlbnRTeW5jZXJJbnRlcnZhbHM7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVTdG9yZXMoKSB7XG4gIGFkZHJlc3MgPSBjcmVhdGVXYWxsZXRTdGF0ZVNsaWNlU3RvcmUoe1xuICAgIHBhcmFtZXRlcjogJ2FkZHJlc3MnLFxuICAgIGluaXRpYWxTdGF0ZTogbnVsbFxuICB9KTtcbiAgbmV0d29yayA9IGNyZWF0ZVdhbGxldFN0YXRlU2xpY2VTdG9yZSh7XG4gICAgcGFyYW1ldGVyOiAnbmV0d29yaycsXG4gICAgaW5pdGlhbFN0YXRlOiBudWxsXG4gIH0pO1xuICBiYWxhbmNlID0gZ2V0X3N0b3JlX3ZhbHVlKGFwcCkuZGFwcElkID8gY3JlYXRlQmFsYW5jZVN0b3JlKG51bGwpIDogY3JlYXRlV2FsbGV0U3RhdGVTbGljZVN0b3JlKHtcbiAgICBwYXJhbWV0ZXI6ICdiYWxhbmNlJyxcbiAgICBpbml0aWFsU3RhdGU6IG51bGwsXG4gICAgaW50ZXJ2YWxTZXR0aW5nOiAxMDAwXG4gIH0pO1xuICB3YWxsZXQgPSB3cml0YWJsZSh7XG4gICAgbmFtZTogbnVsbCxcbiAgICBwcm92aWRlcjogbnVsbCxcbiAgICBjb25uZWN0OiBudWxsLFxuICAgIGluc3RhbmNlOiBudWxsLFxuICAgIGRhc2hib2FyZDogbnVsbCxcbiAgICB0eXBlOiBudWxsXG4gIH0pO1xuICBzdGF0ZSA9IGRlcml2ZWQoW2FkZHJlc3MsIG5ldHdvcmssIGJhbGFuY2UsIHdhbGxldCwgYXBwXSwgZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDUpLFxuICAgICAgICAkYWRkcmVzcyA9IF9yZWY2WzBdLFxuICAgICAgICAkbmV0d29yayA9IF9yZWY2WzFdLFxuICAgICAgICAkYmFsYW5jZSA9IF9yZWY2WzJdLFxuICAgICAgICAkd2FsbGV0ID0gX3JlZjZbM10sXG4gICAgICAgICRhcHAgPSBfcmVmNls0XTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiAkYWRkcmVzcyxcbiAgICAgIG5ldHdvcms6ICRuZXR3b3JrLFxuICAgICAgYmFsYW5jZTogJGJhbGFuY2UsXG4gICAgICB3YWxsZXQ6ICR3YWxsZXQsXG4gICAgICBtb2JpbGVEZXZpY2U6ICRhcHAubW9iaWxlRGV2aWNlLFxuICAgICAgYXBwTmV0d29ya0lkOiAkYXBwLm5ldHdvcmtJZFxuICAgIH07XG4gIH0pO1xuICBjdXJyZW50U3luY2VySW50ZXJ2YWxzID0gW107XG4gIHdhbGxldEludGVyZmFjZSA9IGNyZWF0ZVdhbGxldEludGVyZmFjZVN0b3JlKG51bGwpO1xuICB3YWxsZXRJbnRlcmZhY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBzdG9yZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICAvLyBjbGVhciBhbGwgY3VycmVudCBpbnRlcnZhbHMgaWYgdGhleSBleGlzdFxuICAgICAgY3VycmVudFN5bmNlckludGVydmFscy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY2xlYXIoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGdldF9zdG9yZV92YWx1ZShzdGF0ZSk7IC8vIHJlc2V0IHN0YXRlXG5cbiAgICAgIGN1cnJlbnRTdGF0ZS5iYWxhbmNlICYmIGJhbGFuY2UucmVzZXQoKTtcbiAgICAgIGN1cnJlbnRTdGF0ZS5hZGRyZXNzICYmIGFkZHJlc3MucmVzZXQoKTtcbiAgICAgIGN1cnJlbnRTdGF0ZS5uZXR3b3JrICYmIG5ldHdvcmsucmVzZXQoKTtcblxuICAgICAgaWYgKHdhbGxldEludGVyZmFjZSkge1xuICAgICAgICAvLyBzdGFydCBzeW5jaW5nIHN0YXRlIGFuZCBzYXZlIGludGVydmFsc1xuICAgICAgICBjdXJyZW50U3luY2VySW50ZXJ2YWxzID0gW2FkZHJlc3Muc2V0U3RhdGVTeW5jZXIod2FsbGV0SW50ZXJmYWNlLmFkZHJlc3MpLCBuZXR3b3JrLnNldFN0YXRlU3luY2VyKHdhbGxldEludGVyZmFjZS5uZXR3b3JrKSwgYmFsYW5jZS5zZXRTdGF0ZVN5bmNlcih3YWxsZXRJbnRlcmZhY2UuYmFsYW5jZSldO1xuICAgICAgfVxuXG4gICAgICByZXNldENoZWNrTW9kdWxlcygpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0V2FsbGV0U3RhdGUob3B0aW9ucykge1xuICB3YWxsZXRJbnRlcmZhY2UudXBkYXRlKGZ1bmN0aW9uIChjdXJyZW50SW50ZXJmYWNlKSB7XG4gICAgLy8gbm8gaW50ZXJmYWNlIHRoZW4gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAoIWN1cnJlbnRJbnRlcmZhY2UpIHtcbiAgICAgIHJldHVybiBjdXJyZW50SW50ZXJmYWNlO1xuICAgIH0gLy8gbm8gb3B0aW9ucyBvYmplY3QsIHNvIGRvIGEgZnVsbCByZXNldCBieSBkaXNjb25uZWN0aW5nIGFuZCBzZXR0aW5nIGludGVyZmFjZSB0byBudWxsXG5cblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgd2FsbGV0LnVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgIHByb3ZpZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgY29ubmVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGFzaGJvYXJkOiB1bmRlZmluZWQsXG4gICAgICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRJbnRlcmZhY2UuZGlzY29ubmVjdCAmJiBjdXJyZW50SW50ZXJmYWNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3YWxsZXROYW1lID0gb3B0aW9ucy53YWxsZXROYW1lLFxuICAgICAgICBkaXNjb25uZWN0ZWQgPSBvcHRpb25zLmRpc2Nvbm5lY3RlZDsgLy8gaWYgd2FsbGV0TmFtZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBpbnRlcmZhY2UgbmFtZSB0aGVuIGRvIGEgZnVsbCByZXNldCAoY2hlY2tpbmcgaWYgdG8gZG8gYSBkaXNjb25uZWN0KVxuXG4gICAgaWYgKGN1cnJlbnRJbnRlcmZhY2UubmFtZSA9PT0gd2FsbGV0TmFtZSkge1xuICAgICAgd2FsbGV0LnVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgIHByb3ZpZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgY29ubmVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGFzaGJvYXJkOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgIWRpc2Nvbm5lY3RlZCAmJiBjdXJyZW50SW50ZXJmYWNlLmRpc2Nvbm5lY3QgJiYgY3VycmVudEludGVyZmFjZS5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEludGVyZmFjZTtcbiAgfSk7XG4gIHJlc2V0Q2hlY2tNb2R1bGVzKCk7XG4gIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgd2FsbGV0U2VsZWN0SW5Qcm9ncmVzczogZmFsc2UsXG4gICAgICB3YWxsZXRTZWxlY3RDb21wbGV0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldENoZWNrTW9kdWxlcygpIHtcbiAgdmFyIF9nZXRfc3RvcmVfdmFsdWUgPSBnZXRfc3RvcmVfdmFsdWUoYXBwKSxcbiAgICAgIGNoZWNrTW9kdWxlcyA9IF9nZXRfc3RvcmVfdmFsdWUuY2hlY2tNb2R1bGVzO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoZWNrTW9kdWxlcykpIHtcbiAgICBjaGVja01vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0ucmVzZXQgJiYgbS5yZXNldCgpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhbGxldEludGVyZmFjZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgX3dyaXRhYmxlID0gd3JpdGFibGUoaW5pdGlhbFN0YXRlKSxcbiAgICAgIHN1YnNjcmliZSA9IF93cml0YWJsZS5zdWJzY3JpYmUsXG4gICAgICBfc2V0ID0gX3dyaXRhYmxlLnNldCxcbiAgICAgIHVwZGF0ZSA9IF93cml0YWJsZS51cGRhdGU7XG5cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAgIGlmICh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAgICAgdmFsaWRhdGVXYWxsZXRJbnRlcmZhY2Uod2FsbGV0SW50ZXJmYWNlKTtcbiAgICAgIH1cblxuICAgICAgX3NldCh3YWxsZXRJbnRlcmZhY2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2FsbGV0U3RhdGVTbGljZVN0b3JlKG9wdGlvbnMpIHtcbiAgdmFyIHBhcmFtZXRlciA9IG9wdGlvbnMucGFyYW1ldGVyLFxuICAgICAgaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGUsXG4gICAgICBpbnRlcnZhbFNldHRpbmcgPSBvcHRpb25zLmludGVydmFsU2V0dGluZztcblxuICB2YXIgX3dyaXRhYmxlMiA9IHdyaXRhYmxlKGluaXRpYWxTdGF0ZSksXG4gICAgICBzdWJzY3JpYmUgPSBfd3JpdGFibGUyLnN1YnNjcmliZSxcbiAgICAgIHNldCA9IF93cml0YWJsZTIuc2V0O1xuXG4gIHZhciBjdXJyZW50U3RhdGU7XG4gIHN1YnNjcmliZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICBjdXJyZW50U3RhdGUgPSBzdG9yZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgc2V0KHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZVN5bmNlcjogZnVuY3Rpb24gc2V0U3RhdGVTeW5jZXIoc3RhdGVTeW5jZXIpIHtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdzdGF0ZVN5bmNlcicsXG4gICAgICAgIHZhbHVlOiBzdGF0ZVN5bmNlcixcbiAgICAgICAgdHlwZTogJ29iamVjdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGdldCA9IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICBvbkNoYW5nZSA9IHN0YXRlU3luY2VyLm9uQ2hhbmdlO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogXCJcIi5jb25jYXQocGFyYW1ldGVyLCBcIi5nZXRcIiksXG4gICAgICAgIHZhbHVlOiBnZXQsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6IFwiXCIuY29uY2F0KHBhcmFtZXRlciwgXCIub25DaGFuZ2VcIiksXG4gICAgICAgIHZhbHVlOiBvbkNoYW5nZSxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgc3RhdGVTeW5jU3RhdHVzW3BhcmFtZXRlcl0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIG9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbCB8fCBjdXJyZW50U3RhdGUgIT09IGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICBzZXQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBjcmVhdGVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGVTeW5jU3RhdHVzW3BhcmFtZXRlcl0gPSBnZXQoKS50aGVuKGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgICAgIHN0YXRlU3luY1N0YXR1c1twYXJhbWV0ZXJdID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbCB8fCBjdXJyZW50U3RhdGUgIT09IGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICBpbnRlcnZhbC5zdGF0dXMuYWN0aXZlICYmIHNldChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZ2V0dGluZyBcIi5jb25jYXQocGFyYW1ldGVyLCBcIiBmcm9tIHN0YXRlIHN5bmNlcjogXCIpLmNvbmNhdChlcnIpKTtcbiAgICAgICAgICAgIHN0YXRlU3luY1N0YXR1c1twYXJhbWV0ZXJdID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaW50ZXJ2YWxTZXR0aW5nIHx8IDIwMCk7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhbGFuY2VTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIHN0YXRlU3luY2VyO1xuICB2YXIgZW1pdHRlcjtcbiAgdmFyIGVtaXR0ZXJBZGRyZXNzO1xuXG4gIHZhciBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7fTtcblxuICB2YXIgX2Rlcml2ZWQgPSBkZXJpdmVkKFthZGRyZXNzLCBuZXR3b3JrXSwgZnVuY3Rpb24gKF9yZWY3LCBzZXQpIHtcbiAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMiksXG4gICAgICAgICRhZGRyZXNzID0gX3JlZjhbMF0sXG4gICAgICAgICRuZXR3b3JrID0gX3JlZjhbMV07XG5cbiAgICBpZiAoc3RhdGVTeW5jZXIgJiYgIXN0YXRlU3luY2VyLm9uQ2hhbmdlKSB7XG4gICAgICBpZiAoJGFkZHJlc3MgJiYgJG5ldHdvcmsgJiYgc3RhdGVTeW5jZXIuZ2V0ICYmIHNldCkge1xuICAgICAgICBjYW5jZWwgPSBzeW5jU3RhdGVXaXRoVGltZW91dCh7XG4gICAgICAgICAgZ2V0U3RhdGU6IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICBzZXRTdGF0ZTogc2V0LFxuICAgICAgICAgIHRpbWVvdXQ6IDIwMDAsXG4gICAgICAgICAgY3VycmVudEJhbGFuY2U6IGdldF9zdG9yZV92YWx1ZShiYWxhbmNlKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZW1pdHRlckFkZHJlc3MgIT09ICRhZGRyZXNzKSB7XG4gICAgICAgICAgdmFyIF9ibG9ja25hdGl2ZSA9IGdldEJsb2NrbmF0aXZlKCk7IC8vIHVuc3Vic2NyaWJlIGZyb20gcHJldmlvdXMgYWRkcmVzc1xuXG5cbiAgICAgICAgICBpZiAoZW1pdHRlckFkZHJlc3MpIHtcbiAgICAgICAgICAgIF9ibG9ja25hdGl2ZS51bnN1YnNjcmliZShlbWl0dGVyQWRkcmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW1pdHRlciA9IF9ibG9ja25hdGl2ZS5hY2NvdW50KCRhZGRyZXNzKS5lbWl0dGVyO1xuICAgICAgICAgIGVtaXR0ZXIub24oJ3R4Q29uZmlybWVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlU3luY2VyLmdldCkge1xuICAgICAgICAgICAgICBjYW5jZWwgPSBzeW5jU3RhdGVXaXRoVGltZW91dCh7XG4gICAgICAgICAgICAgICAgZ2V0U3RhdGU6IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZTogc2V0LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDIwMDAsXG4gICAgICAgICAgICAgICAgY3VycmVudEJhbGFuY2U6IGdldF9zdG9yZV92YWx1ZShiYWxhbmNlKSxcbiAgICAgICAgICAgICAgICBwb2xsU3RhcnQ6IERhdGUubm93KClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbWl0dGVyQWRkcmVzcyA9ICRhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVtaXR0ZXJBZGRyZXNzICYmICEkYWRkcmVzcykge1xuICAgICAgICB2YXIgX2Jsb2NrbmF0aXZlMiA9IGdldEJsb2NrbmF0aXZlKCk7IC8vIHVuc3Vic2NyaWJlIGZyb20gcHJldmlvdXMgYWRkcmVzc1xuXG5cbiAgICAgICAgX2Jsb2NrbmF0aXZlMi51bnN1YnNjcmliZShlbWl0dGVyQWRkcmVzcyk7IC8vIG5vIGFkZHJlc3MsIHNvIHNldCBiYWxhbmNlIHRvIHVuZGVmaW5lZFxuXG5cbiAgICAgICAgc2V0ICYmIHNldCh1bmRlZmluZWQpO1xuICAgICAgICBlbWl0dGVyQWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQoaW5pdGlhbFN0YXRlKTtcbiAgfSksXG4gICAgICBzdWJzY3JpYmUgPSBfZGVyaXZlZC5zdWJzY3JpYmU7XG5cbiAgdmFyIGN1cnJlbnRTdGF0ZTtcbiAgc3Vic2NyaWJlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIGN1cnJlbnRTdGF0ZSA9IHN0b3JlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZVN5bmNlcjogZnVuY3Rpb24gc2V0U3RhdGVTeW5jZXIoc3luY2VyKSB7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnc3luY2VyJyxcbiAgICAgICAgdmFsdWU6IHN5bmNlcixcbiAgICAgICAgdHlwZTogJ29iamVjdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGdldCA9IHN5bmNlci5nZXQsXG4gICAgICAgICAgb25DaGFuZ2UgPSBzeW5jZXIub25DaGFuZ2U7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnYmFsYW5jZS5nZXQnLFxuICAgICAgICB2YWx1ZTogZ2V0LFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnYmFsYW5jZS5vbkNoYW5nZScsXG4gICAgICAgIHZhbHVlOiBvbkNoYW5nZSxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc3RhdGVTeW5jZXIgPSBzeW5jZXI7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcmVzZXQ6IGNhbmNlbFxuICB9O1xufVxuXG5mdW5jdGlvbiBzeW5jU3RhdGVXaXRoVGltZW91dChvcHRpb25zKSB7XG4gIHZhciBnZXRTdGF0ZSA9IG9wdGlvbnMuZ2V0U3RhdGUsXG4gICAgICBzZXRTdGF0ZSA9IG9wdGlvbnMuc2V0U3RhdGUsXG4gICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0LFxuICAgICAgY3VycmVudEJhbGFuY2UgPSBvcHRpb25zLmN1cnJlbnRCYWxhbmNlLFxuICAgICAgcG9sbFN0YXJ0ID0gb3B0aW9ucy5wb2xsU3RhcnQ7XG5cbiAgaWYgKHBvbGxTdGFydCAmJiBEYXRlLm5vdygpIC0gcG9sbFN0YXJ0ID4gMjUwMDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gIH1cblxuICB2YXIgcHJvbSA9IG1ha2VDYW5jZWxhYmxlKGdldFN0YXRlKCkpO1xuICBzdGF0ZVN5bmNTdGF0dXMuYmFsYW5jZSA9IHByb207XG4gIHByb20udGhlbiggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0ID09PSBjdXJyZW50QmFsYW5jZSAmJiBwb2xsU3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gd2FpdCQxKDM1MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgc3luY1N0YXRlV2l0aFRpbWVvdXQob3B0aW9ucyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgc3RhdGVTeW5jU3RhdHVzLmJhbGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICBzZXRTdGF0ZShyZXN1bHQpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gzKSB7XG4gICAgICByZXR1cm4gX3JlZjkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgIHN0YXRlU3luY1N0YXR1cy5iYWxhbmNlID0gbnVsbDtcbiAgfSk7XG4gIHZhciB0aW1lZE91dCA9IHdhaXQkMSh0aW1lb3V0KTtcbiAgdGltZWRPdXQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcHJvbS5jYW5jZWwoKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb20uY2FuY2VsKCk7XG4gIH07XG59XG4vKiBzcmMvZWxlbWVudHMvQnJhbmRpbmcuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS0xNW05dXA2LXN0eWxlXCI7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gXCIuYm4tYnJhbmRpbmcuc3ZlbHRlLTE1bTl1cDZ7Zm9udC1zaXplOjAuNzVyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDttYXJnaW46MC40cmVtO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7YWxpZ24taXRlbXM6Y2VudGVyfXNwYW4uc3ZlbHRlLTE1bTl1cDZ7b3BhY2l0eTowLjN9YS5zdmVsdGUtMTVtOXVwNntjb2xvcjppbmhlcml0O2Rpc3BsYXk6ZmxleDttYXJnaW4tbGVmdDowLjI1cmVtO2FsaWduLWl0ZW1zOmNlbnRlcn0uYm4tbG9nby5zdmVsdGUtMTVtOXVwNntoZWlnaHQ6MS4xcmVtO21hcmdpbi1sZWZ0OjAuMjVyZW07bWFyZ2luLWJvdHRvbTowLjFyZW19c3ZnLnN2ZWx0ZS0xNW05dXA2e2hlaWdodDoxMDAlO3dpZHRoOmF1dG99XCI7XG4gIGFwcGVuZChkb2N1bWVudC5oZWFkLCBzdHlsZSk7XG59IC8vICg3Njo2KSB7OmVsc2V9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2Vsc2VfYmxvY2soY3R4KSB7XG4gIHZhciBzdmc7XG4gIHZhciBnO1xuICB2YXIgcGF0aDA7XG4gIHZhciBwYXRoMTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgc3ZnID0gc3ZnX2VsZW1lbnQoXCJzdmdcIik7XG4gICAgICBnID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgcGF0aDAgPSBzdmdfZWxlbWVudChcInBhdGhcIik7XG4gICAgICBwYXRoMSA9IHN2Z19lbGVtZW50KFwicGF0aFwiKTtcbiAgICAgIGF0dHIocGF0aDAsIFwiZFwiLCBcIm0xLjM1NDczNjU0IDI1LjI2OTUyNjhcXG4gICAgICAgICAgICAgIDQxLjY4NTE1Nzg2LTI0LjIxNzcxNzkyYy41NjQ3MDQ0LS4zMjgwNzQ4MiAxLjI2MTk4MzYtLjMyODA3Nzk1XFxuICAgICAgICAgICAgICAxLjgyNjY5MDktLjAwMDAwODIxbDE5LjkyNzUwMTNcXG4gICAgICAgICAgICAgIDExLjU3Njk4OTIzYy41NjM1OTM4LjMyNzQyMjguOTA4ODAyNi45MzE0ODI2LjkwNDgwOTRcXG4gICAgICAgICAgICAgIDEuNTgzMjcwN2wtLjE1MDExMTIgMjQuNTAxNzc1NiAyMC44NDcyNzE2XFxuICAgICAgICAgICAgICAxMi4xMTEzMzQ4Yy41NjAxNTI1LjMyNTQyMzYuOTA0ODQzNC45MjQzMTExLjkwNDg0MzRcXG4gICAgICAgICAgICAgIDEuNTcyMTMxN3Y0OC40NTYwMTIzYzAgLjY0NzgyNS0uMzQ0Njk1MyAxLjI0NjcxNS0uOTA0ODUzN1xcbiAgICAgICAgICAgICAgMS41NzIxMzhsLTQxLjY4MzUwOTJcXG4gICAgICAgICAgICAgIDI0LjIxNTg5NWMtLjU2NTU3MzEuMzI4NTY3LTEuMjY0MDQ0OC4zMjgwMjMtMS44MjkxMDUyLS4wMDE0MjZsLTQxLjUzMTExOTctMjQuMjE0MDFjLS41NTg3NzY0LS4zMjU3ODUtLjkwMjQwNDc2LS45MjM4OTktLjkwMjQwNDc2LTEuNTcwNzEydi00OS41MDUyNTgtMjQuNTA4MjkxN2MwLS42NDc4MTQ3LjM0NDY4NDczLTEuMjQ2Njk3OC45MDQ4MjkzLTEuNTcyMTIzNXpcIik7XG4gICAgICBhdHRyKHBhdGgxLCBcImRcIiwgXCJtMjIuMDQyODQ1MSAxMTQuNDQyODI0di0yNS4yNzMxMTQxbC0yMS41OTI4NDc4OC0xMi41NDQ5Mzg4XFxuICAgICAgICAgICAgICA0Mi43NTAxNDI4OCAyNC42NTUxOTA5Yy41NjQ4NTA3LjMyNTc2NSAxLjI2MDg5OC4zMjQxMDlcXG4gICAgICAgICAgICAgIDEuODI0MTkyNi0uMDA0MzM5bDQyLjI3NjY1NzEtMjQuNjUwODUxOS0yMS41OTU1NDczXFxuICAgICAgICAgICAgICAxMi42MzcwMDg0di0yNC4yMjQ4Mjc2YzAtLjY0ODgwMTItLjM0NTcyNjYtMS4yNDg0NDA1LS45MDcyMTg3LTEuNTczNTA5MmwtMjAuOTIyMjgwNC0xMi4xMTI2ODgzXFxuICAgICAgICAgICAgICAyMS42NzI5MzE0LTEyLjYzNzAwODQtNDIuNDUyNTk1OFxcbiAgICAgICAgICAgICAgMjQuNDc2MzM1MmMtLjU1NDUxNTkuMzE5NzA5OS0xLjIzNjg2NS4zMjE4OTAyLTEuNzkzNDEyNy4wMDU3MzAzbC0yMC44NTI4NjkwOC0xMS44NDU5NTk4XCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlXCIsIFwiIzAwMFwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcInN0cm9rZS13aWR0aFwiLCBcIjIuNzA3OTNcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIik7XG4gICAgICBhdHRyKGcsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDEuODE4MTgyIC45MDkwOTEpXCIpO1xuICAgICAgYXR0cihzdmcsIFwiaGVpZ2h0XCIsIFwiMTMwXCIpO1xuICAgICAgYXR0cihzdmcsIFwidmlld0JveFwiLCBcIjAgMCA5MSAxMzBcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ3aWR0aFwiLCBcIjkxXCIpO1xuICAgICAgYXR0cihzdmcsIFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICAgIGF0dHIoc3ZnLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE1bTl1cDZcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzdmcsIGFuY2hvcik7XG4gICAgICBhcHBlbmQoc3ZnLCBnKTtcbiAgICAgIGFwcGVuZChnLCBwYXRoMCk7XG4gICAgICBhcHBlbmQoZywgcGF0aDEpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChzdmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDQ4OjYpIHsjaWYgZGFya01vZGV9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrKGN0eCkge1xuICB2YXIgc3ZnO1xuICB2YXIgZztcbiAgdmFyIHBhdGgwO1xuICB2YXIgcGF0aDE7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHN2ZyA9IHN2Z19lbGVtZW50KFwic3ZnXCIpO1xuICAgICAgZyA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIHBhdGgwID0gc3ZnX2VsZW1lbnQoXCJwYXRoXCIpO1xuICAgICAgcGF0aDEgPSBzdmdfZWxlbWVudChcInBhdGhcIik7XG4gICAgICBhdHRyKHBhdGgwLCBcImRcIiwgXCJtMS4zNTQ3MzY1NCAyNS4yNjk1MjY4XFxuICAgICAgICAgICAgICA0MS42ODUxNTc4Ni0yNC4yMTc3MTc5MmMuNTY0NzA0NC0uMzI4MDc0ODIgMS4yNjE5ODM2LS4zMjgwNzc5NVxcbiAgICAgICAgICAgICAgMS44MjY2OTA5LS4wMDAwMDgyMWwxOS45Mjc1MDEzXFxuICAgICAgICAgICAgICAxMS41NzY5ODkyM2MuNTYzNTkzOC4zMjc0MjI4LjkwODgwMjYuOTMxNDgyNi45MDQ4MDk0XFxuICAgICAgICAgICAgICAxLjU4MzI3MDdsLS4xNTAxMTEyIDI0LjUwMTc3NTYgMjAuODQ3MjcxNlxcbiAgICAgICAgICAgICAgMTIuMTExMzM0OGMuNTYwMTUyNS4zMjU0MjM2LjkwNDg0MzQuOTI0MzExMS45MDQ4NDM0XFxuICAgICAgICAgICAgICAxLjU3MjEzMTd2NDguNDU2MDEyM2MwIC42NDc4MjUtLjM0NDY5NTMgMS4yNDY3MTUtLjkwNDg1MzdcXG4gICAgICAgICAgICAgIDEuNTcyMTM4bC00MS42ODM1MDkyXFxuICAgICAgICAgICAgICAyNC4yMTU4OTVjLS41NjU1NzMxLjMyODU2Ny0xLjI2NDA0NDguMzI4MDIzLTEuODI5MTA1Mi0uMDAxNDI2bC00MS41MzExMTk3LTI0LjIxNDAxYy0uNTU4Nzc2NC0uMzI1Nzg1LS45MDI0MDQ3Ni0uOTIzODk5LS45MDI0MDQ3Ni0xLjU3MDcxMnYtNDkuNTA1MjU4LTI0LjUwODI5MTdjMC0uNjQ3ODE0Ny4zNDQ2ODQ3My0xLjI0NjY5NzguOTA0ODI5My0xLjU3MjEyMzV6XCIpO1xuICAgICAgYXR0cihwYXRoMSwgXCJkXCIsIFwibTIyLjA0Mjg0NTEgMTE0LjQ0MjgyNHYtMjUuMjczMTE0MWwtMjEuNTkyODQ3ODgtMTIuNTQ0OTM4OFxcbiAgICAgICAgICAgICAgNDIuNzUwMTQyODggMjQuNjU1MTkwOWMuNTY0ODUwNy4zMjU3NjUgMS4yNjA4OTguMzI0MTA5XFxuICAgICAgICAgICAgICAxLjgyNDE5MjYtLjAwNDMzOWw0Mi4yNzY2NTcxLTI0LjY1MDg1MTktMjEuNTk1NTQ3M1xcbiAgICAgICAgICAgICAgMTIuNjM3MDA4NHYtMjQuMjI0ODI3NmMwLS42NDg4MDEyLS4zNDU3MjY2LTEuMjQ4NDQwNS0uOTA3MjE4Ny0xLjU3MzUwOTJsLTIwLjkyMjI4MDQtMTIuMTEyNjg4M1xcbiAgICAgICAgICAgICAgMjEuNjcyOTMxNC0xMi42MzcwMDg0LTQyLjQ1MjU5NThcXG4gICAgICAgICAgICAgIDI0LjQ3NjMzNTJjLS41NTQ1MTU5LjMxOTcwOTktMS4yMzY4NjUuMzIxODkwMi0xLjc5MzQxMjcuMDA1NzMwM2wtMjAuODUyODY5MDgtMTEuODQ1OTU5OFwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcInN0cm9rZVwiLCBcIiNmZmZcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJzdHJva2Utd2lkdGhcIiwgXCIyLjcwNzkzXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgICAgYXR0cihnLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgxLjgxODE4MiAuOTA5MDkxKVwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcImhlaWdodFwiLCBcIjEzMFwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcInZpZXdCb3hcIiwgXCIwIDAgOTEgMTMwXCIpO1xuICAgICAgYXR0cihzdmcsIFwid2lkdGhcIiwgXCI5MVwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAgICBhdHRyKHN2ZywgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNW05dXA2XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgc3ZnLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKHN2ZywgZyk7XG4gICAgICBhcHBlbmQoZywgcGF0aDApO1xuICAgICAgYXBwZW5kKGcsIHBhdGgxKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goc3ZnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudChjdHgpIHtcbiAgdmFyIGRpdjE7XG4gIHZhciBzcGFuMDtcbiAgdmFyIHQxO1xuICB2YXIgYTtcbiAgdmFyIHNwYW4xO1xuICB2YXIgdDM7XG4gIHZhciBkaXYwO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9ibG9ja190eXBlKGN0eCwgZGlydHkpIHtcbiAgICBpZiAoXG4gICAgLypkYXJrTW9kZSovXG4gICAgY3R4WzBdKSByZXR1cm4gY3JlYXRlX2lmX2Jsb2NrO1xuICAgIHJldHVybiBjcmVhdGVfZWxzZV9ibG9jaztcbiAgfVxuXG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICB2YXIgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2MSA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBzcGFuMCA9IGVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3BhbjAudGV4dENvbnRlbnQgPSBcIlBvd2VyZWQgYnlcIjtcbiAgICAgIHQxID0gc3BhY2UoKTtcbiAgICAgIGEgPSBlbGVtZW50KFwiYVwiKTtcbiAgICAgIHNwYW4xID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuMS50ZXh0Q29udGVudCA9IFwiQmxvY2tuYXRpdmVcIjtcbiAgICAgIHQzID0gc3BhY2UoKTtcbiAgICAgIGRpdjAgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgYXR0cihzcGFuMCwgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNW05dXA2XCIpO1xuICAgICAgYXR0cihzcGFuMSwgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNW05dXA2XCIpO1xuICAgICAgYXR0cihkaXYwLCBcImNsYXNzXCIsIFwiYm4tbG9nbyBzdmVsdGUtMTVtOXVwNlwiKTtcbiAgICAgIGF0dHIoYSwgXCJocmVmXCIsIFwiaHR0cHM6Ly9odWJzLmx5L0gwcWgyZzEwXCIpO1xuICAgICAgYXR0cihhLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jbGlja2FibGUgc3ZlbHRlLTE1bTl1cDZcIik7XG4gICAgICBhdHRyKGEsIFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xuICAgICAgYXR0cihhLCBcInJlbFwiLCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XG4gICAgICBhdHRyKGRpdjEsIFwiY2xhc3NcIiwgXCJibi1icmFuZGluZyBzdmVsdGUtMTVtOXVwNlwiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGRpdjEsIGFuY2hvcik7XG4gICAgICBhcHBlbmQoZGl2MSwgc3BhbjApO1xuICAgICAgYXBwZW5kKGRpdjEsIHQxKTtcbiAgICAgIGFwcGVuZChkaXYxLCBhKTtcbiAgICAgIGFwcGVuZChhLCBzcGFuMSk7XG4gICAgICBhcHBlbmQoYSwgdDMpO1xuICAgICAgYXBwZW5kKGEsIGRpdjApO1xuICAgICAgaWZfYmxvY2subShkaXYwLCBudWxsKTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBfcmVmMTApIHtcbiAgICAgIHZhciBfcmVmMTEgPSBfc2xpY2VkVG9BcnJheShfcmVmMTAsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjExWzBdO1xuXG4gICAgICBpZiAoY3VycmVudF9ibG9ja190eXBlICE9PSAoY3VycmVudF9ibG9ja190eXBlID0gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4KSkpIHtcbiAgICAgICAgaWZfYmxvY2suZCgxKTtcbiAgICAgICAgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcblxuICAgICAgICBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgICBpZl9ibG9jay5jKCk7XG4gICAgICAgICAgaWZfYmxvY2subShkaXYwLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goZGl2MSk7XG4gICAgICBpZl9ibG9jay5kKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZSgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgZGFya01vZGUgPSAkJHByb3BzLmRhcmtNb2RlO1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJkYXJrTW9kZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgwLCBkYXJrTW9kZSA9ICQkcHJvcHMuZGFya01vZGUpO1xuICB9O1xuXG4gIHJldHVybiBbZGFya01vZGVdO1xufVxuXG52YXIgQnJhbmRpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyYW5kaW5nLCBfU3ZlbHRlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJyYW5kaW5nKTtcblxuICBmdW5jdGlvbiBCcmFuZGluZyhvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5kaW5nKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xNW05dXA2LXN0eWxlXCIpKSBhZGRfY3NzKCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGRhcmtNb2RlOiAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEJyYW5kaW5nO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvTW9kYWwuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkMSgpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLXJudG9naC1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiYXNpZGUuc3ZlbHRlLXJudG9naHtkaXNwbGF5OmZsZXg7Zm9udC1mYW1pbHk6J0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWY7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cG9zaXRpb246Zml4ZWQ7Zm9udC1zaXplOjE2cHg7dG9wOjA7bGVmdDowO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOnJnYmEoMCwgMCwgMCwgMC4zKX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MjBweCl7YXNpZGUuc3ZlbHRlLXJudG9naHtmb250LXNpemU6MTRweH19c2VjdGlvbi5zdmVsdGUtcm50b2doe2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpjb250ZW50LWJveDtiYWNrZ3JvdW5kOiNmZmZmZmY7Ym9yZGVyLXJhZGl1czoxMHB4O2JveC1zaGFkb3c6MCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEpO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7cGFkZGluZzoxLjMzZW07cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO21heC13aWR0aDozN2VtO2NvbG9yOiM0YTRhNGF9ZGl2LnN2ZWx0ZS1ybnRvZ2h7aGVpZ2h0OjAuNjZlbTtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjAuMjVlbTt0b3A6MS4zM2VtO3JpZ2h0OjEuMzNlbTtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O2JvcmRlci1yYWRpdXM6NXB4O3RyYW5zaXRpb246YmFja2dyb3VuZCAyMDBtcyBlYXNlLWluLW91dDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9ZGl2LnN2ZWx0ZS1ybnRvZ2g6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZDojZWVlZWVlfXN2Zy5zdmVsdGUtcm50b2doe3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHh9LmJuLW9uYm9hcmQtZGFyay1tb2RlLWNsb3NlLWJhY2tncm91bmQuc3ZlbHRlLXJudG9naDpob3ZlcntiYWNrZ3JvdW5kOiMwMDIyMmN9Lm5vLXBhZGRpbmctYnJhbmRpbmcuc3ZlbHRlLXJudG9naHtwYWRkaW5nLWJvdHRvbTowfVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoOTU6NCkgeyNpZiAkYXBwLmRpc3BsYXlCcmFuZGluZ31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMShjdHgpIHtcbiAgdmFyIGJyYW5kaW5nO1xuICB2YXIgY3VycmVudDtcbiAgYnJhbmRpbmcgPSBuZXcgQnJhbmRpbmcoe1xuICAgIHByb3BzOiB7XG4gICAgICBkYXJrTW9kZTpcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGFya01vZGVcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGJyYW5kaW5nLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChicmFuZGluZywgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBicmFuZGluZ19jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDgpIGJyYW5kaW5nX2NoYW5nZXMuZGFya01vZGUgPVxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFszXS5kYXJrTW9kZTtcbiAgICAgIGJyYW5kaW5nLiRzZXQoYnJhbmRpbmdfY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihicmFuZGluZy4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChicmFuZGluZy4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGJyYW5kaW5nLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDk4OjQpIHsjaWYgY2xvc2VhYmxlfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQxKGN0eCkge1xuICB2YXIgZGl2O1xuICB2YXIgc3ZnO1xuICB2YXIgZzA7XG4gIHZhciBwYXRoO1xuICB2YXIgZzE7XG4gIHZhciBnMjtcbiAgdmFyIGczO1xuICB2YXIgZzQ7XG4gIHZhciBnNTtcbiAgdmFyIGc2O1xuICB2YXIgZzc7XG4gIHZhciBnODtcbiAgdmFyIGc5O1xuICB2YXIgZzEwO1xuICB2YXIgZzExO1xuICB2YXIgZzEyO1xuICB2YXIgZzEzO1xuICB2YXIgZzE0O1xuICB2YXIgZzE1O1xuICB2YXIgc3ZnX2ZpbGxfdmFsdWU7XG4gIHZhciBtb3VudGVkO1xuICB2YXIgZGlzcG9zZTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIHN2ZyA9IHN2Z19lbGVtZW50KFwic3ZnXCIpO1xuICAgICAgZzAgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBwYXRoID0gc3ZnX2VsZW1lbnQoXCJwYXRoXCIpO1xuICAgICAgZzEgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnMiA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGczID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzQgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnNSA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGc2ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzcgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnOCA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGc5ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzEwID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzExID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzEyID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzEzID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzE0ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzE1ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgYXR0cihwYXRoLCBcImRcIiwgXCJNMjguMjI4LDIzLjk4Nkw0Ny4wOTIsNS4xMjJjMS4xNzItMS4xNzEsMS4xNzItMy4wNzEsMC00LjI0MmMtMS4xNzItMS4xNzItMy4wNy0xLjE3Mi00LjI0MiwwTDIzLjk4NiwxOS43NDRMNS4xMjEsMC44OFxcbiAgICAgICAgICAgICAgYy0xLjE3Mi0xLjE3Mi0zLjA3LTEuMTcyLTQuMjQyLDBjLTEuMTcyLDEuMTcxLTEuMTcyLDMuMDcxLDAsNC4yNDJsMTguODY1LDE4Ljg2NEwwLjg3OSw0Mi44NWMtMS4xNzIsMS4xNzEtMS4xNzIsMy4wNzEsMCw0LjI0MlxcbiAgICAgICAgICAgICAgQzEuNDY1LDQ3LjY3NywyLjIzMyw0Ny45NywzLDQ3Ljk3czEuNTM1LTAuMjkzLDIuMTIxLTAuODc5bDE4Ljg2NS0xOC44NjRMNDIuODUsNDcuMDkxYzAuNTg2LDAuNTg2LDEuMzU0LDAuODc5LDIuMTIxLDAuODc5XFxuICAgICAgICAgICAgICBzMS41MzUtMC4yOTMsMi4xMjEtMC44NzljMS4xNzItMS4xNzEsMS4xNzItMy4wNzEsMC00LjI0MkwyOC4yMjgsMjMuOTg2elwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ4XCIsIFwiMHB4XCIpO1xuICAgICAgYXR0cihzdmcsIFwieVwiLCBcIjBweFwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcInZpZXdCb3hcIiwgXCIwIDAgNDcuOTcxIDQ3Ljk3MVwiKTtcbiAgICAgIHNldF9zdHlsZShzdmcsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJuZXcgMCAwIDQ3Ljk3MSA0Ny45NzFcIik7XG4gICAgICBzZXRfc3R5bGUoc3ZnLCBcInRyYW5zaXRpb25cIiwgXCJmaWxsIDE1MG1zXFxuICAgICAgICAgIGVhc2UtaW4tb3V0XCIpO1xuICAgICAgYXR0cihzdmcsIFwiZmlsbFwiLCBzdmdfZmlsbF92YWx1ZSA9XG4gICAgICAvKmNsb3NlSG92ZXJlZCovXG4gICAgICBjdHhbMl0gP1xuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFszXS5kYXJrTW9kZSA/IFwiI2ZmZmZmZlwiIDogXCIjNGE0YTRhXCIgOiBcIiM5QjlCOUJcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ4bWw6c3BhY2VcIiwgXCJwcmVzZXJ2ZVwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcImNsYXNzXCIsIFwic3ZlbHRlLXJudG9naFwiKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1jb250ZW50LWNsb3NlIHN2ZWx0ZS1ybnRvZ2hcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWNsb3NlLWJhY2tncm91bmRcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGFya01vZGUpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGRpdiwgc3ZnKTtcbiAgICAgIGFwcGVuZChzdmcsIGcwKTtcbiAgICAgIGFwcGVuZChnMCwgcGF0aCk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMSk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMik7XG4gICAgICBhcHBlbmQoc3ZnLCBnMyk7XG4gICAgICBhcHBlbmQoc3ZnLCBnNCk7XG4gICAgICBhcHBlbmQoc3ZnLCBnNSk7XG4gICAgICBhcHBlbmQoc3ZnLCBnNik7XG4gICAgICBhcHBlbmQoc3ZnLCBnNyk7XG4gICAgICBhcHBlbmQoc3ZnLCBnOCk7XG4gICAgICBhcHBlbmQoc3ZnLCBnOSk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMTApO1xuICAgICAgYXBwZW5kKHN2ZywgZzExKTtcbiAgICAgIGFwcGVuZChzdmcsIGcxMik7XG4gICAgICBhcHBlbmQoc3ZnLCBnMTMpO1xuICAgICAgYXBwZW5kKHN2ZywgZzE0KTtcbiAgICAgIGFwcGVuZChzdmcsIGcxNSk7XG5cbiAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICBkaXNwb3NlID0gW2xpc3RlbihkaXYsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc19mdW5jdGlvbihcbiAgICAgICAgICAvKmNsb3NlTW9kYWwqL1xuICAgICAgICAgIGN0eFswXSkpXG4gICAgICAgICAgICAvKmNsb3NlTW9kYWwqL1xuICAgICAgICAgICAgY3R4WzBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pLCBsaXN0ZW4oZGl2LCBcIm1vdXNlZW50ZXJcIixcbiAgICAgICAgLyptb3VzZWVudGVyX2hhbmRsZXIqL1xuICAgICAgICBjdHhbNl0pLCBsaXN0ZW4oZGl2LCBcIm1vdXNlbGVhdmVcIixcbiAgICAgICAgLyptb3VzZWxlYXZlX2hhbmRsZXIqL1xuICAgICAgICBjdHhbN10pXTtcbiAgICAgICAgbW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKG5ld19jdHgsIGRpcnR5KSB7XG4gICAgICBjdHggPSBuZXdfY3R4O1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypjbG9zZUhvdmVyZWQsICRhcHAqL1xuICAgICAgMTIgJiYgc3ZnX2ZpbGxfdmFsdWUgIT09IChzdmdfZmlsbF92YWx1ZSA9XG4gICAgICAvKmNsb3NlSG92ZXJlZCovXG4gICAgICBjdHhbMl0gP1xuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFszXS5kYXJrTW9kZSA/IFwiI2ZmZmZmZlwiIDogXCIjNGE0YTRhXCIgOiBcIiM5QjlCOUJcIikpIHtcbiAgICAgICAgYXR0cihzdmcsIFwiZmlsbFwiLCBzdmdfZmlsbF92YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgOCkge1xuICAgICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWNsb3NlLWJhY2tncm91bmRcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzNdLmRhcmtNb2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goZGl2KTtcbiAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHJ1bl9hbGwoZGlzcG9zZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnQkMShjdHgpIHtcbiAgdmFyIGFzaWRlO1xuICB2YXIgc2VjdGlvbjtcbiAgdmFyIHQwO1xuICB2YXIgdDE7XG4gIHZhciBhc2lkZV90cmFuc2l0aW9uO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIG1vdW50ZWQ7XG4gIHZhciBkaXNwb3NlO1xuICB2YXIgZGVmYXVsdF9zbG90X3RlbXBsYXRlID1cbiAgLyokJHNsb3RzKi9cbiAgY3R4WzVdW1wiZGVmYXVsdFwiXTtcbiAgdmFyIGRlZmF1bHRfc2xvdCA9IGNyZWF0ZV9zbG90KGRlZmF1bHRfc2xvdF90ZW1wbGF0ZSwgY3R4LFxuICAvKiQkc2NvcGUqL1xuICBjdHhbNF0sIG51bGwpO1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyokYXBwKi9cbiAgY3R4WzNdLmRpc3BsYXlCcmFuZGluZyAmJiBjcmVhdGVfaWZfYmxvY2tfMShjdHgpO1xuICB2YXIgaWZfYmxvY2sxID1cbiAgLypjbG9zZWFibGUqL1xuICBjdHhbMV0gJiYgY3JlYXRlX2lmX2Jsb2NrJDEoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgYXNpZGUgPSBlbGVtZW50KFwiYXNpZGVcIik7XG4gICAgICBzZWN0aW9uID0gZWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuYygpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQxID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBhdHRyKHNlY3Rpb24sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsLWNvbnRlbnQgc3ZlbHRlLXJudG9naFwiKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhzZWN0aW9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlXCIsXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzNdLmRhcmtNb2RlKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhzZWN0aW9uLCBcIm5vLXBhZGRpbmctYnJhbmRpbmdcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGlzcGxheUJyYW5kaW5nKTtcbiAgICAgIGF0dHIoYXNpZGUsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsIHN2ZWx0ZS1ybnRvZ2hcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBhc2lkZSwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChhc2lkZSwgc2VjdGlvbik7XG5cbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIHtcbiAgICAgICAgZGVmYXVsdF9zbG90Lm0oc2VjdGlvbiwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MSk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgZGlzcG9zZSA9IFtsaXN0ZW4oc2VjdGlvbiwgXCJjbGlja1wiLCBjbGlja19oYW5kbGVyKSwgbGlzdGVuKGFzaWRlLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oXG4gICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICBjdHhbMF0pKVxuICAgICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICAgIGN0eFswXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KV07XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBfcmVmMTIpIHtcbiAgICAgIHZhciBfcmVmMTMgPSBfc2xpY2VkVG9BcnJheShfcmVmMTIsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjEzWzBdO1xuXG4gICAgICBjdHggPSBuZXdfY3R4O1xuXG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSB7XG4gICAgICAgIGlmIChkZWZhdWx0X3Nsb3QucCAmJiBkaXJ0eSAmXG4gICAgICAgIC8qJCRzY29wZSovXG4gICAgICAgIDE2KSB7XG4gICAgICAgICAgdXBkYXRlX3Nsb3QoZGVmYXVsdF9zbG90LCBkZWZhdWx0X3Nsb3RfdGVtcGxhdGUsIGN0eCxcbiAgICAgICAgICAvKiQkc2NvcGUqL1xuICAgICAgICAgIGN0eFs0XSwgZGlydHksIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGlzcGxheUJyYW5kaW5nKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgICBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyokYXBwKi9cbiAgICAgICAgICA4KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IGNyZWF0ZV9pZl9ibG9ja18xKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgaWZfYmxvY2swLm0oc2VjdGlvbiwgdDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMCkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKmNsb3NlYWJsZSovXG4gICAgICBjdHhbMV0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMS5wKGN0eCwgZGlydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9jayQxKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICBpZl9ibG9jazEubShzZWN0aW9uLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgaWZfYmxvY2sxLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrMSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgOCkge1xuICAgICAgICB0b2dnbGVfY2xhc3Moc2VjdGlvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZVwiLFxuICAgICAgICAvKiRhcHAqL1xuICAgICAgICBjdHhbM10uZGFya01vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDgpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKHNlY3Rpb24sIFwibm8tcGFkZGluZy1icmFuZGluZ1wiLFxuICAgICAgICAvKiRhcHAqL1xuICAgICAgICBjdHhbM10uZGlzcGxheUJyYW5kaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGRlZmF1bHRfc2xvdCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazApO1xuICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXNpZGVfdHJhbnNpdGlvbikgYXNpZGVfdHJhbnNpdGlvbiA9IGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24oYXNpZGUsIGZhZGUsIHt9LCB0cnVlKTtcbiAgICAgICAgYXNpZGVfdHJhbnNpdGlvbi5ydW4oMSk7XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoZGVmYXVsdF9zbG90LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazApO1xuICAgICAgaWYgKCFhc2lkZV90cmFuc2l0aW9uKSBhc2lkZV90cmFuc2l0aW9uID0gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihhc2lkZSwgZmFkZSwge30sIGZhbHNlKTtcbiAgICAgIGFzaWRlX3RyYW5zaXRpb24ucnVuKDApO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChhc2lkZSk7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmQoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5kKCk7XG4gICAgICBpZiAoZGV0YWNoaW5nICYmIGFzaWRlX3RyYW5zaXRpb24pIGFzaWRlX3RyYW5zaXRpb24uZW5kKCk7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICBydW5fYWxsKGRpc3Bvc2UpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGNsaWNrX2hhbmRsZXIgPSBmdW5jdGlvbiBjbGlja19oYW5kbGVyKGUpIHtcbiAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG5mdW5jdGlvbiBpbnN0YW5jZSQxKCQkc2VsZiwgJCRwcm9wcywgJCRpbnZhbGlkYXRlKSB7XG4gIHZhciAkYXBwO1xuICBjb21wb25lbnRfc3Vic2NyaWJlKCQkc2VsZiwgYXBwLCBmdW5jdGlvbiAoJCR2YWx1ZSkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoMywgJGFwcCA9ICQkdmFsdWUpO1xuICB9KTtcbiAgdmFyIGNsb3NlTW9kYWwgPSAkJHByb3BzLmNsb3NlTW9kYWw7XG4gIHZhciBfJCRwcm9wcyRjbG9zZWFibGUgPSAkJHByb3BzLmNsb3NlYWJsZSxcbiAgICAgIGNsb3NlYWJsZSA9IF8kJHByb3BzJGNsb3NlYWJsZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF8kJHByb3BzJGNsb3NlYWJsZTtcbiAgdmFyIGNsb3NlSG92ZXJlZDtcbiAgdmFyIF8kJHByb3BzJCQkc2xvdHMgPSAkJHByb3BzLiQkc2xvdHMsXG4gICAgICAkJHNsb3RzID0gXyQkcHJvcHMkJCRzbG90cyA9PT0gdm9pZCAwID8ge30gOiBfJCRwcm9wcyQkJHNsb3RzLFxuICAgICAgJCRzY29wZSA9ICQkcHJvcHMuJCRzY29wZTtcblxuICB2YXIgbW91c2VlbnRlcl9oYW5kbGVyID0gZnVuY3Rpb24gbW91c2VlbnRlcl9oYW5kbGVyKCkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoMiwgY2xvc2VIb3ZlcmVkID0gdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIG1vdXNlbGVhdmVfaGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlbGVhdmVfaGFuZGxlcigpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDIsIGNsb3NlSG92ZXJlZCA9IGZhbHNlKTtcbiAgfTtcblxuICAkJHNlbGYuJHNldCA9IGZ1bmN0aW9uICgkJHByb3BzKSB7XG4gICAgaWYgKFwiY2xvc2VNb2RhbFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgwLCBjbG9zZU1vZGFsID0gJCRwcm9wcy5jbG9zZU1vZGFsKTtcbiAgICBpZiAoXCJjbG9zZWFibGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgY2xvc2VhYmxlID0gJCRwcm9wcy5jbG9zZWFibGUpO1xuICAgIGlmIChcIiQkc2NvcGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoNCwgJCRzY29wZSA9ICQkcHJvcHMuJCRzY29wZSk7XG4gIH07XG5cbiAgcmV0dXJuIFtjbG9zZU1vZGFsLCBjbG9zZWFibGUsIGNsb3NlSG92ZXJlZCwgJGFwcCwgJCRzY29wZSwgJCRzbG90cywgbW91c2VlbnRlcl9oYW5kbGVyLCBtb3VzZWxlYXZlX2hhbmRsZXJdO1xufVxuXG52YXIgTW9kYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhNb2RhbCwgX1N2ZWx0ZUNvbXBvbmVudDIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKE1vZGFsKTtcblxuICBmdW5jdGlvbiBNb2RhbChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1ybnRvZ2gtc3R5bGVcIikpIGFkZF9jc3MkMSgpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpLCBvcHRpb25zLCBpbnN0YW5jZSQxLCBjcmVhdGVfZnJhZ21lbnQkMSwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGNsb3NlTW9kYWw6IDAsXG4gICAgICBjbG9zZWFibGU6IDFcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIE1vZGFsO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvTW9kYWxIZWFkZXIuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkMigpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLThpOG82ai1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiaGVhZGVyLnN2ZWx0ZS04aThvNmp7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O21hcmdpbi1ib3R0b206MWVtfWRpdi5zdmVsdGUtOGk4bzZqe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O3BhZGRpbmc6MC42ZW07Ym9yZGVyLXJhZGl1czozMHB4O2JhY2tncm91bmQ6I2VlZWVlZX1oMy5zdmVsdGUtOGk4bzZqe2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1zaXplOjEuMzNlbTtmb250LWZhbWlseTppbmhlcml0O21hcmdpbjowIDAgMCAwLjVlbX1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDIoY3R4KSB7XG4gIHZhciBoZWFkZXI7XG4gIHZhciBkaXY7XG4gIHZhciB0MDtcbiAgdmFyIGgzO1xuICB2YXIgdDE7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGhlYWRlciA9IGVsZW1lbnQoXCJoZWFkZXJcIik7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaDMgPSBlbGVtZW50KFwiaDNcIik7XG4gICAgICB0MSA9IHRleHQoXG4gICAgICAvKmhlYWRpbmcqL1xuICAgICAgY3R4WzBdKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1jb250ZW50LWhlYWRlci1pY29uIHN2ZWx0ZS04aThvNmpcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbMl0uZGFya01vZGUpO1xuICAgICAgYXR0cihoMywgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtY29udGVudC1oZWFkZXItaGVhZGluZyBzdmVsdGUtOGk4bzZqXCIpO1xuICAgICAgYXR0cihoZWFkZXIsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsLWNvbnRlbnQtaGVhZGVyIHN2ZWx0ZS04aThvNmpcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBoZWFkZXIsIGFuY2hvcik7XG4gICAgICBhcHBlbmQoaGVhZGVyLCBkaXYpO1xuICAgICAgZGl2LmlubmVySFRNTCA9XG4gICAgICAvKmljb24qL1xuICAgICAgY3R4WzFdO1xuICAgICAgYXBwZW5kKGhlYWRlciwgdDApO1xuICAgICAgYXBwZW5kKGhlYWRlciwgaDMpO1xuICAgICAgYXBwZW5kKGgzLCB0MSk7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjE0KSB7XG4gICAgICB2YXIgX3JlZjE1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE0LCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYxNVswXTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaWNvbiovXG4gICAgICAyKSBkaXYuaW5uZXJIVE1MID1cbiAgICAgIC8qaWNvbiovXG4gICAgICBjdHhbMV07XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgNCkge1xuICAgICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzJdLmRhcmtNb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaGVhZGluZyovXG4gICAgICAxKSBzZXRfZGF0YSh0MSxcbiAgICAgIC8qaGVhZGluZyovXG4gICAgICBjdHhbMF0pO1xuICAgIH0sXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaGVhZGVyKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDIoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgyLCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgaGVhZGluZyA9ICQkcHJvcHMuaGVhZGluZztcbiAgdmFyIGljb24gPSAkJHByb3BzLmljb247XG5cbiAgJCRzZWxmLiRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcImhlYWRpbmdcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgaGVhZGluZyA9ICQkcHJvcHMuaGVhZGluZyk7XG4gICAgaWYgKFwiaWNvblwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCBpY29uID0gJCRwcm9wcy5pY29uKTtcbiAgfTtcblxuICByZXR1cm4gW2hlYWRpbmcsIGljb24sICRhcHBdO1xufVxuXG52YXIgTW9kYWxIZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQzKSB7XG4gIF9pbmhlcml0cyhNb2RhbEhlYWRlciwgX1N2ZWx0ZUNvbXBvbmVudDMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKE1vZGFsSGVhZGVyKTtcblxuICBmdW5jdGlvbiBNb2RhbEhlYWRlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbEhlYWRlcik7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS04aThvNmotc3R5bGVcIikpIGFkZF9jc3MkMigpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBvcHRpb25zLCBpbnN0YW5jZSQyLCBjcmVhdGVfZnJhZ21lbnQkMiwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGhlYWRpbmc6IDAsXG4gICAgICBpY29uOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBNb2RhbEhlYWRlcjtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcbi8qIHNyYy9lbGVtZW50cy9CdXR0b24uc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkMygpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLXI1ZzF2NC1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiYnV0dG9uLnN2ZWx0ZS1yNWcxdjR7YmFja2dyb3VuZDppbmhlcml0O2ZvbnQtc2l6ZTowLjg4OWVtO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Ym9yZGVyOjFweCBzb2xpZCAjNGE5MGUyO2JvcmRlci1yYWRpdXM6NDBweDtwYWRkaW5nOjAuNTVlbSAxLjRlbTtjdXJzb3I6cG9pbnRlcjtjb2xvcjojNGE5MGUyO2ZvbnQtZmFtaWx5OmluaGVyaXQ7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIDE1MG1zIGVhc2UtaW4tb3V0O2xpbmUtaGVpZ2h0OjEuMTV9YnV0dG9uLnN2ZWx0ZS1yNWcxdjQ6Zm9jdXN7b3V0bGluZTpub25lfWJ1dHRvbi5zdmVsdGUtcjVnMXY0OmhvdmVye2JhY2tncm91bmQ6I2VjZjNmY30uYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1yaWdodC5zdmVsdGUtcjVnMXY0e3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tbGVmdC5zdmVsdGUtcjVnMXY0e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MH1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDMoY3R4KSB7XG4gIHZhciBidXR0b247XG4gIHZhciBjdXJyZW50O1xuICB2YXIgbW91bnRlZDtcbiAgdmFyIGRpc3Bvc2U7XG4gIHZhciBkZWZhdWx0X3Nsb3RfdGVtcGxhdGUgPVxuICAvKiQkc2xvdHMqL1xuICBjdHhbNF1bXCJkZWZhdWx0XCJdO1xuICB2YXIgZGVmYXVsdF9zbG90ID0gY3JlYXRlX3Nsb3QoZGVmYXVsdF9zbG90X3RlbXBsYXRlLCBjdHgsXG4gIC8qJCRzY29wZSovXG4gIGN0eFszXSwgbnVsbCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGJ1dHRvbiA9IGVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuYygpO1xuICAgICAgYXR0cihidXR0b24sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXByZXBhcmUtYnV0dG9uIHN2ZWx0ZS1yNWcxdjRcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tcmlnaHRcIixcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgY3R4WzFdID09PSBcInJpZ2h0XCIpO1xuICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLXByZXBhcmUtYnV0dG9uLWxlZnRcIixcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgY3R4WzFdID09PSBcImxlZnRcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tY2VudGVyXCIsXG4gICAgICAvKnBvc2l0aW9uKi9cbiAgICAgIGN0eFsxXSAhPT0gXCJsZWZ0XCIgJiZcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgY3R4WzFdICE9PSBcInJpZ2h0XCIpO1xuICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1saW5rXCIsXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzJdLmRhcmtNb2RlKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZC1ob3ZlclwiLFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFsyXS5kYXJrTW9kZSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBidXR0b24sIGFuY2hvcik7XG5cbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIHtcbiAgICAgICAgZGVmYXVsdF9zbG90Lm0oYnV0dG9uLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICBkaXNwb3NlID0gbGlzdGVuKGJ1dHRvbiwgXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKFxuICAgICAgICAgIC8qb25jbGljayovXG4gICAgICAgICAgY3R4WzBdKSlcbiAgICAgICAgICAgIC8qb25jbGljayovXG4gICAgICAgICAgICBjdHhbMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBfcmVmMTYpIHtcbiAgICAgIHZhciBfcmVmMTcgPSBfc2xpY2VkVG9BcnJheShfcmVmMTYsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjE3WzBdO1xuXG4gICAgICBjdHggPSBuZXdfY3R4O1xuXG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSB7XG4gICAgICAgIGlmIChkZWZhdWx0X3Nsb3QucCAmJiBkaXJ0eSAmXG4gICAgICAgIC8qJCRzY29wZSovXG4gICAgICAgIDgpIHtcbiAgICAgICAgICB1cGRhdGVfc2xvdChkZWZhdWx0X3Nsb3QsIGRlZmF1bHRfc2xvdF90ZW1wbGF0ZSwgY3R4LFxuICAgICAgICAgIC8qJCRzY29wZSovXG4gICAgICAgICAgY3R4WzNdLCBkaXJ0eSwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgMikge1xuICAgICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tcmlnaHRcIixcbiAgICAgICAgLypwb3NpdGlvbiovXG4gICAgICAgIGN0eFsxXSA9PT0gXCJyaWdodFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgMikge1xuICAgICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tbGVmdFwiLFxuICAgICAgICAvKnBvc2l0aW9uKi9cbiAgICAgICAgY3R4WzFdID09PSBcImxlZnRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnBvc2l0aW9uKi9cbiAgICAgIDIpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLXByZXBhcmUtYnV0dG9uLWNlbnRlclwiLFxuICAgICAgICAvKnBvc2l0aW9uKi9cbiAgICAgICAgY3R4WzFdICE9PSBcImxlZnRcIiAmJlxuICAgICAgICAvKnBvc2l0aW9uKi9cbiAgICAgICAgY3R4WzFdICE9PSBcInJpZ2h0XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDQpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1saW5rXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFsyXS5kYXJrTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgNCkge1xuICAgICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmQtaG92ZXJcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzJdLmRhcmtNb2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGRlZmF1bHRfc2xvdCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChkZWZhdWx0X3Nsb3QsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goYnV0dG9uKTtcbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIGRlZmF1bHRfc2xvdC5kKGRldGFjaGluZyk7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICBkaXNwb3NlKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZSQzKCQkc2VsZiwgJCRwcm9wcywgJCRpbnZhbGlkYXRlKSB7XG4gIHZhciAkYXBwO1xuICBjb21wb25lbnRfc3Vic2NyaWJlKCQkc2VsZiwgYXBwLCBmdW5jdGlvbiAoJCR2YWx1ZSkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoMiwgJGFwcCA9ICQkdmFsdWUpO1xuICB9KTtcbiAgdmFyIF8kJHByb3BzJG9uY2xpY2sgPSAkJHByb3BzLm9uY2xpY2ssXG4gICAgICBvbmNsaWNrID0gXyQkcHJvcHMkb25jbGljayA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfJCRwcm9wcyRvbmNsaWNrO1xuICB2YXIgcG9zaXRpb24gPSAkJHByb3BzLnBvc2l0aW9uO1xuICB2YXIgXyQkcHJvcHMkJCRzbG90czIgPSAkJHByb3BzLiQkc2xvdHMsXG4gICAgICAkJHNsb3RzID0gXyQkcHJvcHMkJCRzbG90czIgPT09IHZvaWQgMCA/IHt9IDogXyQkcHJvcHMkJCRzbG90czIsXG4gICAgICAkJHNjb3BlID0gJCRwcm9wcy4kJHNjb3BlO1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJvbmNsaWNrXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIG9uY2xpY2sgPSAkJHByb3BzLm9uY2xpY2spO1xuICAgIGlmIChcInBvc2l0aW9uXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDEsIHBvc2l0aW9uID0gJCRwcm9wcy5wb3NpdGlvbik7XG4gICAgaWYgKFwiJCRzY29wZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgzLCAkJHNjb3BlID0gJCRwcm9wcy4kJHNjb3BlKTtcbiAgfTtcblxuICByZXR1cm4gW29uY2xpY2ssIHBvc2l0aW9uLCAkYXBwLCAkJHNjb3BlLCAkJHNsb3RzXTtcbn1cblxudmFyIEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N2ZWx0ZUNvbXBvbmVudDQpIHtcbiAgX2luaGVyaXRzKEJ1dHRvbiwgX1N2ZWx0ZUNvbXBvbmVudDQpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKEJ1dHRvbik7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG5cbiAgICBfdGhpczQgPSBfc3VwZXI0LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1yNWcxdjQtc3R5bGVcIikpIGFkZF9jc3MkMygpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczQpLCBvcHRpb25zLCBpbnN0YW5jZSQzLCBjcmVhdGVfZnJhZ21lbnQkMywgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIG9uY2xpY2s6IDAsXG4gICAgICBwb3NpdGlvbjogMVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gQnV0dG9uO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2VsZW1lbnRzL1NwaW5uZXIuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkNCgpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLTE2Z2hrMmgtc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcIi5ibi1vbmJvYXJkLWxvYWRpbmctY29udGFpbmVyLnN2ZWx0ZS0xNmdoazJoe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtjb2xvcjppbmhlcml0fXNwYW4uc3ZlbHRlLTE2Z2hrMmh7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6MC44ODllbTttYXJnaW4tdG9wOjFyZW19LmJuLW9uYm9hcmQtbG9hZGluZ3tkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoyZW07aGVpZ2h0OjJlbX0uYm4tb25ib2FyZC1sb2FkaW5nIGRpdntib3gtc2l6aW5nOmJvcmRlci1ib3g7Zm9udC1zaXplOmluaGVyaXQ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyZW07aGVpZ2h0OjJlbTtib3JkZXI6M3B4IHNvbGlkO2JvcmRlci1yYWRpdXM6NTAlO2FuaW1hdGlvbjpibi1vbmJvYXJkLWxvYWRpbmcgMS4ycyBjdWJpYy1iZXppZXIoMC41LCAwLCAwLjUsIDEpIGluZmluaXRlO2JvcmRlci1jb2xvcjpjdXJyZW50Q29sb3IgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnR9LmJuLW9uYm9hcmQtbG9hZGluZyAuYm4tb25ib2FyZC1sb2FkaW5nLWZpcnN0e2FuaW1hdGlvbi1kZWxheTotMC40NXN9LmJuLW9uYm9hcmQtbG9hZGluZyAuYm4tb25ib2FyZC1sb2FkaW5nLXNlY29uZHthbmltYXRpb24tZGVsYXk6LTAuM3N9LmJuLW9uYm9hcmQtbG9hZGluZyAuYm4tb25ib2FyZC1sb2FkaW5nLXRoaXJke2FuaW1hdGlvbi1kZWxheTotMC4xNXN9QGtleWZyYW1lcyBibi1vbmJvYXJkLWxvYWRpbmd7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19XCI7XG4gIGFwcGVuZChkb2N1bWVudC5oZWFkLCBzdHlsZSk7XG59IC8vICg2NToyKSB7I2lmIGRlc2NyaXB0aW9ufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQyKGN0eCkge1xuICB2YXIgc3BhbjtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHQgPSB0ZXh0KFxuICAgICAgLypkZXNjcmlwdGlvbiovXG4gICAgICBjdHhbMF0pO1xuICAgICAgYXR0cihzcGFuLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE2Z2hrMmhcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzcGFuLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKHNwYW4sIHQpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypkZXNjcmlwdGlvbiovXG4gICAgICAxKSBzZXRfZGF0YSh0LFxuICAgICAgLypkZXNjcmlwdGlvbiovXG4gICAgICBjdHhbMF0pO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChzcGFuKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQ0KGN0eCkge1xuICB2YXIgZGl2NDtcbiAgdmFyIGRpdjM7XG4gIHZhciB0MjtcbiAgdmFyIGlmX2Jsb2NrID1cbiAgLypkZXNjcmlwdGlvbiovXG4gIGN0eFswXSAmJiBjcmVhdGVfaWZfYmxvY2skMihjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBkaXY0ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdjMgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2My5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1maXJzdFxcXCI+PC9kaXY+IFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctc2Vjb25kXFxcIj48L2Rpdj4gXFxuICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy10aGlyZFxcXCI+PC9kaXY+XCI7XG4gICAgICB0MiA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2spIGlmX2Jsb2NrLmMoKTtcbiAgICAgIGF0dHIoZGl2MywgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbG9hZGluZ1wiKTtcbiAgICAgIGF0dHIoZGl2NCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtbG9hZGluZy1jb250YWluZXIgc3ZlbHRlLTE2Z2hrMmhcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBkaXY0LCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGRpdjQsIGRpdjMpO1xuICAgICAgYXBwZW5kKGRpdjQsIHQyKTtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2subShkaXY0LCBudWxsKTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBfcmVmMTgpIHtcbiAgICAgIHZhciBfcmVmMTkgPSBfc2xpY2VkVG9BcnJheShfcmVmMTgsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjE5WzBdO1xuXG4gICAgICBpZiAoXG4gICAgICAvKmRlc2NyaXB0aW9uKi9cbiAgICAgIGN0eFswXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgICBpZl9ibG9jay5wKGN0eCwgZGlydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrID0gY3JlYXRlX2lmX2Jsb2NrJDIoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jay5jKCk7XG4gICAgICAgICAgaWZfYmxvY2subShkaXY0LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jaykge1xuICAgICAgICBpZl9ibG9jay5kKDEpO1xuICAgICAgICBpZl9ibG9jayA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXY0KTtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2suZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkNCgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgZGVzY3JpcHRpb24gPSAkJHByb3BzLmRlc2NyaXB0aW9uO1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJkZXNjcmlwdGlvblwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgwLCBkZXNjcmlwdGlvbiA9ICQkcHJvcHMuZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJldHVybiBbZGVzY3JpcHRpb25dO1xufVxuXG52YXIgU3Bpbm5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N2ZWx0ZUNvbXBvbmVudDUpIHtcbiAgX2luaGVyaXRzKFNwaW5uZXIsIF9TdmVsdGVDb21wb25lbnQ1KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihTcGlubmVyKTtcblxuICBmdW5jdGlvbiBTcGlubmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwaW5uZXIpO1xuXG4gICAgX3RoaXM1ID0gX3N1cGVyNS5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtMTZnaGsyaC1zdHlsZVwiKSkgYWRkX2NzcyQ0KCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNSksIG9wdGlvbnMsIGluc3RhbmNlJDQsIGNyZWF0ZV9mcmFnbWVudCQ0LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgZGVzY3JpcHRpb246IDBcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG5cbiAgcmV0dXJuIFNwaW5uZXI7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG4vKiBzcmMvZWxlbWVudHMvSWNvbkJ1dHRvbi5zdmVsdGUgZ2VuZXJhdGVkIGJ5IFN2ZWx0ZSB2My4yNC4wICovXG5cblxuZnVuY3Rpb24gYWRkX2NzcyQ1KCkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmlkID0gXCJzdmVsdGUtMXNreHNuay1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiYnV0dG9uLnN2ZWx0ZS0xc2t4c25re2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyOm5vbmU7bWFyZ2luOjAuMzNlbSAwO2JhY2tncm91bmQ6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDt3aWR0aDoxOGVtO3BhZGRpbmc6MC42MjVlbSAxLjI1ZW07dHJhbnNpdGlvbjpib3gtc2hhZG93IDE1MG1zIGVhc2UtaW4tb3V0LCBiYWNrZ3JvdW5kIDIwMG1zIGVhc2UtaW4tb3V0O2JvcmRlci1yYWRpdXM6NDBweDtjdXJzb3I6cG9pbnRlcjtjb2xvcjppbmhlcml0O2xpbmUtaGVpZ2h0OjEuMTU7Zm9udC1mYW1pbHk6aW5oZXJpdH1idXR0b24uc3ZlbHRlLTFza3hzbms6aG92ZXJ7Ym94LXNoYWRvdzowIDJweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEpfWJ1dHRvbi5zdmVsdGUtMXNreHNuazpmb2N1c3tvdXRsaW5lOm5vbmV9ZGl2LnN2ZWx0ZS0xc2t4c25re2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtoZWlnaHQ6NDBweDt3aWR0aDo0MHB4O2xpbmUtaGVpZ2h0OjQwcHg7Zm9udC1mYW1pbHk6aW5oZXJpdH1pbWcuc3ZlbHRlLTFza3hzbmt7bWF4LWhlaWdodDoxMDAlO21heC13aWR0aDoxMDAlO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1zcGFuLnN2ZWx0ZS0xc2t4c25re3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6aW5oZXJpdDttYXJnaW4tbGVmdDowLjY2ZW07Zm9udC13ZWlnaHQ6Ym9sZDt0ZXh0LWFsaWduOmxlZnQ7Zm9udC1mYW1pbHk6aW5oZXJpdH1pLnN2ZWx0ZS0xc2t4c25re2ZvbnQtc2l6ZTowLjhyZW07Zm9udC13ZWlnaHQ6bGlnaHRlcjtjb2xvcjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9QG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0NTBweCl7YnV0dG9uLnN2ZWx0ZS0xc2t4c25re3dpZHRoOjEwMCV9fS5ibi1vbmJvYXJkLXNlbGVjdGVkLXdhbGxldC5zdmVsdGUtMXNreHNua3tiYWNrZ3JvdW5kOiNjM2MzYzN9XCI7XG4gIGFwcGVuZChkb2N1bWVudC5oZWFkLCBzdHlsZSk7XG59IC8vICg5Njo0KSB7OmVsc2V9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2Vsc2VfYmxvY2skMShjdHgpIHtcbiAgdmFyIGltZztcbiAgdmFyIGltZ19zcmNfdmFsdWU7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGltZyA9IGVsZW1lbnQoXCJpbWdcIik7XG4gICAgICBpZiAoaW1nLnNyYyAhPT0gKGltZ19zcmNfdmFsdWUgPVxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIGN0eFswXSkpIGF0dHIoaW1nLCBcInNyY1wiLCBpbWdfc3JjX3ZhbHVlKTtcbiAgICAgIGF0dHIoaW1nLCBcInNyY3NldFwiLFxuICAgICAgLyppY29uU3JjU2V0Ki9cbiAgICAgIGN0eFsxXSk7XG4gICAgICBhdHRyKGltZywgXCJhbHRcIixcbiAgICAgIC8qdGV4dCovXG4gICAgICBjdHhbNF0pO1xuICAgICAgYXR0cihpbWcsIFwiY2xhc3NcIiwgXCJzdmVsdGUtMXNreHNua1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGltZywgYW5jaG9yKTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaWNvblNyYyovXG4gICAgICAxICYmIGltZy5zcmMgIT09IChpbWdfc3JjX3ZhbHVlID1cbiAgICAgIC8qaWNvblNyYyovXG4gICAgICBjdHhbMF0pKSB7XG4gICAgICAgIGF0dHIoaW1nLCBcInNyY1wiLCBpbWdfc3JjX3ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaWNvblNyY1NldCovXG4gICAgICAyKSB7XG4gICAgICAgIGF0dHIoaW1nLCBcInNyY3NldFwiLFxuICAgICAgICAvKmljb25TcmNTZXQqL1xuICAgICAgICBjdHhbMV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIDE2KSB7XG4gICAgICAgIGF0dHIoaW1nLCBcImFsdFwiLFxuICAgICAgICAvKnRleHQqL1xuICAgICAgICBjdHhbNF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaW1nKTtcbiAgICB9XG4gIH07XG59IC8vICg5NDoxOCkgXG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzIoY3R4KSB7XG4gIHZhciBodG1sX3RhZztcbiAgdmFyIGh0bWxfYW5jaG9yO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBodG1sX2FuY2hvciA9IGVtcHR5KCk7XG4gICAgICBodG1sX3RhZyA9IG5ldyBIdG1sVGFnKGh0bWxfYW5jaG9yKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGh0bWxfdGFnLm0oXG4gICAgICAvKnN2ZyovXG4gICAgICBjdHhbMl0sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIGh0bWxfYW5jaG9yLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzdmcqL1xuICAgICAgNCkgaHRtbF90YWcucChcbiAgICAgIC8qc3ZnKi9cbiAgICAgIGN0eFsyXSk7XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChodG1sX2FuY2hvcik7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBodG1sX3RhZy5kKCk7XG4gICAgfVxuICB9O1xufSAvLyAoOTI6NCkgeyNpZiBsb2FkaW5nV2FsbGV0ID09PSB0ZXh0fVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18xJDEoY3R4KSB7XG4gIHZhciBzcGlubmVyO1xuICB2YXIgY3VycmVudDtcbiAgc3Bpbm5lciA9IG5ldyBTcGlubmVyKHt9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChzcGlubmVyLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChzcGlubmVyLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IG5vb3AsXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oc3Bpbm5lci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChzcGlubmVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoc3Bpbm5lciwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgxMDI6NCkgeyNpZiBjdXJyZW50bHlTZWxlY3RlZH1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skMyhjdHgpIHtcbiAgdmFyIGk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGkgPSBlbGVtZW50KFwiaVwiKTtcbiAgICAgIGkudGV4dENvbnRlbnQgPSBcInNlbGVjdGVkXCI7XG4gICAgICBhdHRyKGksIFwiY2xhc3NcIiwgXCJzdmVsdGUtMXNreHNua1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGksIGFuY2hvcik7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDUoY3R4KSB7XG4gIHZhciBidXR0b247XG4gIHZhciBkaXY7XG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gIHZhciBpZl9ibG9jazA7XG4gIHZhciB0MDtcbiAgdmFyIHNwYW47XG4gIHZhciB0MTtcbiAgdmFyIHQyO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIG1vdW50ZWQ7XG4gIHZhciBkaXNwb3NlO1xuICB2YXIgaWZfYmxvY2tfY3JlYXRvcnMgPSBbY3JlYXRlX2lmX2Jsb2NrXzEkMSwgY3JlYXRlX2lmX2Jsb2NrXzIsIGNyZWF0ZV9lbHNlX2Jsb2NrJDFdO1xuICB2YXIgaWZfYmxvY2tzID0gW107XG5cbiAgZnVuY3Rpb24gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4LCBkaXJ0eSkge1xuICAgIGlmIChcbiAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgIGN0eFs1XSA9PT1cbiAgICAvKnRleHQqL1xuICAgIGN0eFs0XSkgcmV0dXJuIDA7XG4gICAgaWYgKFxuICAgIC8qc3ZnKi9cbiAgICBjdHhbMl0pIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgY3VycmVudF9ibG9ja190eXBlX2luZGV4ID0gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4KTtcbiAgaWZfYmxvY2swID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0gPSBpZl9ibG9ja19jcmVhdG9yc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdKGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKmN1cnJlbnRseVNlbGVjdGVkKi9cbiAgY3R4WzZdICYmIGNyZWF0ZV9pZl9ibG9jayQzKCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGJ1dHRvbiA9IGVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHQxID0gdGV4dChcbiAgICAgIC8qdGV4dCovXG4gICAgICBjdHhbNF0pO1xuICAgICAgdDIgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmMoKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwic3ZlbHRlLTFza3hzbmtcIik7XG4gICAgICBhdHRyKHNwYW4sIFwiY2xhc3NcIiwgXCJzdmVsdGUtMXNreHNua1wiKTtcbiAgICAgIGF0dHIoYnV0dG9uLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1pY29uLWJ1dHRvbiBzdmVsdGUtMXNreHNua1wiKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZC1ob3ZlclwiLFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFs3XS5kYXJrTW9kZSk7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtc2VsZWN0ZWQtd2FsbGV0XCIsXG4gICAgICAvKmN1cnJlbnRseVNlbGVjdGVkKi9cbiAgICAgIGN0eFs2XSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBidXR0b24sIGFuY2hvcik7XG4gICAgICBhcHBlbmQoYnV0dG9uLCBkaXYpO1xuICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0ubShkaXYsIG51bGwpO1xuICAgICAgYXBwZW5kKGJ1dHRvbiwgdDApO1xuICAgICAgYXBwZW5kKGJ1dHRvbiwgc3Bhbik7XG4gICAgICBhcHBlbmQoc3BhbiwgdDEpO1xuICAgICAgYXBwZW5kKHNwYW4sIHQyKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5tKHNwYW4sIG51bGwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICBkaXNwb3NlID0gbGlzdGVuKGJ1dHRvbiwgXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKFxuICAgICAgICAgIC8qb25jbGljayovXG4gICAgICAgICAgY3R4WzNdKSlcbiAgICAgICAgICAgIC8qb25jbGljayovXG4gICAgICAgICAgICBjdHhbM10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBfcmVmMjApIHtcbiAgICAgIHZhciBfcmVmMjEgPSBfc2xpY2VkVG9BcnJheShfcmVmMjAsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjIxWzBdO1xuXG4gICAgICBjdHggPSBuZXdfY3R4O1xuICAgICAgdmFyIHByZXZpb3VzX2Jsb2NrX2luZGV4ID0gY3VycmVudF9ibG9ja190eXBlX2luZGV4O1xuICAgICAgY3VycmVudF9ibG9ja190eXBlX2luZGV4ID0gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4KTtcblxuICAgICAgaWYgKGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9PT0gcHJldmlvdXNfYmxvY2tfaW5kZXgpIHtcbiAgICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0ucChjdHgsIGRpcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9ja3NbcHJldmlvdXNfYmxvY2tfaW5kZXhdLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2tzW3ByZXZpb3VzX2Jsb2NrX2luZGV4XSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgaWZfYmxvY2swID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF07XG5cbiAgICAgICAgaWYgKCFpZl9ibG9jazApIHtcbiAgICAgICAgICBpZl9ibG9jazAgPSBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XSA9IGlmX2Jsb2NrX2NyZWF0b3JzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0oY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazAsIDEpO1xuICAgICAgICBpZl9ibG9jazAubShkaXYsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgZGlydHkgJlxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIDE2KSBzZXRfZGF0YSh0MSxcbiAgICAgIC8qdGV4dCovXG4gICAgICBjdHhbNF0pO1xuXG4gICAgICBpZiAoXG4gICAgICAvKmN1cnJlbnRseVNlbGVjdGVkKi9cbiAgICAgIGN0eFs2XSkge1xuICAgICAgICBpZiAoaWZfYmxvY2sxKSA7ZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gY3JlYXRlX2lmX2Jsb2NrJDMoKTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIGlmX2Jsb2NrMS5tKHNwYW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBpZl9ibG9jazEuZCgxKTtcbiAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJGFwcCovXG4gICAgICAxMjgpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1iYWNrZ3JvdW5kLWhvdmVyXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFs3XS5kYXJrTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmN1cnJlbnRseVNlbGVjdGVkKi9cbiAgICAgIDY0KSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1zZWxlY3RlZC13YWxsZXRcIixcbiAgICAgICAgLypjdXJyZW50bHlTZWxlY3RlZCovXG4gICAgICAgIGN0eFs2XSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazApO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazApO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChidXR0b24pO1xuICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0uZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoKTtcbiAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDUoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSg3LCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYztcbiAgdmFyIGljb25TcmNTZXQgPSAkJHByb3BzLmljb25TcmNTZXQ7XG4gIHZhciBzdmcgPSAkJHByb3BzLnN2ZztcbiAgdmFyIF8kJHByb3BzJG9uY2xpY2syID0gJCRwcm9wcy5vbmNsaWNrLFxuICAgICAgb25jbGljayA9IF8kJHByb3BzJG9uY2xpY2syID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF8kJHByb3BzJG9uY2xpY2syO1xuICB2YXIgdGV4dCA9ICQkcHJvcHMudGV4dDtcbiAgdmFyIGxvYWRpbmdXYWxsZXQgPSAkJHByb3BzLmxvYWRpbmdXYWxsZXQ7XG4gIHZhciBfJCRwcm9wcyRjdXJyZW50bHlTZWwgPSAkJHByb3BzLmN1cnJlbnRseVNlbGVjdGVkLFxuICAgICAgY3VycmVudGx5U2VsZWN0ZWQgPSBfJCRwcm9wcyRjdXJyZW50bHlTZWwgPT09IHZvaWQgMCA/IGZhbHNlIDogXyQkcHJvcHMkY3VycmVudGx5U2VsO1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJpY29uU3JjXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIGljb25TcmMgPSAkJHByb3BzLmljb25TcmMpO1xuICAgIGlmIChcImljb25TcmNTZXRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgaWNvblNyY1NldCA9ICQkcHJvcHMuaWNvblNyY1NldCk7XG4gICAgaWYgKFwic3ZnXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDIsIHN2ZyA9ICQkcHJvcHMuc3ZnKTtcbiAgICBpZiAoXCJvbmNsaWNrXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDMsIG9uY2xpY2sgPSAkJHByb3BzLm9uY2xpY2spO1xuICAgIGlmIChcInRleHRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoNCwgdGV4dCA9ICQkcHJvcHMudGV4dCk7XG4gICAgaWYgKFwibG9hZGluZ1dhbGxldFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSg1LCBsb2FkaW5nV2FsbGV0ID0gJCRwcm9wcy5sb2FkaW5nV2FsbGV0KTtcbiAgICBpZiAoXCJjdXJyZW50bHlTZWxlY3RlZFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSg2LCBjdXJyZW50bHlTZWxlY3RlZCA9ICQkcHJvcHMuY3VycmVudGx5U2VsZWN0ZWQpO1xuICB9O1xuXG4gIHJldHVybiBbaWNvblNyYywgaWNvblNyY1NldCwgc3ZnLCBvbmNsaWNrLCB0ZXh0LCBsb2FkaW5nV2FsbGV0LCBjdXJyZW50bHlTZWxlY3RlZCwgJGFwcF07XG59XG5cbnZhciBJY29uQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50Nikge1xuICBfaW5oZXJpdHMoSWNvbkJ1dHRvbiwgX1N2ZWx0ZUNvbXBvbmVudDYpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEljb25CdXR0b24pO1xuXG4gIGZ1bmN0aW9uIEljb25CdXR0b24ob3B0aW9ucykge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbkJ1dHRvbik7XG5cbiAgICBfdGhpczYgPSBfc3VwZXI2LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xc2t4c25rLXN0eWxlXCIpKSBhZGRfY3NzJDUoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM2KSwgb3B0aW9ucywgaW5zdGFuY2UkNSwgY3JlYXRlX2ZyYWdtZW50JDUsIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICBpY29uU3JjOiAwLFxuICAgICAgaWNvblNyY1NldDogMSxcbiAgICAgIHN2ZzogMixcbiAgICAgIG9uY2xpY2s6IDMsXG4gICAgICB0ZXh0OiA0LFxuICAgICAgbG9hZGluZ1dhbGxldDogNSxcbiAgICAgIGN1cnJlbnRseVNlbGVjdGVkOiA2XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIHJldHVybiBJY29uQnV0dG9uO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvV2FsbGV0cy5zdmVsdGUgZ2VuZXJhdGVkIGJ5IFN2ZWx0ZSB2My4yNC4wICovXG5cblxuZnVuY3Rpb24gYWRkX2NzcyQ2KCkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmlkID0gXCJzdmVsdGUtcTE1Mjctc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcInVsLnN2ZWx0ZS1xMTUyNy5zdmVsdGUtcTE1Mjd7ZGlzcGxheTpmbGV4O2ZsZXgtZmxvdzpyb3cgd3JhcDthbGlnbi1pdGVtczpjZW50ZXI7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjEuMjVlbSAwO3BhZGRpbmc6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OjEuMTU7Ym94LXNpemluZzpib3JkZXItYm94fXVsLnN2ZWx0ZS1xMTUyNyBsaS5zdmVsdGUtcTE1Mjd7cGFkZGluZzowIDAuMjVlbX1kaXYuc3ZlbHRlLXExNTI3LnN2ZWx0ZS1xMTUyN3t3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLXRvcDoxLjI1ZW19LnN2ZWx0ZS1xMTUyNy5zdmVsdGUtcTE1Mjc6Oi13ZWJraXQtc2Nyb2xsYmFye2Rpc3BsYXk6bm9uZX1AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ1MHB4KXt1bC5zdmVsdGUtcTE1MjcgbGkuc3ZlbHRlLXExNTI3e3dpZHRoOjEwMCV9dWwuc3ZlbHRlLXExNTI3LnN2ZWx0ZS1xMTUyN3ttYXgtaGVpZ2h0OjY2dmg7b3ZlcmZsb3cteTpzY3JvbGx9fVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufVxuXG5mdW5jdGlvbiBnZXRfZWFjaF9jb250ZXh0KGN0eCwgbGlzdCwgaSkge1xuICB2YXIgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gIGNoaWxkX2N0eFs5XSA9IGxpc3RbaV07XG4gIGNoaWxkX2N0eFsxMV0gPSBpO1xuICByZXR1cm4gY2hpbGRfY3R4O1xufVxuXG5mdW5jdGlvbiBnZXRfZWFjaF9jb250ZXh0XzEoY3R4LCBsaXN0LCBpKSB7XG4gIHZhciBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgY2hpbGRfY3R4WzldID0gbGlzdFtpXTtcbiAgY2hpbGRfY3R4WzExXSA9IGk7XG4gIHJldHVybiBjaGlsZF9jdHg7XG59IC8vICg2MToyKSB7I2VhY2ggbW9kYWxEYXRhLnByaW1hcnlXYWxsZXRzIGFzIHdhbGxldCwgaSAod2FsbGV0Lm5hbWUpfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9lYWNoX2Jsb2NrXzEoa2V5XzEsIGN0eCkge1xuICB2YXIgbGk7XG4gIHZhciBpY29uYnV0dG9uO1xuICB2YXIgY3VycmVudDtcblxuICBmdW5jdGlvbiBmdW5jKCkge1xuICAgIHZhciBfY3R4O1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qZnVuYyovXG4gICAgICAoX2N0eCA9IGN0eClbNl0uYXBwbHkoX2N0eCwgW1xuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldXS5jb25jYXQoYXJncykpXG4gICAgKTtcbiAgfVxuXG4gIGljb25idXR0b24gPSBuZXcgSWNvbkJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIG9uY2xpY2s6IGZ1bmMsXG4gICAgICBpY29uU3JjOlxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLmljb25TcmMsXG4gICAgICBpY29uU3JjU2V0OlxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLmljb25TcmNTZXQsXG4gICAgICBzdmc6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0uc3ZnLFxuICAgICAgdGV4dDpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5uYW1lLFxuICAgICAgY3VycmVudGx5U2VsZWN0ZWQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0ubmFtZSA9PT1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXQqL1xuICAgICAgY3R4WzVdLm5hbWUsXG4gICAgICBsb2FkaW5nV2FsbGV0OlxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIGN0eFsyXVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXlfMSxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgbGkgPSBlbGVtZW50KFwibGlcIik7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGljb25idXR0b24uJCQuZnJhZ21lbnQpO1xuICAgICAgYXR0cihsaSwgXCJjbGFzc1wiLCBcInN2ZWx0ZS1xMTUyN1wiKTtcbiAgICAgIHRoaXMuZmlyc3QgPSBsaTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGxpLCBhbmNob3IpO1xuICAgICAgbW91bnRfY29tcG9uZW50KGljb25idXR0b24sIGxpLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBkaXJ0eSkge1xuICAgICAgY3R4ID0gbmV3X2N0eDtcbiAgICAgIHZhciBpY29uYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmhhbmRsZVdhbGxldFNlbGVjdCwgbW9kYWxEYXRhKi9cbiAgICAgIDMpIGljb25idXR0b25fY2hhbmdlcy5vbmNsaWNrID0gZnVuYztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyYyA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0uaWNvblNyYztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyY1NldCA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0uaWNvblNyY1NldDtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuc3ZnID1cbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5zdmc7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLnRleHQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWU7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEsIHNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIDMzKSBpY29uYnV0dG9uX2NoYW5nZXMuY3VycmVudGx5U2VsZWN0ZWQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWUgPT09XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIGN0eFs1XS5uYW1lO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICA0KSBpY29uYnV0dG9uX2NoYW5nZXMubG9hZGluZ1dhbGxldCA9XG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgY3R4WzJdO1xuICAgICAgaWNvbmJ1dHRvbi4kc2V0KGljb25idXR0b25fY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpY29uYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGljb25idXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2gobGkpO1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoaWNvbmJ1dHRvbik7XG4gICAgfVxuICB9O1xufSAvLyAoNzQ6MikgeyNpZiBtb2RhbERhdGEuc2Vjb25kYXJ5V2FsbGV0cyAmJiBtb2RhbERhdGEuc2Vjb25kYXJ5V2FsbGV0cy5sZW5ndGggJiYgIXNob3dpbmdBbGxXYWxsZXRNb2R1bGVzfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18xJDIoY3R4KSB7XG4gIHZhciBkaXY7XG4gIHZhciBidXR0b247XG4gIHZhciBjdXJyZW50O1xuICBidXR0b24gPSBuZXcgQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgb25jbGljazpcbiAgICAgIC8qc2hvd0FsbFdhbGxldHMqL1xuICAgICAgY3R4WzRdLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3RdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGRpdiA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGJ1dHRvbi4kJC5mcmFnbWVudCk7XG4gICAgICBhdHRyKGRpdiwgXCJjbGFzc1wiLCBcInN2ZWx0ZS1xMTUyN1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGRpdiwgYW5jaG9yKTtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIGRpdiwgbnVsbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgdmFyIGJ1dHRvbl9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzaG93QWxsV2FsbGV0cyovXG4gICAgICAxNikgYnV0dG9uX2NoYW5nZXMub25jbGljayA9XG4gICAgICAvKnNob3dBbGxXYWxsZXRzKi9cbiAgICAgIGN0eFs0XTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICA4MTkyKSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goZGl2KTtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGJ1dHRvbik7XG4gICAgfVxuICB9O1xufSAvLyAoNzY6NikgPEJ1dHRvbiBvbmNsaWNrPXtzaG93QWxsV2FsbGV0c30+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdChjdHgpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KFwiU2hvdyBNb3JlXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdCwgYW5jaG9yKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgfVxuICB9O1xufSAvLyAoODA6MikgeyNpZiBzaG93aW5nQWxsV2FsbGV0TW9kdWxlc31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skNChjdHgpIHtcbiAgdmFyIGVhY2hfYmxvY2tzID0gW107XG4gIHZhciBlYWNoXzFfbG9va3VwID0gbmV3IE1hcCgpO1xuICB2YXIgZWFjaF8xX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBlYWNoX3ZhbHVlID1cbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cztcblxuICB2YXIgZ2V0X2tleSA9IGZ1bmN0aW9uIGdldF9rZXkoY3R4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5uYW1lXG4gICAgKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVhY2hfdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgY2hpbGRfY3R4ID0gZ2V0X2VhY2hfY29udGV4dChjdHgsIGVhY2hfdmFsdWUsIGkpO1xuICAgIHZhciBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgZWFjaF8xX2xvb2t1cC5zZXQoa2V5LCBlYWNoX2Jsb2Nrc1tpXSA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlYWNoX2Jsb2Nrcy5sZW5ndGg7IF9pMyArPSAxKSB7XG4gICAgICAgIGVhY2hfYmxvY2tzW19pM10uYygpO1xuICAgICAgfVxuXG4gICAgICBlYWNoXzFfYW5jaG9yID0gZW1wdHkoKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2k0ICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2k0XS5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0KHRhcmdldCwgZWFjaF8xX2FuY2hvciwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypoYW5kbGVXYWxsZXRTZWxlY3QsIG1vZGFsRGF0YSwgc2VsZWN0ZWRXYWxsZXQsIGxvYWRpbmdXYWxsZXQqL1xuICAgICAgMzkpIHtcbiAgICAgICAgdmFyIF9lYWNoX3ZhbHVlID1cbiAgICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cztcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIGVhY2hfYmxvY2tzID0gdXBkYXRlX2tleWVkX2VhY2goZWFjaF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCAxLCBjdHgsIF9lYWNoX3ZhbHVlLCBlYWNoXzFfbG9va3VwLCBlYWNoXzFfYW5jaG9yLnBhcmVudE5vZGUsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBjcmVhdGVfZWFjaF9ibG9jaywgZWFjaF8xX2FuY2hvciwgZ2V0X2VhY2hfY29udGV4dCk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgZWFjaF92YWx1ZS5sZW5ndGg7IF9pNSArPSAxKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oZWFjaF9ibG9ja3NbX2k1XSk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTYgKz0gMSkge1xuICAgICAgICB0cmFuc2l0aW9uX291dChlYWNoX2Jsb2Nrc1tfaTZdKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2k3ICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2k3XS5kKGRldGFjaGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChlYWNoXzFfYW5jaG9yKTtcbiAgICB9XG4gIH07XG59IC8vICg4MTo0KSB7I2VhY2ggbW9kYWxEYXRhLnNlY29uZGFyeVdhbGxldHMgYXMgd2FsbGV0LCBpICh3YWxsZXQubmFtZSl9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2VhY2hfYmxvY2soa2V5XzEsIGN0eCkge1xuICB2YXIgbGk7XG4gIHZhciBpY29uYnV0dG9uO1xuICB2YXIgdDtcbiAgdmFyIGN1cnJlbnQ7XG5cbiAgZnVuY3Rpb24gZnVuY18xKCkge1xuICAgIHZhciBfY3R4MjtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvKmZ1bmNfMSovXG4gICAgICAoX2N0eDIgPSBjdHgpWzddLmFwcGx5KF9jdHgyLCBbXG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV1dLmNvbmNhdChhcmdzKSlcbiAgICApO1xuICB9XG5cbiAgaWNvbmJ1dHRvbiA9IG5ldyBJY29uQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgb25jbGljazogZnVuY18xLFxuICAgICAgaWNvblNyYzpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5pY29uU3JjLFxuICAgICAgaWNvblNyY1NldDpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5pY29uU3JjU2V0LFxuICAgICAgc3ZnOlxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLnN2ZyxcbiAgICAgIHRleHQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0ubmFtZSxcbiAgICAgIGN1cnJlbnRseVNlbGVjdGVkOlxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWUgPT09XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIGN0eFs1XS5uYW1lLFxuICAgICAgbG9hZGluZ1dhbGxldDpcbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICBjdHhbMl1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGtleToga2V5XzEsXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGxpID0gZWxlbWVudChcImxpXCIpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChpY29uYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICAgIHQgPSBzcGFjZSgpO1xuICAgICAgYXR0cihsaSwgXCJjbGFzc1wiLCBcInN2ZWx0ZS1xMTUyN1wiKTtcbiAgICAgIHRoaXMuZmlyc3QgPSBsaTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGxpLCBhbmNob3IpO1xuICAgICAgbW91bnRfY29tcG9uZW50KGljb25idXR0b24sIGxpLCBudWxsKTtcbiAgICAgIGFwcGVuZChsaSwgdCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAobmV3X2N0eCwgZGlydHkpIHtcbiAgICAgIGN0eCA9IG5ld19jdHg7XG4gICAgICB2YXIgaWNvbmJ1dHRvbl9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypoYW5kbGVXYWxsZXRTZWxlY3QsIG1vZGFsRGF0YSovXG4gICAgICAzKSBpY29uYnV0dG9uX2NoYW5nZXMub25jbGljayA9IGZ1bmNfMTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyYyA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0uaWNvblNyYztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyY1NldCA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbOV0uaWNvblNyY1NldDtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuc3ZnID1cbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFs5XS5zdmc7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLnRleHQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWU7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEsIHNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIDMzKSBpY29uYnV0dG9uX2NoYW5nZXMuY3VycmVudGx5U2VsZWN0ZWQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWUgPT09XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIGN0eFs1XS5uYW1lO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICA0KSBpY29uYnV0dG9uX2NoYW5nZXMubG9hZGluZ1dhbGxldCA9XG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgY3R4WzJdO1xuICAgICAgaWNvbmJ1dHRvbi4kc2V0KGljb25idXR0b25fY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpY29uYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGljb25idXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2gobGkpO1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoaWNvbmJ1dHRvbik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnQkNihjdHgpIHtcbiAgdmFyIHVsO1xuICB2YXIgZWFjaF9ibG9ja3MgPSBbXTtcbiAgdmFyIGVhY2hfMV9sb29rdXAgPSBuZXcgTWFwKCk7XG4gIHZhciB0MDtcbiAgdmFyIHQxO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIGVhY2hfdmFsdWVfMSA9XG4gIC8qbW9kYWxEYXRhKi9cbiAgY3R4WzBdLnByaW1hcnlXYWxsZXRzO1xuXG4gIHZhciBnZXRfa2V5ID0gZnVuY3Rpb24gZ2V0X2tleShjdHgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzldLm5hbWVcbiAgICApO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWFjaF92YWx1ZV8xLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNoaWxkX2N0eCA9IGdldF9lYWNoX2NvbnRleHRfMShjdHgsIGVhY2hfdmFsdWVfMSwgaSk7XG4gICAgdmFyIGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICBlYWNoXzFfbG9va3VwLnNldChrZXksIGVhY2hfYmxvY2tzW2ldID0gY3JlYXRlX2VhY2hfYmxvY2tfMShrZXksIGNoaWxkX2N0eCkpO1xuICB9XG5cbiAgdmFyIGlmX2Jsb2NrMCA9XG4gIC8qbW9kYWxEYXRhKi9cbiAgY3R4WzBdLnNlY29uZGFyeVdhbGxldHMgJiZcbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cy5sZW5ndGggJiYgIVxuICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgY3R4WzNdICYmIGNyZWF0ZV9pZl9ibG9ja18xJDIoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrMSA9XG4gIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICBjdHhbM10gJiYgY3JlYXRlX2lmX2Jsb2NrJDQoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgdWwgPSBlbGVtZW50KFwidWxcIik7XG5cbiAgICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2k4ICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2k4XS5jKCk7XG4gICAgICB9XG5cbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuYygpO1xuICAgICAgYXR0cih1bCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtc2VsZWN0LXdhbGxldHMgc3ZlbHRlLXExNTI3XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdWwsIGFuY2hvcik7XG5cbiAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2k5ICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2k5XS5tKHVsLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgYXBwZW5kKHVsLCB0MCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubSh1bCwgbnVsbCk7XG4gICAgICBhcHBlbmQodWwsIHQxKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5tKHVsLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYyMikge1xuICAgICAgdmFyIF9yZWYyMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyMiwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMjNbMF07XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmhhbmRsZVdhbGxldFNlbGVjdCwgbW9kYWxEYXRhLCBzZWxlY3RlZFdhbGxldCwgbG9hZGluZ1dhbGxldCovXG4gICAgICAzOSkge1xuICAgICAgICB2YXIgX2VhY2hfdmFsdWVfID1cbiAgICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgICBjdHhbMF0ucHJpbWFyeVdhbGxldHM7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICBlYWNoX2Jsb2NrcyA9IHVwZGF0ZV9rZXllZF9lYWNoKGVhY2hfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgMSwgY3R4LCBfZWFjaF92YWx1ZV8sIGVhY2hfMV9sb29rdXAsIHVsLCBvdXRyb19hbmRfZGVzdHJveV9ibG9jaywgY3JlYXRlX2VhY2hfYmxvY2tfMSwgdDAsIGdldF9lYWNoX2NvbnRleHRfMSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cyAmJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgY3R4WzBdLnNlY29uZGFyeVdhbGxldHMubGVuZ3RoICYmICFcbiAgICAgIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICAgICAgY3R4WzNdKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgICBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyptb2RhbERhdGEsIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgICAgICA5KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IGNyZWF0ZV9pZl9ibG9ja18xJDIoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazAubSh1bCwgdDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMCkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgIGN0eFszXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgICAgaWZfYmxvY2sxLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICAgICAgICAgIDgpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gY3JlYXRlX2lmX2Jsb2NrJDQoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazEubSh1bCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazEsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazEgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IGVhY2hfdmFsdWVfMS5sZW5ndGg7IF9pMTAgKz0gMSkge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGVhY2hfYmxvY2tzW19pMTBdKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazApO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazEpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2kxMSArPSAxKSB7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGVhY2hfYmxvY2tzW19pMTFdKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMSk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHVsKTtcblxuICAgICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBlYWNoX2Jsb2Nrcy5sZW5ndGg7IF9pMTIgKz0gMSkge1xuICAgICAgICBlYWNoX2Jsb2Nrc1tfaTEyXS5kKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5kKCk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkNigkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgbW9kYWxEYXRhID0gJCRwcm9wcy5tb2RhbERhdGE7XG4gIHZhciBoYW5kbGVXYWxsZXRTZWxlY3QgPSAkJHByb3BzLmhhbmRsZVdhbGxldFNlbGVjdDtcbiAgdmFyIGxvYWRpbmdXYWxsZXQgPSAkJHByb3BzLmxvYWRpbmdXYWxsZXQ7XG4gIHZhciBfJCRwcm9wcyRzaG93aW5nQWxsV2EgPSAkJHByb3BzLnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzLFxuICAgICAgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMgPSBfJCRwcm9wcyRzaG93aW5nQWxsV2EgPT09IHZvaWQgMCA/IGZhbHNlIDogXyQkcHJvcHMkc2hvd2luZ0FsbFdhO1xuICB2YXIgc2hvd0FsbFdhbGxldHMgPSAkJHByb3BzLnNob3dBbGxXYWxsZXRzO1xuICB2YXIgc2VsZWN0ZWRXYWxsZXQ7XG4gIHZhciB1bnN1YnNjcmliZSA9IHdhbGxldC5zdWJzY3JpYmUoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoNSwgc2VsZWN0ZWRXYWxsZXQgPSB3YWxsZXQpO1xuICB9KTtcbiAgb25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmUoKTtcbiAgfSk7XG5cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHdhbGxldCkge1xuICAgIHJldHVybiBoYW5kbGVXYWxsZXRTZWxlY3Qod2FsbGV0KTtcbiAgfTtcblxuICB2YXIgZnVuY18xID0gZnVuY3Rpb24gZnVuY18xKHdhbGxldCkge1xuICAgIHJldHVybiBoYW5kbGVXYWxsZXRTZWxlY3Qod2FsbGV0KTtcbiAgfTtcblxuICAkJHNlbGYuJHNldCA9IGZ1bmN0aW9uICgkJHByb3BzKSB7XG4gICAgaWYgKFwibW9kYWxEYXRhXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIG1vZGFsRGF0YSA9ICQkcHJvcHMubW9kYWxEYXRhKTtcbiAgICBpZiAoXCJoYW5kbGVXYWxsZXRTZWxlY3RcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgaGFuZGxlV2FsbGV0U2VsZWN0ID0gJCRwcm9wcy5oYW5kbGVXYWxsZXRTZWxlY3QpO1xuICAgIGlmIChcImxvYWRpbmdXYWxsZXRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMiwgbG9hZGluZ1dhbGxldCA9ICQkcHJvcHMubG9hZGluZ1dhbGxldCk7XG4gICAgaWYgKFwic2hvd2luZ0FsbFdhbGxldE1vZHVsZXNcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMywgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMgPSAkJHByb3BzLnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKTtcbiAgICBpZiAoXCJzaG93QWxsV2FsbGV0c1wiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSg0LCBzaG93QWxsV2FsbGV0cyA9ICQkcHJvcHMuc2hvd0FsbFdhbGxldHMpO1xuICB9O1xuXG4gIHJldHVybiBbbW9kYWxEYXRhLCBoYW5kbGVXYWxsZXRTZWxlY3QsIGxvYWRpbmdXYWxsZXQsIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzLCBzaG93QWxsV2FsbGV0cywgc2VsZWN0ZWRXYWxsZXQsIGZ1bmMsIGZ1bmNfMV07XG59XG5cbnZhciBXYWxsZXRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50Nykge1xuICBfaW5oZXJpdHMoV2FsbGV0cywgX1N2ZWx0ZUNvbXBvbmVudDcpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKFdhbGxldHMpO1xuXG4gIGZ1bmN0aW9uIFdhbGxldHMob3B0aW9ucykge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2FsbGV0cyk7XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1xMTUyNy1zdHlsZVwiKSkgYWRkX2NzcyQ2KCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIG9wdGlvbnMsIGluc3RhbmNlJDYsIGNyZWF0ZV9mcmFnbWVudCQ2LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgbW9kYWxEYXRhOiAwLFxuICAgICAgaGFuZGxlV2FsbGV0U2VsZWN0OiAxLFxuICAgICAgbG9hZGluZ1dhbGxldDogMixcbiAgICAgIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzOiAzLFxuICAgICAgc2hvd0FsbFdhbGxldHM6IDRcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgcmV0dXJuIFdhbGxldHM7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG4vKiBzcmMvZWxlbWVudHMvSWNvbkRpc3BsYXkuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkNygpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLTE4enRzNGItc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcImRpdi5zdmVsdGUtMTh6dHM0YntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2JvcmRlcjpub25lO21hcmdpbjowO2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7YmFja2dyb3VuZDppbmhlcml0O3BhZGRpbmc6MDt3aWR0aDoxOGVtO2JvcmRlci1yYWRpdXM6NDBweDtjb2xvcjppbmhlcml0fWltZy5zdmVsdGUtMTh6dHM0Ynt3aWR0aDphdXRvO2hlaWdodDozZW19c3Bhbi5zdmVsdGUtMTh6dHM0YnttYXJnaW4tbGVmdDowLjY2ZW07Zm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O29wYWNpdHk6MC43O3RleHQtYWxpZ246bGVmdH1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDQxOjIpIHs6ZWxzZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWxzZV9ibG9jayQyKGN0eCkge1xuICB2YXIgaW1nO1xuICB2YXIgaW1nX3NyY192YWx1ZTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaW1nID0gZWxlbWVudChcImltZ1wiKTtcbiAgICAgIGlmIChpbWcuc3JjICE9PSAoaW1nX3NyY192YWx1ZSA9XG4gICAgICAvKmljb25TcmMqL1xuICAgICAgY3R4WzBdKSkgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAvKmljb25TcmNTZXQqL1xuICAgICAgY3R4WzFdKTtcbiAgICAgIGF0dHIoaW1nLCBcImFsdFwiLFxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIGN0eFsyXSk7XG4gICAgICBhdHRyKGltZywgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xOHp0czRiXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaW1nLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIDEgJiYgaW1nLnNyYyAhPT0gKGltZ19zcmNfdmFsdWUgPVxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIGN0eFswXSkpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjU2V0Ki9cbiAgICAgIDIpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAgIC8qaWNvblNyY1NldCovXG4gICAgICAgIGN0eFsxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnRleHQqL1xuICAgICAgNCkge1xuICAgICAgICBhdHRyKGltZywgXCJhbHRcIixcbiAgICAgICAgLyp0ZXh0Ki9cbiAgICAgICAgY3R4WzJdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaW1nKTtcbiAgICB9XG4gIH07XG59IC8vICgzOToyKSB7I2lmIHN2Z31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skNShjdHgpIHtcbiAgdmFyIGh0bWxfdGFnO1xuICB2YXIgaHRtbF9hbmNob3I7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGh0bWxfYW5jaG9yID0gZW1wdHkoKTtcbiAgICAgIGh0bWxfdGFnID0gbmV3IEh0bWxUYWcoaHRtbF9hbmNob3IpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaHRtbF90YWcubShcbiAgICAgIC8qc3ZnKi9cbiAgICAgIGN0eFszXSwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaHRtbF9hbmNob3IsIGFuY2hvcik7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnN2ZyovXG4gICAgICA4KSBodG1sX3RhZy5wKFxuICAgICAgLypzdmcqL1xuICAgICAgY3R4WzNdKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaHRtbF9hbmNob3IpO1xuICAgICAgaWYgKGRldGFjaGluZykgaHRtbF90YWcuZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDcoY3R4KSB7XG4gIHZhciBkaXY7XG4gIHZhciB0MDtcbiAgdmFyIHNwYW47XG4gIHZhciB0MTtcblxuICBmdW5jdGlvbiBzZWxlY3RfYmxvY2tfdHlwZShjdHgsIGRpcnR5KSB7XG4gICAgaWYgKFxuICAgIC8qc3ZnKi9cbiAgICBjdHhbM10pIHJldHVybiBjcmVhdGVfaWZfYmxvY2skNTtcbiAgICByZXR1cm4gY3JlYXRlX2Vsc2VfYmxvY2skMjtcbiAgfVxuXG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICB2YXIgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmX2Jsb2NrLmMoKTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHQxID0gdGV4dChcbiAgICAgIC8qdGV4dCovXG4gICAgICBjdHhbMl0pO1xuICAgICAgYXR0cihzcGFuLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE4enRzNGJcIik7XG4gICAgICBhdHRyKGRpdiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtaWNvbi1kaXNwbGF5IHN2ZWx0ZS0xOHp0czRiXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgaWZfYmxvY2subShkaXYsIG51bGwpO1xuICAgICAgYXBwZW5kKGRpdiwgdDApO1xuICAgICAgYXBwZW5kKGRpdiwgc3Bhbik7XG4gICAgICBhcHBlbmQoc3BhbiwgdDEpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYyNCkge1xuICAgICAgdmFyIF9yZWYyNSA9IF9zbGljZWRUb0FycmF5KF9yZWYyNCwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMjVbMF07XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGUgPT09IChjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpKSAmJiBpZl9ibG9jaykge1xuICAgICAgICBpZl9ibG9jay5wKGN0eCwgZGlydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWZfYmxvY2suZCgxKTtcbiAgICAgICAgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcblxuICAgICAgICBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgICBpZl9ibG9jay5jKCk7XG4gICAgICAgICAgaWZfYmxvY2subShkaXYsIHQwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIDQpIHNldF9kYXRhKHQxLFxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIGN0eFsyXSk7XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYpO1xuICAgICAgaWZfYmxvY2suZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkNygkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYztcbiAgdmFyIGljb25TcmNTZXQgPSAkJHByb3BzLmljb25TcmNTZXQ7XG4gIHZhciB0ZXh0ID0gJCRwcm9wcy50ZXh0O1xuICB2YXIgc3ZnID0gJCRwcm9wcy5zdmc7XG5cbiAgJCRzZWxmLiRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcImljb25TcmNcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYyk7XG4gICAgaWYgKFwiaWNvblNyY1NldFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCBpY29uU3JjU2V0ID0gJCRwcm9wcy5pY29uU3JjU2V0KTtcbiAgICBpZiAoXCJ0ZXh0XCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDIsIHRleHQgPSAkJHByb3BzLnRleHQpO1xuICAgIGlmIChcInN2Z1wiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgzLCBzdmcgPSAkJHByb3BzLnN2Zyk7XG4gIH07XG5cbiAgcmV0dXJuIFtpY29uU3JjLCBpY29uU3JjU2V0LCB0ZXh0LCBzdmddO1xufVxuXG52YXIgSWNvbkRpc3BsYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQ4KSB7XG4gIF9pbmhlcml0cyhJY29uRGlzcGxheSwgX1N2ZWx0ZUNvbXBvbmVudDgpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKEljb25EaXNwbGF5KTtcblxuICBmdW5jdGlvbiBJY29uRGlzcGxheShvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzODtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uRGlzcGxheSk7XG5cbiAgICBfdGhpczggPSBfc3VwZXI4LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xOHp0czRiLXN0eWxlXCIpKSBhZGRfY3NzJDcoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM4KSwgb3B0aW9ucywgaW5zdGFuY2UkNywgY3JlYXRlX2ZyYWdtZW50JDcsIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICBpY29uU3JjOiAwLFxuICAgICAgaWNvblNyY1NldDogMSxcbiAgICAgIHRleHQ6IDIsXG4gICAgICBzdmc6IDNcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgcmV0dXJuIEljb25EaXNwbGF5O1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvU2VsZWN0ZWRXYWxsZXQuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMjQuMCAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkOCgpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLW1pNmFoYy1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwic2VjdGlvbi5zdmVsdGUtbWk2YWhje2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtkaXNwbGF5OmJsb2NrfWZvb3Rlci5zdmVsdGUtbWk2YWhje2Rpc3BsYXk6ZmxleDtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoMzM6MikgeyNpZiBpbnN0YWxsTWVzc2FnZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skNihjdHgpIHtcbiAgdmFyIGh0bWxfdGFnO1xuICB2YXIgaHRtbF9hbmNob3I7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGh0bWxfYW5jaG9yID0gZW1wdHkoKTtcbiAgICAgIGh0bWxfdGFnID0gbmV3IEh0bWxUYWcoaHRtbF9hbmNob3IpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaHRtbF90YWcubShcbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgY3R4WzJdLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBodG1sX2FuY2hvciwgYW5jaG9yKTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgNCkgaHRtbF90YWcucChcbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgY3R4WzJdKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaHRtbF9hbmNob3IpO1xuICAgICAgaWYgKGRldGFjaGluZykgaHRtbF90YWcuZCgpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDQyOjYpIDxCdXR0b24+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdF8xKGN0eCkge1xuICB2YXIgdDA7XG4gIHZhciB0MV92YWx1ZSA9XG4gIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICBjdHhbMF0ubmFtZSArIFwiXCI7XG4gIHZhciB0MTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgdDAgPSB0ZXh0KFwiT3BlbiBvciBpbnN0YWxsIFwiKTtcbiAgICAgIHQxID0gdGV4dCh0MV92YWx1ZSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICAxICYmIHQxX3ZhbHVlICE9PSAodDFfdmFsdWUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0ubmFtZSArIFwiXCIpKSBzZXRfZGF0YSh0MSwgdDFfdmFsdWUpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MCk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDEpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDQ0OjQpIDxCdXR0b24gb25jbGljaz17b25CYWNrfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90JDEoY3R4KSB7XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB0ID0gdGV4dChcIkJhY2tcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0LCBhbmNob3IpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQ4KGN0eCkge1xuICB2YXIgc2VjdGlvbjtcbiAgdmFyIGljb25kaXNwbGF5O1xuICB2YXIgdDA7XG4gIHZhciB0MTtcbiAgdmFyIGZvb3RlcjtcbiAgdmFyIGE7XG4gIHZhciBidXR0b24wO1xuICB2YXIgYV9ocmVmX3ZhbHVlO1xuICB2YXIgdDI7XG4gIHZhciBidXR0b24xO1xuICB2YXIgc2VjdGlvbl9pbnRybztcbiAgdmFyIGN1cnJlbnQ7XG4gIGljb25kaXNwbGF5ID0gbmV3IEljb25EaXNwbGF5KHtcbiAgICBwcm9wczoge1xuICAgICAgaWNvblNyYzpcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLmljb25TcmMsXG4gICAgICBpY29uU3JjU2V0OlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0uaWNvblNyY1NldCxcbiAgICAgIHN2ZzpcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLnN2ZyxcbiAgICAgIHRleHQ6XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFswXS5uYW1lXG4gICAgfVxuICB9KTtcbiAgdmFyIGlmX2Jsb2NrID1cbiAgLyppbnN0YWxsTWVzc2FnZSovXG4gIGN0eFsyXSAmJiBjcmVhdGVfaWZfYmxvY2skNihjdHgpO1xuICBidXR0b24wID0gbmV3IEJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XzFdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGJ1dHRvbjEgPSBuZXcgQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgb25jbGljazpcbiAgICAgIC8qb25CYWNrKi9cbiAgICAgIGN0eFsxXSxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90JDFdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHNlY3Rpb24gPSBlbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoaWNvbmRpc3BsYXkuJCQuZnJhZ21lbnQpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5jKCk7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBmb290ZXIgPSBlbGVtZW50KFwiZm9vdGVyXCIpO1xuICAgICAgYSA9IGVsZW1lbnQoXCJhXCIpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChidXR0b24wLiQkLmZyYWdtZW50KTtcbiAgICAgIHQyID0gc3BhY2UoKTtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uMS4kJC5mcmFnbWVudCk7XG4gICAgICBhdHRyKGEsIFwiaHJlZlwiLCBhX2hyZWZfdmFsdWUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0ubGluayk7XG4gICAgICBhdHRyKGEsIFwicmVsXCIsIFwibm9yZWZlcnJlciBub29wZW5lclwiKTtcbiAgICAgIGF0dHIoYSwgXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XG4gICAgICBhdHRyKGZvb3RlciwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtc2VsZWN0ZWQtd2FsbGV0LWZvb3RlciBzdmVsdGUtbWk2YWhjXCIpO1xuICAgICAgYXR0cihzZWN0aW9uLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1zZWxlY3RlZC13YWxsZXQgc3ZlbHRlLW1pNmFoY1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHNlY3Rpb24sIGFuY2hvcik7XG4gICAgICBtb3VudF9jb21wb25lbnQoaWNvbmRpc3BsYXksIHNlY3Rpb24sIG51bGwpO1xuICAgICAgYXBwZW5kKHNlY3Rpb24sIHQwKTtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2subShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MSk7XG4gICAgICBhcHBlbmQoc2VjdGlvbiwgZm9vdGVyKTtcbiAgICAgIGFwcGVuZChmb290ZXIsIGEpO1xuICAgICAgbW91bnRfY29tcG9uZW50KGJ1dHRvbjAsIGEsIG51bGwpO1xuICAgICAgYXBwZW5kKGZvb3RlciwgdDIpO1xuICAgICAgbW91bnRfY29tcG9uZW50KGJ1dHRvbjEsIGZvb3RlciwgbnVsbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBfcmVmMjYpIHtcbiAgICAgIHZhciBfcmVmMjcgPSBfc2xpY2VkVG9BcnJheShfcmVmMjYsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjI3WzBdO1xuXG4gICAgICB2YXIgaWNvbmRpc3BsYXlfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgMSkgaWNvbmRpc3BsYXlfY2hhbmdlcy5pY29uU3JjID1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLmljb25TcmM7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICAxKSBpY29uZGlzcGxheV9jaGFuZ2VzLmljb25TcmNTZXQgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0uaWNvblNyY1NldDtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIDEpIGljb25kaXNwbGF5X2NoYW5nZXMuc3ZnID1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLnN2ZztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIDEpIGljb25kaXNwbGF5X2NoYW5nZXMudGV4dCA9XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFswXS5uYW1lO1xuICAgICAgaWNvbmRpc3BsYXkuJHNldChpY29uZGlzcGxheV9jaGFuZ2VzKTtcblxuICAgICAgaWYgKFxuICAgICAgLyppbnN0YWxsTWVzc2FnZSovXG4gICAgICBjdHhbMl0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgICAgaWZfYmxvY2sucChjdHgsIGRpcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jayA9IGNyZWF0ZV9pZl9ibG9jayQ2KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgICAgIGlmX2Jsb2NrLm0oc2VjdGlvbiwgdDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgIGlmX2Jsb2NrLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbjBfY2hhbmdlcyA9IHt9O1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokJHNjb3BlLCBzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICA5KSB7XG4gICAgICAgIGJ1dHRvbjBfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24wLiRzZXQoYnV0dG9uMF9jaGFuZ2VzKTtcblxuICAgICAgaWYgKCFjdXJyZW50IHx8IGRpcnR5ICZcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgMSAmJiBhX2hyZWZfdmFsdWUgIT09IChhX2hyZWZfdmFsdWUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0ubGluaykpIHtcbiAgICAgICAgYXR0cihhLCBcImhyZWZcIiwgYV9ocmVmX3ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbjFfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qb25CYWNrKi9cbiAgICAgIDIpIGJ1dHRvbjFfY2hhbmdlcy5vbmNsaWNrID1cbiAgICAgIC8qb25CYWNrKi9cbiAgICAgIGN0eFsxXTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICA4KSB7XG4gICAgICAgIGJ1dHRvbjFfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24xLiRzZXQoYnV0dG9uMV9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGljb25kaXNwbGF5LiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbjAuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIHRyYW5zaXRpb25faW4oYnV0dG9uMS4kJC5mcmFnbWVudCwgbG9jYWwpO1xuXG4gICAgICBpZiAoIXNlY3Rpb25faW50cm8pIHtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VjdGlvbl9pbnRybyA9IGNyZWF0ZV9pbl90cmFuc2l0aW9uKHNlY3Rpb24sIGZhZGUsIHt9KTtcbiAgICAgICAgICBzZWN0aW9uX2ludHJvLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGljb25kaXNwbGF5LiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24wLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24xLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHNlY3Rpb24pO1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoaWNvbmRpc3BsYXkpO1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5kKCk7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24wKTtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGJ1dHRvbjEpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkOCgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPSAkJHByb3BzLnNlbGVjdGVkV2FsbGV0TW9kdWxlO1xuICB2YXIgb25CYWNrID0gJCRwcm9wcy5vbkJhY2s7XG4gIHZhciBpbnN0YWxsTWVzc2FnZSA9ICQkcHJvcHMuaW5zdGFsbE1lc3NhZ2U7XG5cbiAgJCRzZWxmLiRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcInNlbGVjdGVkV2FsbGV0TW9kdWxlXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIHNlbGVjdGVkV2FsbGV0TW9kdWxlID0gJCRwcm9wcy5zZWxlY3RlZFdhbGxldE1vZHVsZSk7XG4gICAgaWYgKFwib25CYWNrXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDEsIG9uQmFjayA9ICQkcHJvcHMub25CYWNrKTtcbiAgICBpZiAoXCJpbnN0YWxsTWVzc2FnZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgyLCBpbnN0YWxsTWVzc2FnZSA9ICQkcHJvcHMuaW5zdGFsbE1lc3NhZ2UpO1xuICB9O1xuXG4gIHJldHVybiBbc2VsZWN0ZWRXYWxsZXRNb2R1bGUsIG9uQmFjaywgaW5zdGFsbE1lc3NhZ2VdO1xufVxuXG52YXIgU2VsZWN0ZWRXYWxsZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQ5KSB7XG4gIF9pbmhlcml0cyhTZWxlY3RlZFdhbGxldCwgX1N2ZWx0ZUNvbXBvbmVudDkpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKFNlbGVjdGVkV2FsbGV0KTtcblxuICBmdW5jdGlvbiBTZWxlY3RlZFdhbGxldChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzOTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3RlZFdhbGxldCk7XG5cbiAgICBfdGhpczkgPSBfc3VwZXI5LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1taTZhaGMtc3R5bGVcIikpIGFkZF9jc3MkOCgpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczkpLCBvcHRpb25zLCBpbnN0YW5jZSQ4LCBjcmVhdGVfZnJhZ21lbnQkOCwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIHNlbGVjdGVkV2FsbGV0TW9kdWxlOiAwLFxuICAgICAgb25CYWNrOiAxLFxuICAgICAgaW5zdGFsbE1lc3NhZ2U6IDJcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM5O1xuICB9XG5cbiAgcmV0dXJuIFNlbGVjdGVkV2FsbGV0O1xufShTdmVsdGVDb21wb25lbnQpO1xuXG52YXIgd2FsbGV0SWNvbiA9IFwiXFxuPHN2Z1xcbmhlaWdodD1cXFwiMThcXFwiXFxudmlld0JveD1cXFwiMCAwIDE5IDE4XFxcIlxcbndpZHRoPVxcXCIxOVxcXCJcXG54bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbjxnIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZmlsbC1ydWxlPVxcXCJldmVub2RkXFxcIj5cXG5cXHQ8cGF0aFxcblxcdFxcdGQ9XFxcIm0xNS43NzIxNjE4LjAwMDA2NjIzaC0xMy4yNzQ2OTgzOWMtLjg2NzYyMDY1XFxuXFx0XFx0MC0xLjQ4NTkyNjgxLjMwNzgwODYtMS44OTc0MTA0Ni43NjExMzE5My0uNDA2MTU4MjMuNDQ3NDUwNjQtLjYwODM5MDYzXFxuXFx0XFx0MS4wNDY2MTk4OC0uNTk5Nzg5NzRcXG5cXHRcXHQxLjY0NDY0MTA3LjAwMDI5MTg3LjAwNTEyNC4wMDA0MDMzNS4wMTAyNTY1My4wMDAzMzQyMy4wMTUzODgyMnYzLjY2ODk5ODExYy4wNjY4MjQwNC0uMTE2ODU3NzYuMTQxNjI1MDctLjIyOTM4ODI3LjIyNTMzODk0LS4zMzYyODg5NS4zNjc3ODg0NS0uNDY5NTk0NjYuOTA4MTI5NTItLjgyMTE2MTQ1XFxuXFx0XFx0MS42MTg2NjEzMi0uOTU2MjMzMzl2LS41OTA5MzQyMmMwLS41NTIxNDM1My4xNzY0OTY1Ny0xLjA1NzkwMTYzLjQ3Mjc4MTczLTEuNDMzODg2NDUuMjk2MzA3NDUtLjM3NTk2Mjc1LjcyMjkyMDY1LS42MjUxMzI3MlxcblxcdFxcdDEuMTk5NjkwODgtLjYyNTEzMjcyaDExLjIzNTQ2MjM5Yy40NzY1NDc0IDAgLjkwMzI0OTcuMjQ4NTA3NjRcXG5cXHRcXHQxLjE5OTYyNC42MjQyNDk2MS4yOTYzNzQzLjM3NTc0MTk2LjQ3Mjg3MDkuODgxNjEwNDUuNDcyODcwOVxcblxcdFxcdDEuNDM0NzY5NTZ2LjQ2NTI4OTVjLjUyMzU2MjYtLjExMDQ3NzI4LjkyNjY2ODItLjM1NDQ1ODk3XFxuXFx0XFx0MS4yMjQ2MDIyLS42NzMzNzI3LjQxMTYzOTctLjQ0MDYwNjUzLjYyMTA0NjktMS4wMzM5MjUxNS42MjEwNDY5LTEuNjMwMTU4MDRzLS4yMDk0MDcyLTEuMTg5NTUxNTEtLjYyMTA0NjktMS42MzAxODAxMWMtLjQxMTYzOTYtLjQ0MDYwNjUzLTEuMDIzODYyNy0uNzM4MzQ3NjUtMS44Nzc0NjgtLjczODM0NzY1elxcXCIgLz5cXG5cXHQ8cGF0aFxcblxcdFxcdGQ9XFxcIm0xNC42MDk2MDQ3IDIuNTcxNTE3MzRoLTExLjIxOTE0MjY3Yy0uMzIwNzMwMDJcXG5cXHRcXHQwLS42MTg1NDI4LjE2NTYxNDMzLS44NDcyMjU2NC40NTc2OTczOXMtLjM3NzgyMjg2LjcwNzYzOTAxLS4zNzc4MjI4NlxcblxcdFxcdDEuMTY4MDg4MTR2LjUzOTUzOTI0Yy4wNjI2NTUyNy0uMDAzNjE3Mi4xMjY0MDA3OC0uMDA1NzAzMTkuMTkxMjU4NzgtLjAwNjE2OTIxLjAwNTE4NDgyLS4wMDAzMjkyNC4wMTAzNzk2MS0uMDAwNDc3MjcuMDE1NTc0ODItLjAwMDQ0MzgzaC4wMTMyNjA4NFxcblxcdFxcdDEzLjI0MjE1NTkzYy4wNzA2NjUyIDBcXG5cXHRcXHQuMTM5NTI4MS0uMDAyMjg1NzEuMjA2OTIyNi0uMDA2MzAyMzV2LS41MjY3MTI2MmMwLS40NjE2NDc0Ni0uMTQ5MTYyMy0uODc3MTE0NjQtLjM3Nzc1NjEtMS4xNjg4NDI2NC0uMjI4NjE2MS0uMjkxNzUwMTktLjUyNjM2MjItLjQ1Njk0Mjg5LS44NDczMTQ3LS40NTY5NDI4OXpcXFwiIC8+XFxuXFx0PHBhdGhcXG5cXHRcXHRkPVxcXCJtMTguMjcwNjc2N1xcblxcdFxcdDMuOTI0ODEyMDNjLS4wODU3MTk1LjEzMjc4MDQ3LS4xODM3ODMyLjI1OTA2OTkzLS4yOTQ1NDc4LjM3NjgyOS0uNDk1NDY2LjUyNjgwMTg0LTEuMjQzOTIzNi44NzQwMDQ2OC0yLjIwNDUyOTYuODc0MDA0NjhoLTEzLjI2MTQ0NzY1Yy0uOTMyODY0NzFcXG5cXHRcXHQwLTEuNTM2Mjg3NzcuMzM3NjYzNjktMS45MzI2ODczMS44NDAzNjU1cy0uNTc3NDY0MzRcXG5cXHRcXHQxLjE4ODc3NDQzLS41Nzc0NjQzNFxcblxcdFxcdDEuODcyMTI3ODV2LjQxMjUyOTUxYy4xMzcyNTgwOC4xNDgxNzQ2Ny4yOTIyOTczMi4yMDQ1MDgyNC41MDAxNjc1NC4yMzIxMTY5My4yMTE3MDI3Ni4wMjgxMTMwNS40NjgxNDgwOS4wMTQwMzQ1OS43NDIxMjk0Ny4wMjE3MDk3N2g1LjI1OTc5MTkxYy45NDE0NjU2NFxcblxcdFxcdDAgMS42NzU4ODU0OC4zNjA4NDI3MSAyLjE1ODc4NDM1LjkwMzQxMTU1LjQ4Mjg5ODg3LjU0MjU5MDc4LjcxODg2NjlcXG5cXHRcXHQxLjI1NjQ5MTM4LjcxODg2NjkgMS45NjczODc2OHMtLjIzNTk2ODAzIDEuNDI0Nzk2OS0uNzE4ODY2OVxcblxcdFxcdDEuOTY3Mzg3N2MtLjQ4Mjg5ODg3LjU0MjU2ODktMS4yMTczMTg3MS45MDMzODk2LTIuMTU4Nzg0MzUuOTAzMzg5NmgtNS4yNTk3OTE5MWMtLjI1MDM4NDU4XFxuXFx0XFx0MC0uNTU3NDk5NTMtLjAxNzEwNDYtLjg0OTA4MzgxLS4wODY2MTk4LS4xMzUyMDgxMi0uMDMyMjU3Ni0uMjcwMDM3NDQtLjA3NTYxMTQtLjM5MzIxMzItLjEzODA2NTN2MS41MzAyMzE4YzBcXG5cXHRcXHQxLjMyMDEyOTUgMS4wOTU2MTM1OCAyLjM5ODM4MTUgMi40MzY5NzcwNlxcblxcdFxcdDIuMzk4MzgxNWgxMy4zOTY3MjI1NGMxLjM0MTM2MzUgMCAyLjQzNjk3NzEtMS4wNzgyNTJcXG5cXHRcXHQyLjQzNjk3NzEtMi4zOTgzODE1elxcXCIgLz5cXG5cXHQ8cGF0aFxcblxcdFxcdGQ9XFxcIm0wXFxuXFx0XFx0OC43OTY5OTI0OGMuMTQyNjA2MjguMDY5NTkwMjIuMjk4NjQ2NjUuMTEwNTAzNzYuNDQ1NTc1MDEuMTI5OTY0NS4yNzUzMjA4LjAzNjQ5MTYzLjU0NDg0OTEyLjAxMzM1MzI3Ljc5MzY4MDQ5LjAyMDU3NzE3LjAwMjMwMi4wMDAwMzUwNi4wMDQ2MDQ0MS4wMDAwMzUwNi4wMDY5MDY0MVxcblxcdFxcdDBoNS4yNTY0MDM4M2MuODI4Mjc5MzkgMCAxLjQyMjA5NzIuMzAxNTY0OTJcXG5cXHRcXHQxLjgyNDA3MjcuNzUyNDg5NDEuNDAxOTk3NzcuNDUwOTQ2MzQuNjA1NjkyMzkgMS4wNjIyMTk1NC42MDU2OTIzOVxcblxcdFxcdDEuNjc2MDEwMTQgMCAuNjEzNzQ2Ny0uMjAzNjk0NjIgMS4yMjUwNjM3LS42MDU2OTIzOVxcblxcdFxcdDEuNjc1OTg4Mi0uNDAxOTc1NS40NTA5NDYzLS45OTU3OTMzMS43NTI0ODk0LTEuODI0MDcyNy43NTI0ODk0aC01LjI1NjQwMzgzYy0uMjI4MzEyNjRcXG5cXHRcXHQwLS41MDg0Njc5Mi0uMDE4ODI1OS0uNzQ0OTM0NTgtLjA3NTIzOC0uMjM2NDY2NjYtLjA1NjMyNDUtLjQxNDE2MTk3LS4xNTE3Njc2LS40ODczNDc2Ny0uMjU5OTcyOC0uMDA0NDAwMTMtLjAwNDcyMDMtLjAwOTAwODgzLS4wMDkyNDg3LS4wMTM4Nzk2Ni0uMDEzNTcyMnYtNC42NTg2MDQ0OHptNi40MjYwMTU5NVxcblxcdFxcdDEuNDIyODg5MTJjLS42Mjk3OTc5OSAwLTEuMTQ4NzM2OTMuNTAyNDExMS0xLjE0ODczNjkzIDEuMTIxODkzMyAwXFxuXFx0XFx0LjYyMTE2NzcuNTE4OTM4OTQgMS4xMjg3NDUgMS4xNDg3MzY5MyAxLjEyODc0NS42Mjk4NDI1NiAwXFxuXFx0XFx0MS4xNDE3ODU5Ny0uNTA4MjEyMiAxLjE0MTc4NTk3LTEuMTI4NzQ1XFxuXFx0XFx0MC0uNjE4ODY5Mi0uNTExOTQzNDEtMS4xMjE4OTMzLTEuMTQxNzg1OTctMS4xMjE4OTMzelxcXCIgLz5cXG48L2c+XFxuPC9zdmc+XFxuXFx0XCI7XG4vKiBzcmMvdmlld3MvV2FsbGV0U2VsZWN0LnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjI0LjAgKi9cblxuZnVuY3Rpb24gYWRkX2NzcyQ5KCkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmlkID0gXCJzdmVsdGUtcmozZnBhLXN0eWxlXCI7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gXCJwLnN2ZWx0ZS1yajNmcGEuc3ZlbHRlLXJqM2ZwYXtmb250LXNpemU6MC44ODllbTttYXJnaW46MS42ZW0gMCAwIDA7Zm9udC1mYW1pbHk6aW5oZXJpdH1kaXYuc3ZlbHRlLXJqM2ZwYS5zdmVsdGUtcmozZnBhe2Rpc3BsYXk6ZmxleDtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufWRpdi5zdmVsdGUtcmozZnBhIHNwYW4uc3ZlbHRlLXJqM2ZwYXtjb2xvcjojNGE5MGUyO2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7bWFyZ2luLXRvcDowLjY2ZW07Y3Vyc29yOnBvaW50ZXJ9XCI7XG4gIGFwcGVuZChkb2N1bWVudC5oZWFkLCBzdHlsZSk7XG59IC8vICgxODA6MCkgeyNpZiBtb2RhbERhdGF9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrJDcoY3R4KSB7XG4gIHZhciBtb2RhbDtcbiAgdmFyIGN1cnJlbnQ7XG4gIG1vZGFsID0gbmV3IE1vZGFsKHtcbiAgICBwcm9wczoge1xuICAgICAgY2xvc2VNb2RhbDpcbiAgICAgIC8qZnVuY18yKi9cbiAgICAgIGN0eFsxNV0sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdCQyXVxuICAgICAgfSxcbiAgICAgICQkc2NvcGU6IHtcbiAgICAgICAgY3R4OiBjdHhcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KG1vZGFsLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChtb2RhbCwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBtb2RhbF9jaGFuZ2VzID0ge307XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiQkc2NvcGUsIG1vZGFsRGF0YSwgc2hvd1dhbGxldERlZmluaXRpb24sIGxvYWRpbmdXYWxsZXQsIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzLCBzZWxlY3RlZFdhbGxldE1vZHVsZSwgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCwgaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgMzM1NTQ1NTkpIHtcbiAgICAgICAgbW9kYWxfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtb2RhbC4kc2V0KG1vZGFsX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4obW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQobW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbCwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgyMTA6NCkgezplbHNlfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9lbHNlX2Jsb2NrJDMoY3R4KSB7XG4gIHZhciBzZWxlY3RlZHdhbGxldDtcbiAgdmFyIGN1cnJlbnQ7XG4gIHNlbGVjdGVkd2FsbGV0ID0gbmV3IFNlbGVjdGVkV2FsbGV0KHtcbiAgICBwcm9wczoge1xuICAgICAgc2VsZWN0ZWRXYWxsZXRNb2R1bGU6XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFs0XSxcbiAgICAgIG9uQmFjazpcbiAgICAgIC8qZnVuY18xKi9cbiAgICAgIGN0eFsxNF0sXG4gICAgICBpbnN0YWxsTWVzc2FnZTpcbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgY3R4WzNdXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChzZWxlY3RlZHdhbGxldC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQoc2VsZWN0ZWR3YWxsZXQsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgc2VsZWN0ZWR3YWxsZXRfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgMTYpIHNlbGVjdGVkd2FsbGV0X2NoYW5nZXMuc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbNF07XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSwgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCovXG4gICAgICAyMCkgc2VsZWN0ZWR3YWxsZXRfY2hhbmdlcy5vbkJhY2sgPVxuICAgICAgLypmdW5jXzEqL1xuICAgICAgY3R4WzE0XTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgICAgIDgpIHNlbGVjdGVkd2FsbGV0X2NoYW5nZXMuaW5zdGFsbE1lc3NhZ2UgPVxuICAgICAgLyppbnN0YWxsTWVzc2FnZSovXG4gICAgICBjdHhbM107XG4gICAgICBzZWxlY3RlZHdhbGxldC4kc2V0KHNlbGVjdGVkd2FsbGV0X2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oc2VsZWN0ZWR3YWxsZXQuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoc2VsZWN0ZWR3YWxsZXQuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChzZWxlY3RlZHdhbGxldCwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgxODM6NCkgeyNpZiAhc2VsZWN0ZWRXYWxsZXRNb2R1bGV9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzEkMyhjdHgpIHtcbiAgdmFyIF9wO1xuXG4gIHZhciByYXdfdmFsdWUgPVxuICAvKm1vZGFsRGF0YSovXG4gIGN0eFswXS5kZXNjcmlwdGlvbiArIFwiXCI7XG4gIHZhciB0MDtcbiAgdmFyIHdhbGxldHNfMTtcbiAgdmFyIHQxO1xuICB2YXIgZGl2O1xuICB2YXIgc3BhbjtcbiAgdmFyIHQzO1xuICB2YXIgdDQ7XG4gIHZhciBpZl9ibG9jazFfYW5jaG9yO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIG1vdW50ZWQ7XG4gIHZhciBkaXNwb3NlO1xuICB3YWxsZXRzXzEgPSBuZXcgV2FsbGV0cyh7XG4gICAgcHJvcHM6IHtcbiAgICAgIG1vZGFsRGF0YTpcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXSxcbiAgICAgIGhhbmRsZVdhbGxldFNlbGVjdDpcbiAgICAgIC8qaGFuZGxlV2FsbGV0U2VsZWN0Ki9cbiAgICAgIGN0eFs5XSxcbiAgICAgIGxvYWRpbmdXYWxsZXQ6XG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgY3R4WzVdLFxuICAgICAgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXM6XG4gICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgIGN0eFs2XSxcbiAgICAgIHNob3dBbGxXYWxsZXRzOlxuICAgICAgLypzaG93QWxsV2FsbGV0cyovXG4gICAgICBjdHhbOF1cbiAgICB9XG4gIH0pO1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyptb2JpbGVEZXZpY2UqL1xuICBjdHhbN10gJiYgY3JlYXRlX2lmX2Jsb2NrXzMoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrMSA9XG4gIC8qc2hvd1dhbGxldERlZmluaXRpb24qL1xuICBjdHhbMV0gJiYgY3JlYXRlX2lmX2Jsb2NrXzIkMShjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBfcCA9IGVsZW1lbnQoXCJwXCIpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudCh3YWxsZXRzXzEuJCQuZnJhZ21lbnQpO1xuICAgICAgdDEgPSBzcGFjZSgpO1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIldoYXQgaXMgYSB3YWxsZXQ/XCI7XG4gICAgICB0MyA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuYygpO1xuICAgICAgdDQgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmMoKTtcbiAgICAgIGlmX2Jsb2NrMV9hbmNob3IgPSBlbXB0eSgpO1xuICAgICAgYXR0cihfcCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtc2VsZWN0LWRlc2NyaXB0aW9uIHN2ZWx0ZS1yajNmcGFcIik7XG4gICAgICBhdHRyKHNwYW4sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXNlbGVjdC13YWxsZXQtaW5mbyBzdmVsdGUtcmozZnBhXCIpO1xuICAgICAgYXR0cihkaXYsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXNlbGVjdC1pbmZvLWNvbnRhaW5lciBzdmVsdGUtcmozZnBhXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgX3AsIGFuY2hvcik7XG4gICAgICBfcC5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIG1vdW50X2NvbXBvbmVudCh3YWxsZXRzXzEsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGRpdiwgc3Bhbik7XG4gICAgICBhcHBlbmQoZGl2LCB0Myk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubShkaXYsIG51bGwpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDQsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpZl9ibG9jazFfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICBkaXNwb3NlID0gbGlzdGVuKHNwYW4sIFwiY2xpY2tcIixcbiAgICAgICAgLypjbGlja19oYW5kbGVyKi9cbiAgICAgICAgY3R4WzEyXSk7XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoKCFjdXJyZW50IHx8IGRpcnR5ICZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIDEpICYmIHJhd192YWx1ZSAhPT0gKHJhd192YWx1ZSA9XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMF0uZGVzY3JpcHRpb24gKyBcIlwiKSkgX3AuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuICAgICAgdmFyIHdhbGxldHNfMV9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgd2FsbGV0c18xX2NoYW5nZXMubW9kYWxEYXRhID1cbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgMzIpIHdhbGxldHNfMV9jaGFuZ2VzLmxvYWRpbmdXYWxsZXQgPVxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIGN0eFs1XTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgIDY0KSB3YWxsZXRzXzFfY2hhbmdlcy5zaG93aW5nQWxsV2FsbGV0TW9kdWxlcyA9XG4gICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgIGN0eFs2XTtcbiAgICAgIHdhbGxldHNfMS4kc2V0KHdhbGxldHNfMV9jaGFuZ2VzKTtcbiAgICAgIGlmIChcbiAgICAgIC8qbW9iaWxlRGV2aWNlKi9cbiAgICAgIGN0eFs3XSkgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgIGlmIChcbiAgICAgIC8qc2hvd1dhbGxldERlZmluaXRpb24qL1xuICAgICAgY3R4WzFdKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgICBpZl9ibG9jazEucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLypzaG93V2FsbGV0RGVmaW5pdGlvbiovXG4gICAgICAgICAgMikge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazEsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazEgPSBjcmVhdGVfaWZfYmxvY2tfMiQxKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgaWZfYmxvY2sxLm0oaWZfYmxvY2sxX2FuY2hvci5wYXJlbnROb2RlLCBpZl9ibG9jazFfYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgaWZfYmxvY2sxLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrMSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbih3YWxsZXRzXzEuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQod2FsbGV0c18xLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazApO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChfcCk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDApO1xuICAgICAgZGVzdHJveV9jb21wb25lbnQod2FsbGV0c18xLCBkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQxKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmQoKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0NCk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGlmX2Jsb2NrMV9hbmNob3IpO1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuICAgICAgZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDE5OTo4KSB7I2lmIG1vYmlsZURldmljZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMyhjdHgpIHtcbiAgdmFyIGJ1dHRvbjtcbiAgdmFyIGN1cnJlbnQ7XG4gIGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgIHByb3BzOiB7XG4gICAgICBvbmNsaWNrOlxuICAgICAgLypmdW5jKi9cbiAgICAgIGN0eFsxM10sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdF8xJDFdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgYnV0dG9uX2NoYW5nZXMgPSB7fTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICAzMzU1NDQzMikge1xuICAgICAgICBidXR0b25fY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24uJHNldChidXR0b25fY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoYnV0dG9uLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDIwMDoxMCkgPEJ1dHRvbiBvbmNsaWNrPXsoKSA9PiBmaW5pc2goeyBjb21wbGV0ZWQ6IGZhbHNlIH0pfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90XzEkMShjdHgpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KFwiRGlzbWlzc1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDIwMzo2KSB7I2lmIHNob3dXYWxsZXREZWZpbml0aW9ufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18yJDEoY3R4KSB7XG4gIHZhciBfcDI7XG5cbiAgdmFyIHJhd192YWx1ZSA9XG4gIC8qbW9kYWxEYXRhKi9cbiAgY3R4WzBdLmV4cGxhbmF0aW9uICsgXCJcIjtcbiAgdmFyIHBfaW50cm87XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIF9wMiA9IGVsZW1lbnQoXCJwXCIpO1xuICAgICAgYXR0cihfcDIsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXNlbGVjdC13YWxsZXQtZGVmaW5pdGlvbiBzdmVsdGUtcmozZnBhXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgX3AyLCBhbmNob3IpO1xuICAgICAgX3AyLmlubmVySFRNTCA9IHJhd192YWx1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIDEgJiYgcmF3X3ZhbHVlICE9PSAocmF3X3ZhbHVlID1cbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXS5leHBsYW5hdGlvbiArIFwiXCIpKSBfcDIuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKCFwX2ludHJvKSB7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBfaW50cm8gPSBjcmVhdGVfaW5fdHJhbnNpdGlvbihfcDIsIGZhZGUsIHt9KTtcbiAgICAgICAgICBwX2ludHJvLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbzogbm9vcCxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKF9wMik7XG4gICAgfVxuICB9O1xufSAvLyAoMTgxOjIpIDxNb2RhbCBjbG9zZU1vZGFsPXsoKSA9PiBmaW5pc2goeyBjb21wbGV0ZWQ6IGZhbHNlIH0pfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90JDIoY3R4KSB7XG4gIHZhciBtb2RhbGhlYWRlcjtcbiAgdmFyIHQ7XG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gIHZhciBpZl9ibG9jaztcbiAgdmFyIGlmX2Jsb2NrX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIG1vZGFsaGVhZGVyID0gbmV3IE1vZGFsSGVhZGVyKHtcbiAgICBwcm9wczoge1xuICAgICAgaWNvbjogd2FsbGV0SWNvbixcbiAgICAgIGhlYWRpbmc6XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMF0uaGVhZGluZ1xuICAgIH1cbiAgfSk7XG4gIHZhciBpZl9ibG9ja19jcmVhdG9ycyA9IFtjcmVhdGVfaWZfYmxvY2tfMSQzLCBjcmVhdGVfZWxzZV9ibG9jayQzXTtcbiAgdmFyIGlmX2Jsb2NrcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9ibG9ja190eXBlKGN0eCwgZGlydHkpIHtcbiAgICBpZiAoIVxuICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgIGN0eFs0XSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICBpZl9ibG9jayA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdID0gaWZfYmxvY2tfY3JlYXRvcnNbY3VycmVudF9ibG9ja190eXBlX2luZGV4XShjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50KTtcbiAgICAgIHQgPSBzcGFjZSgpO1xuICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgaWZfYmxvY2tfYW5jaG9yID0gZW1wdHkoKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChtb2RhbGhlYWRlciwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdCwgYW5jaG9yKTtcbiAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaWZfYmxvY2tfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBtb2RhbGhlYWRlcl9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgbW9kYWxoZWFkZXJfY2hhbmdlcy5oZWFkaW5nID1cbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXS5oZWFkaW5nO1xuICAgICAgbW9kYWxoZWFkZXIuJHNldChtb2RhbGhlYWRlcl9jaGFuZ2VzKTtcbiAgICAgIHZhciBwcmV2aW91c19ibG9ja19pbmRleCA9IGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleDtcbiAgICAgIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPT09IHByZXZpb3VzX2Jsb2NrX2luZGV4KSB7XG4gICAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLnAoY3R4LCBkaXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2tzW3ByZXZpb3VzX2Jsb2NrX2luZGV4XSwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2Nrc1twcmV2aW91c19ibG9ja19pbmRleF0gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgIGlmX2Jsb2NrID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF07XG5cbiAgICAgICAgaWYgKCFpZl9ibG9jaykge1xuICAgICAgICAgIGlmX2Jsb2NrID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0gPSBpZl9ibG9ja19jcmVhdG9yc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jaywgMSk7XG4gICAgICAgIGlmX2Jsb2NrLm0oaWZfYmxvY2tfYW5jaG9yLnBhcmVudE5vZGUsIGlmX2Jsb2NrX2FuY2hvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihtb2RhbGhlYWRlci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jayk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jayk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQobW9kYWxoZWFkZXIsIGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgICBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XS5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaWZfYmxvY2tfYW5jaG9yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQ5KGN0eCkge1xuICB2YXIgaWZfYmxvY2tfYW5jaG9yO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIGlmX2Jsb2NrID1cbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMF0gJiYgY3JlYXRlX2lmX2Jsb2NrJDcoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5jKCk7XG4gICAgICBpZl9ibG9ja19hbmNob3IgPSBlbXB0eSgpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIGlmX2Jsb2NrX2FuY2hvciwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYyOCkge1xuICAgICAgdmFyIF9yZWYyOSA9IF9zbGljZWRUb0FycmF5KF9yZWYyOCwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMjlbMF07XG5cbiAgICAgIGlmIChcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgICBpZl9ibG9jay5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5ICZcbiAgICAgICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAgICAgMSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jaywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrID0gY3JlYXRlX2lmX2Jsb2NrJDcoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jay5jKCk7XG4gICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jaywgMSk7XG4gICAgICAgICAgaWZfYmxvY2subShpZl9ibG9ja19hbmNob3IucGFyZW50Tm9kZSwgaWZfYmxvY2tfYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jaykge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2ssIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jayA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2spO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2suZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGlmX2Jsb2NrX2FuY2hvcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsb2NrU2Nyb2xsKCkge1xuICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDkoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyIF8kJHByb3BzJG1vZHVsZSA9ICQkcHJvcHMubW9kdWxlLFxuICAgICAgbW9kdWxlID0gXyQkcHJvcHMkbW9kdWxlID09PSB2b2lkIDAgPyB7XG4gICAgaGVhZGluZzogXCJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB3YWxsZXRzOiBbXVxuICB9IDogXyQkcHJvcHMkbW9kdWxlO1xuICB2YXIgbW9kYWxEYXRhO1xuICB2YXIgc2hvd1dhbGxldERlZmluaXRpb247XG4gIHZhciB3YWxsZXRBbHJlYWR5SW5zdGFsbGVkO1xuICB2YXIgaW5zdGFsbE1lc3NhZ2U7XG4gIHZhciBzZWxlY3RlZFdhbGxldE1vZHVsZTtcblxuICB2YXIgX2dldF9zdG9yZV92YWx1ZTIgPSBnZXRfc3RvcmVfdmFsdWUoYXBwKSxcbiAgICAgIG1vYmlsZURldmljZSA9IF9nZXRfc3RvcmVfdmFsdWUyLm1vYmlsZURldmljZSxcbiAgICAgIG9zID0gX2dldF9zdG9yZV92YWx1ZTIub3M7XG5cbiAgdmFyIF9tb2R1bGUgPSBtb2R1bGUsXG4gICAgICBoZWFkaW5nID0gX21vZHVsZS5oZWFkaW5nLFxuICAgICAgZGVzY3JpcHRpb24gPSBfbW9kdWxlLmRlc2NyaXB0aW9uLFxuICAgICAgZXhwbGFuYXRpb24gPSBfbW9kdWxlLmV4cGxhbmF0aW9uLFxuICAgICAgd2FsbGV0cyA9IF9tb2R1bGUud2FsbGV0cztcbiAgdmFyIHByaW1hcnlXYWxsZXRzO1xuICB2YXIgc2Vjb25kYXJ5V2FsbGV0cztcbiAgdmFyIGxvYWRpbmdXYWxsZXQgPSB1bmRlZmluZWQ7XG4gIHZhciBzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyA9IGZhbHNlO1xuXG4gIHZhciBzaG93QWxsV2FsbGV0cyA9IGZ1bmN0aW9uIHNob3dBbGxXYWxsZXRzKCkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoNiwgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMgPSB0cnVlKTtcbiAgfTtcblxuICB2YXIgb3JpZ2luYWxPdmVyZmxvd1ZhbHVlO1xuICBvbk1vdW50KGZ1bmN0aW9uICgpIHtcbiAgICBvcmlnaW5hbE92ZXJmbG93VmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbG9ja1Njcm9sbCk7XG4gIH0pO1xuICBvbkRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxvY2tTY3JvbGwpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3JpZ2luYWxPdmVyZmxvd1ZhbHVlO1xuICB9KTtcbiAgcmVuZGVyV2FsbGV0U2VsZWN0KCk7XG5cbiAgZnVuY3Rpb24gcmVuZGVyV2FsbGV0U2VsZWN0KCkge1xuICAgIHJldHVybiBfcmVuZGVyV2FsbGV0U2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVuZGVyV2FsbGV0U2VsZWN0KCkge1xuICAgIF9yZW5kZXJXYWxsZXRTZWxlY3QgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgdmFyIGFwcFN0YXRlLCBkZXZpY2VXYWxsZXRzLCBfbW9kdWxlMjtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXBwU3RhdGUgPSBnZXRfc3RvcmVfdmFsdWUoYXBwKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0cztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB3YWxsZXRzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgIGRldmljZVdhbGxldHMgPSB3YWxsZXRzLmZpbHRlcihmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldFttb2JpbGVEZXZpY2UgPyBcIm1vYmlsZVwiIDogXCJkZXNrdG9wXCJdO1xuICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgICAgICAgICAgIHZhciBfd2FsbGV0JG9zRXhjbHVzaW9ucyA9IHdhbGxldC5vc0V4Y2x1c2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9zRXhjbHVzaW9ucyA9IF93YWxsZXQkb3NFeGNsdXNpb25zID09PSB2b2lkIDAgPyBbXSA6IF93YWxsZXQkb3NFeGNsdXNpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3NFeGNsdXNpb25zLmluY2x1ZGVzKG9zLm5hbWUpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoZGV2aWNlV2FsbGV0cy5maW5kKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LnByZWZlcnJlZDtcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBwcmVmZXJyZWQgd2FsbGV0cywgdGhlbiBzcGxpdCBpbiB0byBwcmVmZXJyZWQgYW5kIG5vdCBwcmVmZXJyZWRcbiAgICAgICAgICAgICAgICBwcmltYXJ5V2FsbGV0cyA9IGRldmljZVdhbGxldHMuZmlsdGVyKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQucHJlZmVycmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlY29uZGFyeVdhbGxldHMgPSBkZXZpY2VXYWxsZXRzLmZpbHRlcihmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gIXdhbGxldC5wcmVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG1ha2UgdGhlIGZpcnN0IDQgd2FsbGV0cyBwcmVmZXJyZWRcbiAgICAgICAgICAgICAgICBwcmltYXJ5V2FsbGV0cyA9IGRldmljZVdhbGxldHMuc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5V2FsbGV0cyA9IGRldmljZVdhbGxldHMubGVuZ3RoID4gNCA/IGRldmljZVdhbGxldHMuc2xpY2UoNCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWFwcFN0YXRlLmF1dG9TZWxlY3RXYWxsZXQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX21vZHVsZTIgPSBkZXZpY2VXYWxsZXRzLmZpbmQoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5uYW1lID09PSBhcHBTdGF0ZS5hdXRvU2VsZWN0V2FsbGV0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhdXRvU2VsZWN0V2FsbGV0OiBcIlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICghX21vZHVsZTIpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGFuZGxlV2FsbGV0U2VsZWN0KF9tb2R1bGUyLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgwLCBtb2RhbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGluZzogaGVhZGluZyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uLFxuICAgICAgICAgICAgICAgIHByaW1hcnlXYWxsZXRzOiBwcmltYXJ5V2FsbGV0cyxcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlXYWxsZXRzOiBzZWNvbmRhcnlXYWxsZXRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHdhbGxldFNlbGVjdERpc3BsYXllZFVJOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9yZW5kZXJXYWxsZXRTZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVdhbGxldFNlbGVjdChfeDQsIF94NSkge1xuICAgIHJldHVybiBfaGFuZGxlV2FsbGV0U2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlV2FsbGV0U2VsZWN0KCkge1xuICAgIF9oYW5kbGVXYWxsZXRTZWxlY3QgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KG1vZHVsZSwgYXV0b1NlbGVjdGVkKSB7XG4gICAgICB2YXIgY3VycmVudFdhbGxldEludGVyZmFjZSwgX2dldF9zdG9yZV92YWx1ZTMsIGJyb3dzZXIsIG9zLCBfeWllbGQkbW9kdWxlJHdhbGxldCwgcHJvdmlkZXIsIHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlLCBpbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY3VycmVudFdhbGxldEludGVyZmFjZSA9IGdldF9zdG9yZV92YWx1ZSh3YWxsZXRJbnRlcmZhY2UpO1xuICAgICAgICAgICAgICBfZ2V0X3N0b3JlX3ZhbHVlMyA9IGdldF9zdG9yZV92YWx1ZShhcHApLCBicm93c2VyID0gX2dldF9zdG9yZV92YWx1ZTMuYnJvd3Nlciwgb3MgPSBfZ2V0X3N0b3JlX3ZhbHVlMy5vcztcblxuICAgICAgICAgICAgICBpZiAoIShjdXJyZW50V2FsbGV0SW50ZXJmYWNlICYmIGN1cnJlbnRXYWxsZXRJbnRlcmZhY2UubmFtZSA9PT0gbW9kdWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmluaXNoKHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICQkaW52YWxpZGF0ZSg1LCBsb2FkaW5nV2FsbGV0ID0gbW9kdWxlLm5hbWUpO1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiBtb2R1bGUud2FsbGV0KHtcbiAgICAgICAgICAgICAgICBnZXRQcm92aWRlck5hbWU6IGdldFByb3ZpZGVyTmFtZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMZWdhY3lQcm92aWRlckludGVyZmFjZTogY3JlYXRlTGVnYWN5UHJvdmlkZXJJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlTW9kZXJuUHJvdmlkZXJJbnRlcmZhY2U6IGNyZWF0ZU1vZGVyblByb3ZpZGVySW50ZXJmYWNlLFxuICAgICAgICAgICAgICAgIEJpZ051bWJlcjogQmlnTnVtYmVyLFxuICAgICAgICAgICAgICAgIGdldE5ldHdvcms6IGdldE5ldHdvcmssXG4gICAgICAgICAgICAgICAgZ2V0QWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBnZXRCYWxhbmNlOiBnZXRCYWxhbmNlLFxuICAgICAgICAgICAgICAgIHJlc2V0V2FsbGV0U3RhdGU6IHJlc2V0V2FsbGV0U3RhdGUsXG4gICAgICAgICAgICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtOYW1lLFxuICAgICAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICAgICAgb3M6IG9zXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF95aWVsZCRtb2R1bGUkd2FsbGV0ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgIHByb3ZpZGVyID0gX3lpZWxkJG1vZHVsZSR3YWxsZXQucHJvdmlkZXI7XG4gICAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlID0gX3lpZWxkJG1vZHVsZSR3YWxsZXRbXCJpbnRlcmZhY2VcIl07XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gX3lpZWxkJG1vZHVsZSR3YWxsZXQuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICQkaW52YWxpZGF0ZSg1LCBsb2FkaW5nV2FsbGV0ID0gdW5kZWZpbmVkKTsgLy8gaWYgbm8gaW50ZXJmYWNlIHRoZW4gdGhlIHVzZXIgZG9lcyBub3QgaGF2ZSB0aGUgd2FsbGV0IHRoZXkgc2VsZWN0ZWQgaW5zdGFsbGVkIG9yIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZFdhbGxldEludGVyZmFjZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoNCwgc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPSBtb2R1bGUpO1xuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMiwgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCA9IHByb3ZpZGVyICYmIGdldFByb3ZpZGVyTmFtZShwcm92aWRlcikpO1xuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMywgaW5zdGFsbE1lc3NhZ2UgPSBtb2R1bGUuaW5zdGFsbE1lc3NhZ2UgJiYgbW9kdWxlLmluc3RhbGxNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2FsbGV0OiB3YWxsZXRBbHJlYWR5SW5zdGFsbGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0OiBzZWxlY3RlZFdhbGxldE1vZHVsZS5uYW1lXG4gICAgICAgICAgICAgIH0pKTsgLy8gaWYgaXQgd2FzIGF1dG9TZWxlY3RlZCB0aGVuIHdlIG5lZWQgdG8gYWRkIG1vZGFsRGF0YSB0byBzaG93IHRoZSBtb2RhbFxuXG4gICAgICAgICAgICAgIGlmIChhdXRvU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMCwgbW9kYWxEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaGVhZGluZzogaGVhZGluZyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICAgICAgICAgICAgICAgIHByaW1hcnlXYWxsZXRzOiBwcmltYXJ5V2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVdhbGxldHM6IHNlY29uZGFyeVdhbGxldHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgd2FsbGV0SW50ZXJmYWNlLnVwZGF0ZShmdW5jdGlvbiAoY3VycmVudEludGVyZmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJmYWNlICYmIGN1cnJlbnRJbnRlcmZhY2UuZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudEludGVyZmFjZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2FsbGV0LnNldCh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBkYXNoYm9hcmQ6IHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlLmRhc2hib2FyZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0OiBzZWxlY3RlZFdhbGxldEludGVyZmFjZS5jb25uZWN0LFxuICAgICAgICAgICAgICAgIHR5cGU6IG1vZHVsZS50eXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBmaW5pc2goe1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfaGFuZGxlV2FsbGV0U2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2gob3B0aW9ucykge1xuICAgICQkaW52YWxpZGF0ZSgwLCBtb2RhbERhdGEgPSBudWxsKTtcbiAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICB3YWxsZXRTZWxlY3RJblByb2dyZXNzOiBmYWxzZSxcbiAgICAgICAgd2FsbGV0U2VsZWN0Q29tcGxldGVkOiBvcHRpb25zLmNvbXBsZXRlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2xpY2tfaGFuZGxlciA9IGZ1bmN0aW9uIGNsaWNrX2hhbmRsZXIoKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgxLCBzaG93V2FsbGV0RGVmaW5pdGlvbiA9ICFzaG93V2FsbGV0RGVmaW5pdGlvbik7XG4gIH07XG5cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiBmaW5pc2goe1xuICAgICAgY29tcGxldGVkOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBmdW5jXzEgPSBmdW5jdGlvbiBmdW5jXzEoKSB7XG4gICAgJCRpbnZhbGlkYXRlKDQsIHNlbGVjdGVkV2FsbGV0TW9kdWxlID0gbnVsbCk7XG4gICAgJCRpbnZhbGlkYXRlKDIsIHdhbGxldEFscmVhZHlJbnN0YWxsZWQgPSBudWxsKTtcbiAgfTtcblxuICB2YXIgZnVuY18yID0gZnVuY3Rpb24gZnVuY18yKCkge1xuICAgIHJldHVybiBmaW5pc2goe1xuICAgICAgY29tcGxldGVkOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJtb2R1bGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMTEsIG1vZHVsZSA9ICQkcHJvcHMubW9kdWxlKTtcbiAgfTtcblxuICByZXR1cm4gW21vZGFsRGF0YSwgc2hvd1dhbGxldERlZmluaXRpb24sIHdhbGxldEFscmVhZHlJbnN0YWxsZWQsIGluc3RhbGxNZXNzYWdlLCBzZWxlY3RlZFdhbGxldE1vZHVsZSwgbG9hZGluZ1dhbGxldCwgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMsIG1vYmlsZURldmljZSwgc2hvd0FsbFdhbGxldHMsIGhhbmRsZVdhbGxldFNlbGVjdCwgZmluaXNoLCBtb2R1bGUsIGNsaWNrX2hhbmRsZXIsIGZ1bmMsIGZ1bmNfMSwgZnVuY18yXTtcbn1cblxudmFyIFdhbGxldFNlbGVjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N2ZWx0ZUNvbXBvbmVudDEwKSB7XG4gIF9pbmhlcml0cyhXYWxsZXRTZWxlY3QsIF9TdmVsdGVDb21wb25lbnQxMCk7XG5cbiAgdmFyIF9zdXBlcjEwID0gX2NyZWF0ZVN1cGVyKFdhbGxldFNlbGVjdCk7XG5cbiAgZnVuY3Rpb24gV2FsbGV0U2VsZWN0KG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMxMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYWxsZXRTZWxlY3QpO1xuXG4gICAgX3RoaXMxMCA9IF9zdXBlcjEwLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1yajNmcGEtc3R5bGVcIikpIGFkZF9jc3MkOSgpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczEwKSwgb3B0aW9ucywgaW5zdGFuY2UkOSwgY3JlYXRlX2ZyYWdtZW50JDksIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICBtb2R1bGU6IDExXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMTA7XG4gIH1cblxuICByZXR1cm4gV2FsbGV0U2VsZWN0O1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL3ZpZXdzL1dhbGxldENoZWNrLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjI0LjAgKi9cblxuXG5mdW5jdGlvbiBhZGRfY3NzJGEoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS16cnZzY3ctc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcInAuc3ZlbHRlLXpydnNjd3tmb250LXNpemU6MC44ODllbTtmb250LWZhbWlseTppbmhlcml0O21hcmdpbjoxZW0gMH1zcGFuLnN2ZWx0ZS16cnZzY3d7Y29sb3I6I2UyNTA0YTtmb250LXNpemU6MC44ODllbTtmb250LWZhbWlseTppbmhlcml0O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWJvdHRvbTowLjc1ZW07cGFkZGluZzowLjVlbTtib3JkZXI6MXB4IHNvbGlkICNlMjUwNGE7Ym9yZGVyLXJhZGl1czo1cHh9ZGl2LnN2ZWx0ZS16cnZzY3d7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO21pbi1oZWlnaHQ6Mi41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfXNlY3Rpb24uc3ZlbHRlLXpydnNjd3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO21hcmdpbi1ib3R0b206MXJlbX1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDIzOTowKSB7I2lmIGxvYWRpbmdNb2RhbH1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfNihjdHgpIHtcbiAgdmFyIG1vZGFsO1xuICB2YXIgY3VycmVudDtcbiAgbW9kYWwgPSBuZXcgTW9kYWwoe1xuICAgIHByb3BzOiB7XG4gICAgICBjbG9zZWFibGU6IGZhbHNlLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3RfNF1cbiAgICAgIH0sXG4gICAgICAkJHNjb3BlOiB7XG4gICAgICAgIGN0eDogY3R4XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChtb2RhbC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQobW9kYWwsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4obW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQobW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbCwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgyNDA6MikgPE1vZGFsIGNsb3NlYWJsZT17ZmFsc2V9PlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X3Nsb3RfNChjdHgpIHtcbiAgdmFyIHNwaW5uZXI7XG4gIHZhciBjdXJyZW50O1xuICBzcGlubmVyID0gbmV3IFNwaW5uZXIoe1xuICAgIHByb3BzOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJDaGVja2luZyB3YWxsZXRcIlxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoc3Bpbm5lci4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQoc3Bpbm5lciwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBub29wLFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHNwaW5uZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoc3Bpbm5lci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHNwaW5uZXIsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjQ1OjApIHsjaWYgYWN0aXZlTW9kYWx9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrJDgoY3R4KSB7XG4gIHZhciBtb2RhbDtcbiAgdmFyIGN1cnJlbnQ7XG4gIG1vZGFsID0gbmV3IE1vZGFsKHtcbiAgICBwcm9wczoge1xuICAgICAgY2xvc2VNb2RhbDpcbiAgICAgIC8qZnVuY18xKi9cbiAgICAgIGN0eFsxMF0sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdCQzXVxuICAgICAgfSxcbiAgICAgICQkc2NvcGU6IHtcbiAgICAgICAgY3R4OiBjdHhcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KG1vZGFsLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChtb2RhbCwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBtb2RhbF9jaGFuZ2VzID0ge307XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiQkc2NvcGUsIGxvYWRpbmcsIGFjdGl2ZU1vZGFsLCBlcnJvck1zZywgJGFwcCovXG4gICAgICAxNjc3NzIzOSkge1xuICAgICAgICBtb2RhbF9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1vZGFsLiRzZXQobW9kYWxfY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihtb2RhbC4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChtb2RhbC4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KG1vZGFsLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI1MTo0KSB7I2lmIGVycm9yTXNnfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja181KGN0eCkge1xuICB2YXIgc3BhbjtcbiAgdmFyIHQ7XG4gIHZhciBzcGFuX2ludHJvO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBzcGFuID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICB0ID0gdGV4dChcbiAgICAgIC8qZXJyb3JNc2cqL1xuICAgICAgY3R4WzFdKTtcbiAgICAgIGF0dHIoc3BhbiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtcHJlcGFyZS1lcnJvciBzdmVsdGUtenJ2c2N3XCIpO1xuICAgICAgdG9nZ2xlX2NsYXNzKHNwYW4sIFwiYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZFwiLFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFs0XS5kYXJrTW9kZSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzcGFuLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKHNwYW4sIHQpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyplcnJvck1zZyovXG4gICAgICAyKSBzZXRfZGF0YSh0LFxuICAgICAgLyplcnJvck1zZyovXG4gICAgICBjdHhbMV0pO1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDE2KSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhzcGFuLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzRdLmRhcmtNb2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmICghc3Bhbl9pbnRybykge1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzcGFuX2ludHJvID0gY3JlYXRlX2luX3RyYW5zaXRpb24oc3BhbiwgZmFkZSwge30pO1xuICAgICAgICAgIHNwYW5faW50cm8uc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goc3Bhbik7XG4gICAgfVxuICB9O1xufSAvLyAoMjYwOjQpIHsjaWYgYWN0aXZlTW9kYWwuaHRtbH1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfNChjdHgpIHtcbiAgdmFyIHNlY3Rpb247XG4gIHZhciByYXdfdmFsdWUgPVxuICAvKmFjdGl2ZU1vZGFsKi9cbiAgY3R4WzBdLmh0bWwgKyBcIlwiO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBzZWN0aW9uID0gZWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgICBhdHRyKHNlY3Rpb24sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXdhbGxldC1jaGVjay1zZWN0aW9uIHN2ZWx0ZS16cnZzY3dcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzZWN0aW9uLCBhbmNob3IpO1xuICAgICAgc2VjdGlvbi5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEgJiYgcmF3X3ZhbHVlICE9PSAocmF3X3ZhbHVlID1cbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmh0bWwgKyBcIlwiKSkgc2VjdGlvbi5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHNlY3Rpb24pO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI2Nzo2KSB7I2lmIGFjdGl2ZU1vZGFsLmJ1dHRvbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMyQxKGN0eCkge1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgYnV0dG9uID0gbmV3IEJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgIG9uY2xpY2s6XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5idXR0b24ub25jbGljayxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XzNdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpIGJ1dHRvbl9jaGFuZ2VzLm9uY2xpY2sgPVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uYnV0dG9uLm9uY2xpY2s7XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiQkc2NvcGUsIGFjdGl2ZU1vZGFsKi9cbiAgICAgIDE2Nzc3MjE3KSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24sIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjY4OjgpIDxCdXR0b24gcG9zaXRpb249XCJsZWZ0XCIgb25jbGljaz17YWN0aXZlTW9kYWwuYnV0dG9uLm9uY2xpY2t9PlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X3Nsb3RfMyhjdHgpIHtcbiAgdmFyIHRfdmFsdWUgPVxuICAvKmFjdGl2ZU1vZGFsKi9cbiAgY3R4WzBdLmJ1dHRvbi50ZXh0ICsgXCJcIjtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KHRfdmFsdWUpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdCwgYW5jaG9yKTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgMSAmJiB0X3ZhbHVlICE9PSAodF92YWx1ZSA9XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5idXR0b24udGV4dCArIFwiXCIpKSBzZXRfZGF0YSh0LCB0X3ZhbHVlKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgfVxuICB9O1xufSAvLyAoMjc2OjYpIHs6ZWxzZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWxzZV9ibG9jayQ0KGN0eCkge1xuICB2YXIgZGl2O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYXR0cihkaXYsIFwiY2xhc3NcIiwgXCJzdmVsdGUtenJ2c2N3XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogbm9vcCxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI3Mjo2KSB7I2lmIGVycm9yTXNnfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18yJDIoY3R4KSB7XG4gIHZhciBidXR0b247XG4gIHZhciBjdXJyZW50O1xuICBidXR0b24gPSBuZXcgQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgcG9zaXRpb246ICFcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmJ1dHRvbiAmJiBcImxlZnRcIixcbiAgICAgIG9uY2xpY2s6XG4gICAgICAvKmRvQWN0aW9uKi9cbiAgICAgIGN0eFs1XSxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XzJdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpIGJ1dHRvbl9jaGFuZ2VzLnBvc2l0aW9uID0gIVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uYnV0dG9uICYmIFwibGVmdFwiO1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokJHNjb3BlKi9cbiAgICAgIDE2Nzc3MjE2KSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24sIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjczOjgpIDxCdXR0b24gcG9zaXRpb249eyFhY3RpdmVNb2RhbC5idXR0b24gJiYgJ2xlZnQnfSBvbmNsaWNrPXtkb0FjdGlvbn0+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdF8yKGN0eCkge1xuICB2YXIgdDtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgdCA9IHRleHQoXCJUcnkgQWdhaW5cIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0LCBhbmNob3IpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0KTtcbiAgICB9XG4gIH07XG59IC8vICgyNzk6NikgeyNpZiBsb2FkaW5nfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18xJDQoY3R4KSB7XG4gIHZhciBzcGlubmVyO1xuICB2YXIgY3VycmVudDtcbiAgc3Bpbm5lciA9IG5ldyBTcGlubmVyKHt9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChzcGlubmVyLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChzcGlubmVyLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHNwaW5uZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoc3Bpbm5lci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHNwaW5uZXIsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjgyOjYpIDxCdXR0b24gcG9zaXRpb249XCJyaWdodFwiIG9uY2xpY2s9eygpID0+IGhhbmRsZUV4aXQoZmFsc2UpfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90XzEkMihjdHgpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KFwiRGlzbWlzc1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI0NjoyKSA8TW9kYWwgY2xvc2VNb2RhbD17KCkgPT4gaGFuZGxlRXhpdCgpfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90JDMoY3R4KSB7XG4gIHZhciBtb2RhbGhlYWRlcjtcbiAgdmFyIHQwO1xuXG4gIHZhciBfcDM7XG5cbiAgdmFyIHJhd192YWx1ZSA9XG4gIC8qYWN0aXZlTW9kYWwqL1xuICBjdHhbMF0uZGVzY3JpcHRpb24gKyBcIlwiO1xuICB2YXIgdDE7XG4gIHZhciB0MjtcbiAgdmFyIHQzO1xuICB2YXIgZGl2O1xuICB2YXIgdDQ7XG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gIHZhciBpZl9ibG9jazM7XG4gIHZhciB0NTtcbiAgdmFyIHQ2O1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgbW9kYWxoZWFkZXIgPSBuZXcgTW9kYWxIZWFkZXIoe1xuICAgIHByb3BzOiB7XG4gICAgICBpY29uOlxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uaWNvbixcbiAgICAgIGhlYWRpbmc6XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5oZWFkaW5nXG4gICAgfVxuICB9KTtcbiAgdmFyIGlmX2Jsb2NrMCA9XG4gIC8qZXJyb3JNc2cqL1xuICBjdHhbMV0gJiYgY3JlYXRlX2lmX2Jsb2NrXzUoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrMSA9XG4gIC8qYWN0aXZlTW9kYWwqL1xuICBjdHhbMF0uaHRtbCAmJiBjcmVhdGVfaWZfYmxvY2tfNChjdHgpO1xuICB2YXIgaWZfYmxvY2syID1cbiAgLyphY3RpdmVNb2RhbCovXG4gIGN0eFswXS5idXR0b24gJiYgY3JlYXRlX2lmX2Jsb2NrXzMkMShjdHgpO1xuICB2YXIgaWZfYmxvY2tfY3JlYXRvcnMgPSBbY3JlYXRlX2lmX2Jsb2NrXzIkMiwgY3JlYXRlX2Vsc2VfYmxvY2skNF07XG4gIHZhciBpZl9ibG9ja3MgPSBbXTtcblxuICBmdW5jdGlvbiBzZWxlY3RfYmxvY2tfdHlwZShjdHgsIGRpcnR5KSB7XG4gICAgaWYgKFxuICAgIC8qZXJyb3JNc2cqL1xuICAgIGN0eFsxXSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICBpZl9ibG9jazMgPSBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XSA9IGlmX2Jsb2NrX2NyZWF0b3JzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0oY3R4KTtcbiAgdmFyIGlmX2Jsb2NrNCA9XG4gIC8qbG9hZGluZyovXG4gIGN0eFsyXSAmJiBjcmVhdGVfaWZfYmxvY2tfMSQ0KCk7XG4gIGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgIHByb3BzOiB7XG4gICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgb25jbGljazpcbiAgICAgIC8qZnVuYyovXG4gICAgICBjdHhbOV0sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdF8xJDJdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQobW9kYWxoZWFkZXIuJCQuZnJhZ21lbnQpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgX3AzID0gZWxlbWVudChcInBcIik7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuYygpO1xuICAgICAgdDIgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmMoKTtcbiAgICAgIHQzID0gc3BhY2UoKTtcbiAgICAgIGRpdiA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIuYygpO1xuICAgICAgdDQgPSBzcGFjZSgpO1xuICAgICAgaWZfYmxvY2szLmMoKTtcbiAgICAgIHQ1ID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazQpIGlmX2Jsb2NrNC5jKCk7XG4gICAgICB0NiA9IHNwYWNlKCk7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGJ1dHRvbi4kJC5mcmFnbWVudCk7XG4gICAgICBhdHRyKF9wMywgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtcHJlcGFyZS1kZXNjcmlwdGlvbiBzdmVsdGUtenJ2c2N3XCIpO1xuICAgICAgYXR0cihkaXYsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXByZXBhcmUtYnV0dG9uLWNvbnRhaW5lciBzdmVsdGUtenJ2c2N3XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KG1vZGFsaGVhZGVyLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIF9wMywgYW5jaG9yKTtcbiAgICAgIF9wMy5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MSwgYW5jaG9yKTtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQyLCBhbmNob3IpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDMsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBkaXYsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIubShkaXYsIG51bGwpO1xuICAgICAgYXBwZW5kKGRpdiwgdDQpO1xuICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0ubShkaXYsIG51bGwpO1xuICAgICAgYXBwZW5kKGRpdiwgdDUpO1xuICAgICAgaWYgKGlmX2Jsb2NrNCkgaWZfYmxvY2s0Lm0oZGl2LCBudWxsKTtcbiAgICAgIGFwcGVuZChkaXYsIHQ2KTtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIGRpdiwgbnVsbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgdmFyIG1vZGFsaGVhZGVyX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpIG1vZGFsaGVhZGVyX2NoYW5nZXMuaWNvbiA9XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5pY29uO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgMSkgbW9kYWxoZWFkZXJfY2hhbmdlcy5oZWFkaW5nID1cbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmhlYWRpbmc7XG4gICAgICBtb2RhbGhlYWRlci4kc2V0KG1vZGFsaGVhZGVyX2NoYW5nZXMpO1xuICAgICAgaWYgKCghY3VycmVudCB8fCBkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpICYmIHJhd192YWx1ZSAhPT0gKHJhd192YWx1ZSA9XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5kZXNjcmlwdGlvbiArIFwiXCIpKSBfcDMuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuXG4gICAgICBpZiAoXG4gICAgICAvKmVycm9yTXNnKi9cbiAgICAgIGN0eFsxXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgICAgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qZXJyb3JNc2cqL1xuICAgICAgICAgIDIpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gY3JlYXRlX2lmX2Jsb2NrXzUoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazAubSh0Mi5wYXJlbnROb2RlLCB0Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgIGlmX2Jsb2NrMC5kKDEpO1xuICAgICAgICBpZl9ibG9jazAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5odG1sKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgICBpZl9ibG9jazEucChjdHgsIGRpcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazEgPSBjcmVhdGVfaWZfYmxvY2tfNChjdHgpO1xuICAgICAgICAgIGlmX2Jsb2NrMS5jKCk7XG4gICAgICAgICAgaWZfYmxvY2sxLm0odDMucGFyZW50Tm9kZSwgdDMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBpZl9ibG9jazEuZCgxKTtcbiAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uYnV0dG9uKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazIpIHtcbiAgICAgICAgICBpZl9ibG9jazIucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICAgICAgMSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazIsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazIgPSBjcmVhdGVfaWZfYmxvY2tfMyQxKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2syLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMiwgMSk7XG4gICAgICAgICAgaWZfYmxvY2syLm0oZGl2LCB0NCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2syKSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazIsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2aW91c19ibG9ja19pbmRleCA9IGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleDtcbiAgICAgIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPT09IHByZXZpb3VzX2Jsb2NrX2luZGV4KSB7XG4gICAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLnAoY3R4LCBkaXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2tzW3ByZXZpb3VzX2Jsb2NrX2luZGV4XSwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2Nrc1twcmV2aW91c19ibG9ja19pbmRleF0gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgIGlmX2Jsb2NrMyA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdO1xuXG4gICAgICAgIGlmICghaWZfYmxvY2szKSB7XG4gICAgICAgICAgaWZfYmxvY2szID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0gPSBpZl9ibG9ja19jcmVhdG9yc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2szLmMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2szLCAxKTtcbiAgICAgICAgaWZfYmxvY2szLm0oZGl2LCB0NSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qbG9hZGluZyovXG4gICAgICBjdHhbMl0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrNCkge1xuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLypsb2FkaW5nKi9cbiAgICAgICAgICA0KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrNCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrNCA9IGNyZWF0ZV9pZl9ibG9ja18xJDQoKTtcbiAgICAgICAgICBpZl9ibG9jazQuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2s0LCAxKTtcbiAgICAgICAgICBpZl9ibG9jazQubShkaXYsIHQ2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazQpIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrNCwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2NrNCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbl9jaGFuZ2VzID0ge307XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiQkc2NvcGUqL1xuICAgICAgMTY3NzcyMTYpIHtcbiAgICAgICAgYnV0dG9uX2NoYW5nZXMuJCRzY29wZSA9IHtcbiAgICAgICAgICBkaXJ0eTogZGlydHksXG4gICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYnV0dG9uLiRzZXQoYnV0dG9uX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4obW9kYWxoZWFkZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2syKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2szKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2s0KTtcbiAgICAgIHRyYW5zaXRpb25faW4oYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazIpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2szKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrNCk7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbGhlYWRlciwgZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MCk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goX3AzKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MSk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQyKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDMpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGRpdik7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIuZCgpO1xuICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0uZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrNCkgaWZfYmxvY2s0LmQoKTtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGJ1dHRvbik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnQkYShjdHgpIHtcbiAgdmFyIHQ7XG4gIHZhciBpZl9ibG9jazFfYW5jaG9yO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIGlmX2Jsb2NrMCA9XG4gIC8qbG9hZGluZ01vZGFsKi9cbiAgY3R4WzNdICYmIGNyZWF0ZV9pZl9ibG9ja182KGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKmFjdGl2ZU1vZGFsKi9cbiAgY3R4WzBdICYmIGNyZWF0ZV9pZl9ibG9jayQ4KGN0eCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0ID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBpZl9ibG9jazFfYW5jaG9yID0gZW1wdHkoKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpZl9ibG9jazFfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjMwKSB7XG4gICAgICB2YXIgX3JlZjMxID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMwLCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYzMVswXTtcblxuICAgICAgaWYgKFxuICAgICAgLypsb2FkaW5nTW9kYWwqL1xuICAgICAgY3R4WzNdKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qbG9hZGluZ01vZGFsKi9cbiAgICAgICAgICA4KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IGNyZWF0ZV9pZl9ibG9ja182KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgaWZfYmxvY2swLm0odC5wYXJlbnROb2RlLCB0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMS5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5ICZcbiAgICAgICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgICAgICAxKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9jayQ4KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgaWZfYmxvY2sxLm0oaWZfYmxvY2sxX2FuY2hvci5wYXJlbnROb2RlLCBpZl9ibG9jazFfYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMSwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazEpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGlmX2Jsb2NrMV9hbmNob3IpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9ja1Njcm9sbCQxKCkge1xuICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2tNb2RhbCh2YWwpIHtcbiAgcmV0dXJuIHZhbC5oZWFkaW5nICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJGEoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSg0LCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgd2FsbGV0U2VsZWN0ID0gJCRwcm9wcy53YWxsZXRTZWxlY3Q7XG4gIHZhciBtb2R1bGVzID0gJCRwcm9wcy5tb2R1bGVzO1xuICB2YXIgYmxvY2tuYXRpdmUgPSBnZXRCbG9ja25hdGl2ZSgpO1xuICB2YXIgY3VycmVudFN0YXRlO1xuICB2YXIgYWN0aXZlTW9kYWwgPSB1bmRlZmluZWQ7XG4gIHZhciBjdXJyZW50TW9kdWxlID0gdW5kZWZpbmVkO1xuICB2YXIgZXJyb3JNc2c7XG4gIHZhciBwb2xsaW5nSW50ZXJ2YWw7XG4gIHZhciBjaGVja2luZ01vZHVsZSA9IGZhbHNlO1xuICB2YXIgYWN0aW9uUmVzb2x2ZWQgPSB1bmRlZmluZWQ7XG4gIHZhciBsb2FkaW5nID0gZmFsc2U7XG4gIHZhciBsb2FkaW5nTW9kYWwgPSBmYWxzZTtcbiAgdmFyIHVuc3Vic2NyaWJlID0gd2FsbGV0SW50ZXJmYWNlLnN1YnNjcmliZShmdW5jdGlvbiAoY3VycmVudEludGVyZmFjZSkge1xuICAgIGlmIChjdXJyZW50SW50ZXJmYWNlID09PSBudWxsKSB7XG4gICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBvcmlnaW5hbE92ZXJmbG93VmFsdWU7XG4gIHZhciB1bnN1YnNjcmliZUN1cnJlbnRTdGF0ZSA9IHN0YXRlLnN1YnNjcmliZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlID0gc3RvcmU7XG4gIH0pO1xuICBvbk1vdW50KGZ1bmN0aW9uICgpIHtcbiAgICBvcmlnaW5hbE92ZXJmbG93VmFsdWUgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbG9ja1Njcm9sbCQxKTtcbiAgfSk7XG4gIG9uRGVzdHJveShmdW5jdGlvbiAoKSB7XG4gICAgdW5zdWJzY3JpYmVDdXJyZW50U3RhdGUoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsb2NrU2Nyb2xsJDEpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3JpZ2luYWxPdmVyZmxvd1ZhbHVlO1xuICB9KTtcblxuICBmdW5jdGlvbiByZW5kZXJNb2R1bGUoKSB7XG4gICAgcmV0dXJuIF9yZW5kZXJNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW5kZXJNb2R1bGUoKSB7XG4gICAgX3JlbmRlck1vZHVsZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgICB2YXIgY2hlY2tNb2R1bGVzLCBjdXJyZW50V2FsbGV0O1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgJCRpbnZhbGlkYXRlKDE0LCBjaGVja2luZ01vZHVsZSA9IHRydWUpO1xuICAgICAgICAgICAgICBjaGVja01vZHVsZXMgPSBtb2R1bGVzIHx8IGdldF9zdG9yZV92YWx1ZShhcHApLmNoZWNrTW9kdWxlcztcblxuICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZShjaGVja01vZHVsZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gY2hlY2tNb2R1bGVzO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNoZWNrTW9kdWxlcyA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgICBjaGVja01vZHVsZXMuZm9yRWFjaCh2YWxpZGF0ZVdhbGxldENoZWNrTW9kdWxlKTtcbiAgICAgICAgICAgICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBjaGVja01vZHVsZXM6IGNoZWNrTW9kdWxlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjdXJyZW50V2FsbGV0ID0gZ2V0X3N0b3JlX3ZhbHVlKHdhbGxldCkubmFtZTsgLy8gbG9vcCB0aHJvdWdoIGFuZCBydW4gZWFjaCBtb2R1bGUgdG8gY2hlY2sgaWYgYSBtb2RhbCBuZWVkcyB0byBiZSBzaG93blxuXG4gICAgICAgICAgICAgIHJ1bk1vZHVsZXMoY2hlY2tNb2R1bGVzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBubyByZXN1bHQgdGhlbiB1c2VyIGhhcyBwYXNzZWQgYWxsIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5tb2RhbCkge1xuICAgICAgICAgICAgICAgICAgYmxvY2tuYXRpdmUgJiYgYmxvY2tuYXRpdmUuZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeUNvZGU6IFwib25ib2FyZFwiLFxuICAgICAgICAgICAgICAgICAgICBldmVudENvZGU6IFwib25ib2FyZGluZ0NvbXBsZXRlZFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZUV4aXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSAvLyBzZXQgdGhhdCBVSSBoYXMgYmVlbiBkaXNwbGF5ZWQsIHNvIHRoYXQgdGltZW91dHMgY2FuIGJlIGFkZGVkIGZvciBVSSB0cmFuc2l0aW9uc1xuXG5cbiAgICAgICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDaGVja0Rpc3BsYXllZFVJOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMCwgYWN0aXZlTW9kYWwgPSByZXN1bHQubW9kYWwpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNb2R1bGUgPSByZXN1bHQubW9kdWxlOyAvLyBsb2cgdGhlIGV2ZW50IGNvZGUgZm9yIHRoaXMgbW9kdWxlXG5cbiAgICAgICAgICAgICAgICBibG9ja25hdGl2ZSAmJiBibG9ja25hdGl2ZS5ldmVudCh7XG4gICAgICAgICAgICAgICAgICBldmVudENvZGU6IGFjdGl2ZU1vZGFsLmV2ZW50Q29kZSxcbiAgICAgICAgICAgICAgICAgIGNhdGVnb3J5Q29kZTogXCJvbmJvYXJkXCJcbiAgICAgICAgICAgICAgICB9KTsgLy8gcnVuIGFueSBhY3Rpb25zIHRoYXQgbW9kdWxlIHJlcXVpcmUgYXMgcGFydCBvZiB0aGlzIHN0ZXBcblxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVNb2RhbC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIGRvQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSAvLyBwb2xsIHRvIGF1dG9tYXRpY2FsbHkgdG8gY2hlY2sgaWYgY29uZGl0aW9uIGhhcyBiZWVuIG1ldFxuXG5cbiAgICAgICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCggLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZFN0YXRlKGN1cnJlbnRNb2R1bGUsIGdldF9zdG9yZV92YWx1ZShzdGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSBfY29udGV4dDYuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9yZXN1bHQgJiYgYWN0aW9uUmVzb2x2ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTdGF0ZSgpOyAvLyBkZWxheWVkIGZvciBhbmltYXRpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgxNCwgY2hlY2tpbmdNb2R1bGUgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMCwgYWN0aXZlTW9kYWwgPSBfcmVzdWx0ICYmIF9yZXN1bHQubW9kYWwgPyBfcmVzdWx0Lm1vZGFsIDogYWN0aXZlTW9kYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNik7XG4gICAgICAgICAgICAgICAgfSkpLCAxMDApO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNyk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfcmVuZGVyTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBkb0FjdGlvbigpIHtcbiAgICBhY3Rpb25SZXNvbHZlZCA9IGZhbHNlO1xuICAgICQkaW52YWxpZGF0ZSgyLCBsb2FkaW5nID0gdHJ1ZSk7XG4gICAgYWN0aXZlTW9kYWwgJiYgYWN0aXZlTW9kYWwuYWN0aW9uICYmIGFjdGl2ZU1vZGFsLmFjdGlvbigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aW9uUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgJCRpbnZhbGlkYXRlKDIsIGxvYWRpbmcgPSBmYWxzZSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAkJGludmFsaWRhdGUoMSwgZXJyb3JNc2cgPSBlcnIubWVzc2FnZSk7XG4gICAgICAkJGludmFsaWRhdGUoMiwgbG9hZGluZyA9IGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUV4aXQoY29tcGxldGVkKSB7XG4gICAgcmVzZXRTdGF0ZSgpO1xuICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgIHdhbGxldENoZWNrSW5Qcm9ncmVzczogZmFsc2UsXG4gICAgICAgIHdhbGxldENoZWNrQ29tcGxldGVkOiBjb21wbGV0ZWQgPyBjb21wbGV0ZWQgOiBmYWxzZSxcbiAgICAgICAgYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3M6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwpO1xuICAgICQkaW52YWxpZGF0ZSgxLCBlcnJvck1zZyA9IFwiXCIpO1xuICAgIGFjdGlvblJlc29sdmVkID0gdW5kZWZpbmVkO1xuICAgICQkaW52YWxpZGF0ZSgwLCBhY3RpdmVNb2RhbCA9IHVuZGVmaW5lZCk7XG4gICAgY3VycmVudE1vZHVsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bk1vZHVsZXMobW9kdWxlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMzIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHJlc29sdmUpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciwgX3N0ZXAsIG1vZHVsZSwgcmVzdWx0O1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRTdGF0ZShtb2R1bGUsIGN1cnJlbnRTdGF0ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKHJlc3VsdCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxNztcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmZpbmlzaCgxNyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBtb2R1bGU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgbnVsbCwgW1sxLCAxNCwgMTcsIDIwXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKF94Nikge1xuICAgICAgICByZXR1cm4gX3JlZjMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkU3RhdGUoX3g3LCBfeDgpIHtcbiAgICByZXR1cm4gX2ludmFsaWRTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2ludmFsaWRTdGF0ZSgpIHtcbiAgICBfaW52YWxpZFN0YXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOChtb2R1bGUsIHN0YXRlKSB7XG4gICAgICB2YXIgcmVzdWx0LCBtb2RhbDtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG1vZHVsZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgICAgICAgICBCaWdOdW1iZXI6IEJpZ051bWJlcixcbiAgICAgICAgICAgICAgICB3YWxsZXRTZWxlY3Q6IHdhbGxldFNlbGVjdCxcbiAgICAgICAgICAgICAgICBleGl0OiBoYW5kbGVFeGl0LFxuICAgICAgICAgICAgICAgIHdhbGxldDogZ2V0X3N0b3JlX3ZhbHVlKHdhbGxldCksXG4gICAgICAgICAgICAgICAgc3RhdGVTeW5jU3RhdHVzOiBzdGF0ZVN5bmNTdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdGVTdG9yZToge1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0NoZWNrTW9kYWwocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhbGlkYXRlTW9kYWwocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG1vZGFsOiByZXN1bHRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA5O1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgJCRpbnZhbGlkYXRlKDMsIGxvYWRpbmdNb2RhbCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBtb2RhbCA9IHJlcztcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgzLCBsb2FkaW5nTW9kYWwgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA2NTApO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhbGlkYXRlTW9kYWwobW9kYWwpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgbW9kYWw6IG1vZGFsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU4KTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9pbnZhbGlkU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICByZXR1cm4gaGFuZGxlRXhpdChmYWxzZSk7XG4gIH07XG5cbiAgdmFyIGZ1bmNfMSA9IGZ1bmN0aW9uIGZ1bmNfMSgpIHtcbiAgICByZXR1cm4gaGFuZGxlRXhpdCgpO1xuICB9O1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJ3YWxsZXRTZWxlY3RcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoNywgd2FsbGV0U2VsZWN0ID0gJCRwcm9wcy53YWxsZXRTZWxlY3QpO1xuICAgIGlmIChcIm1vZHVsZXNcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoOCwgbW9kdWxlcyA9ICQkcHJvcHMubW9kdWxlcyk7XG4gIH07XG5cbiAgJCRzZWxmLiQkLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJCRzZWxmLiQkLmRpcnR5ICZcbiAgICAvKmFjdGl2ZU1vZGFsLCBjaGVja2luZ01vZHVsZSovXG4gICAgMTYzODUpIHtcbiAgICAgIC8vIHJlY2hlY2sgbW9kdWxlcyBpZiBiZWxvdyBjb25kaXRpb25zXG4gICAgICBpZiAoIWFjdGl2ZU1vZGFsICYmICFjaGVja2luZ01vZHVsZSkge1xuICAgICAgICByZW5kZXJNb2R1bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFthY3RpdmVNb2RhbCwgZXJyb3JNc2csIGxvYWRpbmcsIGxvYWRpbmdNb2RhbCwgJGFwcCwgZG9BY3Rpb24sIGhhbmRsZUV4aXQsIHdhbGxldFNlbGVjdCwgbW9kdWxlcywgZnVuYywgZnVuY18xXTtcbn1cblxudmFyIFdhbGxldENoZWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50MTEpIHtcbiAgX2luaGVyaXRzKFdhbGxldENoZWNrLCBfU3ZlbHRlQ29tcG9uZW50MTEpO1xuXG4gIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihXYWxsZXRDaGVjayk7XG5cbiAgZnVuY3Rpb24gV2FsbGV0Q2hlY2sob3B0aW9ucykge1xuICAgIHZhciBfdGhpczExO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdhbGxldENoZWNrKTtcblxuICAgIF90aGlzMTEgPSBfc3VwZXIxMS5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtenJ2c2N3LXN0eWxlXCIpKSBhZGRfY3NzJGEoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSksIG9wdGlvbnMsIGluc3RhbmNlJGEsIGNyZWF0ZV9mcmFnbWVudCRhLCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgd2FsbGV0U2VsZWN0OiA3LFxuICAgICAgbW9kdWxlczogOFxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczExO1xuICB9XG5cbiAgcmV0dXJuIFdhbGxldENoZWNrO1xufShTdmVsdGVDb21wb25lbnQpO1xuXG52YXIgdXNiSWNvbiA9IFwiXFxuXFx0PHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDUxMiA1MTJcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIiB3aWR0aD1cXFwiMThweFxcXCIgaGVpZ2h0PVxcXCIxOHB4XFxcIj5cXG5cXHQ8Zz5cXG5cXHQ8Zz5cXG5cXHQ8cGF0aCBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGQ9XFxcIk0zMTQuNDY4LDE1Ny4xOTd2MTAzLjk0MmgzMS41NTN2Mi4zMTJjMCw5Ljg4OC00LjgxNSwxOS4yMDUtMTIuODgxLDI0LjkyNGwtNTYuNjUyLDQwLjE3MVYxMDkuOTM5aDQ0LjU0NkwyNTcuNjM0LDBcXG5cXHRcXHRsLTY2LjUyNywxMDkuOTM5aDQ1LjQwNFYzNTguMjVsLTU2LjY1Mi00MC4xNzFjLTguMDY2LTUuNzE5LTEyLjg4MS0xNS4wMzctMTIuODgxLTI0LjkyNHYtOC40ODlcXG5cXHRcXHRjMjAuMTktNy44MTUsMzQuNTUyLTI3LjQyNywzNC41NTItNTAuMzQyYzAtMjkuNzU5LTI0LjIxMS01My45Ny01My45Ny01My45N2MtMjkuNzYsMC01My45NywyNC4yMTEtNTMuOTcsNTMuOTdcXG5cXHRcXHRjMCwyMi40ODIsMTMuODIxLDQxLjc4OSwzMy40MSw0OS44OTF2OC45NGMwLDIyLjgyNCwxMS4xMTYsNDQuMzMzLDI5LjczNSw1Ny41MzZsNjYuODk1LDQ3LjQzNFxcblxcdFxcdGM0LjI1NSwzLjAxNiw3LjU5Myw3LjA0LDkuODA5LDExLjYxNWMtMTcuNzEzLDguODYyLTI5LjkwOSwyNy4xNzMtMjkuOTA5LDQ4LjI5YzAsMjkuNzYsMjQuMjExLDUzLjk3LDUzLjk3LDUzLjk3XFxuXFx0XFx0YzI5Ljc1OSwwLDUzLjk3LTI0LjIxMSw1My45Ny01My45N2MwLTIzLjA3OC0xNC41NjQtNDIuODEtMzQuOTgxLTUwLjUxMXYtMTQuMTc0YzAtOS44ODgsNC44MTUtMTkuMjA1LDEyLjg4MS0yNC45MjRcXG5cXHRcXHRsNjYuODk1LTQ3LjQzNGMxOC42MTktMTMuMjAyLDI5LjczNS0zNC43MTEsMjkuNzM1LTU3LjUzNnYtMi4zMTJoMzIuNDExVjE1Ny4xOTdIMzE0LjQ2OHogTTE0Ny41NiwyNDguMzE2XFxuXFx0XFx0Yy03LjcxNiwwLTEzLjk5Mi02LjI3Ny0xMy45OTItMTMuOTkyYzAtNy43MTYsNi4yNzYtMTMuOTkyLDEzLjk5Mi0xMy45OTJjNy43MTYsMCwxMy45OTIsNi4yNzYsMTMuOTkyLDEzLjk5MlxcblxcdFxcdEMxNjEuNTUyLDI0Mi4wNCwxNTUuMjc2LDI0OC4zMTYsMTQ3LjU2LDI0OC4zMTZ6IE0yNTcuNDk5LDQ3Mi4wMjJjLTcuNzE2LDAtMTMuOTkyLTYuMjc2LTEzLjk5Mi0xMy45OTJcXG5cXHRcXHRjMC03LjcxNiw2LjI3Ny0xMy45OTIsMTMuOTkyLTEzLjk5MmM3LjcxNiwwLDEzLjk5Miw2LjI3NiwxMy45OTIsMTMuOTkyQzI3MS40OTEsNDY1Ljc0NiwyNjUuMjE1LDQ3Mi4wMjIsMjU3LjQ5OSw0NzIuMDIyelxcblxcdFxcdE0zNzguNDMyLDIyMS4xNjFoLTIzLjk4N3YtMjMuOTg3aDIzLjk4N1YyMjEuMTYxelxcXCIvPlxcblxcdDwvZz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PC9zdmc+XFx0ICBcXG5cIjtcbnZhciBjb25uZWN0SWNvbiA9IFwiXFxuXFx0PHN2ZyBoZWlnaHQ9XFxcIjE0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTggMTRcXFwiIHdpZHRoPVxcXCIxOFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG5cXHRcXHQ8ZyBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiPlxcblxcdFxcdFxcdDxwYXRoIGQ9XFxcIm0xMC4yOTM3NSA0LjA1MzUxNTYzYzAtLjA0OTIxODc1IDAtLjA5MTQwNjI1IDAtLjEzMDA3ODEzIDAtMS4wNTQ2ODc1IDAtMi4xMDkzNzUgMC0zLjE2NDA2MjUgMC0uNDM5NDUzMTIuMzQ4MDQ2OS0uNzY5OTIxODguNzgwNDY4OC0uNzQ1MzEyNS4yMDAzOTA2LjAxMDU0Njg4LjM1ODU5MzcuMTA1NDY4NzUuNDk5MjE4Ny4yNDYwOTM3NS41ODAwNzgxLjU4MzU5Mzc1IDEuMTU2NjQwNiAxLjE2MzY3MTg4IDEuNzM2NzE4NyAxLjc0MDIzNDM4IDEuNDY5NTMxMyAxLjQ2OTUzMTI1IDIuOTM5MDYyNSAyLjkzOTA2MjQ5IDQuNDA1MDc4MiA0LjQwODU5Mzc1LjEzMzU5MzcuMTMzNTkzNzUuMjQyNTc4MS4yNzQyMTg3NS4yNzA3MDMxLjQ2NzU3ODEyLjAzNTE1NjIuMjA3NDIxODgtLjAyNDYwOTQuNDIxODc1LS4xNjUyMzQ0LjU4MDA3ODEzLS4wMjQ2MDk0LjAyODEyNS0uMDQ5MjE4Ny4wNTI3MzQzNy0uMDczODI4MS4wODA4NTkzNy0yLjA2MDE1NjMgMi4wNjM2NzE4OC00LjEyMDMxMjUgNC4xMjM4MjgxLTYuMTgwNDY4OCA2LjE4NzUtLjIxMDkzNzUuMjEwOTM3NS0uNDU3MDMxMi4zMDIzNDM4LS43NDUzMTI1LjIxNzk2ODgtLjI3MDcwMzEtLjA4MDg1OTQtLjQ0NjQ4NDMtLjI3MDcwMzItLjUxMzI4MTItLjU0ODQzNzUtLjAxNDA2MjUtLjA3MzgyODItLjAxNzU3ODEtLjE0NDE0MDctLjAxNDA2MjUtLjIxNzk2ODggMC0xLjAzMzU5MzcgMC0yLjA3MDcwMzEgMC0zLjEwNDI5NjkgMC0uMDM4NjcxOSAwLS4wODA4NTkzNSAwLS4xMzM1OTM3MmgtNS4wNjk1MzEyNWMtLjQ5NTcwMzEzIDAtLjgwNTA3ODEzLS4zMDkzNzUtLjgwNTA3ODEzLS44MDg1OTM3NSAwLTEuNDIzODI4MTMgMC0yLjg0NDE0MDYzIDAtNC4yNjc5Njg3NSAwLS40OTU3MDMxMy4zMDU4NTkzOC0uODAxNTYyNS44MDE1NjI1LS44MDE1NjI1aDQuOTM1OTM3NDh6XFxcIi8+XFxuXFx0XFx0XFx0PHBhdGggZD1cXFwibTUuNjk4ODI4MTIgMTMuOTc4MTI1aC00LjAxMTMyODEyYy0uOTI4MTI1IDAtMS42ODc1LS44NzUzOTA2LTEuNjg3NS0xLjk1MTE3MTl2LTEwLjA2MTcxODcyYzAtMS4wNzU3ODEyNS43NTU4NTkzOC0xLjk1MTE3MTg4IDEuNjg3NS0xLjk1MTE3MTg4aDQuMDExMzI4MTJjLjM0MTAxNTYzIDAgLjYxNTIzNDM4LjMxOTkyMTg4LjYxNTIzNDM4LjcxMDE1NjI1IDAgLjM5MDIzNDM4LS4yNzQyMTg3NS43MTAxNTYyNS0uNjE1MjM0MzguNzEwMTU2MjVoLTQuMDExMzI4MTJjLS4yNTMxMjUgMC0uNDU3MDMxMjUuMjM1NTQ2ODgtLjQ1NzAzMTI1LjUyNzM0Mzc1djEwLjA2MTcxODc1YzAgLjI5MTc5NjkuMjAzOTA2MjUuNTI3MzQzNy40NTcwMzEyNS41MjczNDM3aDQuMDExMzI4MTJjLjM0MTAxNTYzIDAgLjYxNTIzNDM4LjMxOTkyMTkuNjE1MjM0MzguNzEwMTU2M3MtLjI3NzczNDM4LjcxNzE4NzUtLjYxNTIzNDM4LjcxNzE4NzV6XFxcIi8+XFxuXFx0XFx0PC9nPlxcblxcdDwvc3ZnPlxcblwiO1xudmFyIGJhbGFuY2VJY29uID0gXCJcXG5cXHQ8c3ZnIGhlaWdodD1cXFwiMThcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MjkgNjk1XFxcIiB3aWR0aD1cXFwiMThcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuXFx0XFx0PGcgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiPlxcblxcdFxcdFxcdDxwYXRoIGQ9XFxcIm0wIDM5NCAyMTMgMTI2LjIyODUxNiAyMTQtMTI2LjIyODUxNi0yMTQgMzAxelxcXCIvPlxcblxcdFxcdFxcdDxwYXRoIGQ9XFxcIm0wIDM1My45NjIyNjQgMjEzLjUtMzUzLjk2MjI2NCAyMTMuNSAzNTMuOTYyMjY0LTIxMy41IDEyNi4wMzc3MzZ6XFxcIi8+XFxuXFx0XFx0PC9nPlxcblxcdDwvc3ZnPlxcblwiO1xudmFyIG1zZ1N0eWxlcyA9IFwiXFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc2l6ZTogMC44ODllbTtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuXCI7XG5cbmZ1bmN0aW9uIGFjY291bnRTZWxlY3QoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGhlYWRpbmcgPSBvcHRpb25zLmhlYWRpbmcsXG4gICAgICBkZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICBpY29uID0gb3B0aW9ucy5pY29uO1xuICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG4gIHZhciBsb2FkaW5nQWNjb3VudHMgPSBmYWxzZTtcbiAgdmFyIGFjY291bnRzQW5kQmFsYW5jZXMgPSBbXTtcblxuICBmdW5jdGlvbiBjaGVja01vZHVsZShfeDkpIHtcbiAgICByZXR1cm4gX2NoZWNrTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2hlY2tNb2R1bGUoKSB7XG4gICAgX2NoZWNrTW9kdWxlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoc3RhdGVBbmRIZWxwZXJzKSB7XG4gICAgICB2YXIgd2FsbGV0LCBCaWdOdW1iZXIsIHByb3ZpZGVyLCB0eXBlLCBfYWNjb3VudHMsIGRlbGV0ZVdpbmRvd1Byb3BlcnRpZXMsIGxvYWRNb3JlQWNjb3VudHMsIF9hY2NvdW50U2VsZWN0O1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgd2FsbGV0ID0gc3RhdGVBbmRIZWxwZXJzLndhbGxldCwgQmlnTnVtYmVyID0gc3RhdGVBbmRIZWxwZXJzLkJpZ051bWJlcjtcbiAgICAgICAgICAgICAgcHJvdmlkZXIgPSB3YWxsZXQucHJvdmlkZXIsIHR5cGUgPSB3YWxsZXQudHlwZTtcblxuICAgICAgICAgICAgICBpZiAoISh0eXBlID09PSAnaGFyZHdhcmUnICYmICFjb21wbGV0ZWQgJiYgIXByb3ZpZGVyLmlzQ3VzdG9tUGF0aCgpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCEoYWNjb3VudHNBbmRCYWxhbmNlcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2FkaW5nQWNjb3VudHMgPSB0cnVlO1xuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZW5hYmxlKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2FjY291bnRzID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJhbGFuY2VzKF9hY2NvdW50cyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGFjY291bnRzQW5kQmFsYW5jZXMgPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgIGxvYWRpbmdBY2NvdW50cyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVsZXRlV2luZG93UHJvcGVydGllcygpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93LmFjY291bnRTZWxlY3Q7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5sb2FkTW9yZUFjY291bnRzO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGxvYWRNb3JlQWNjb3VudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMzQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ0FjY291bnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0TW9yZUFjY291bnRzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNBbmRCYWxhbmNlcyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nQWNjb3VudHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU5KTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9hZE1vcmVBY2NvdW50cygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMzQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgX2FjY291bnRTZWxlY3QgPSBmdW5jdGlvbiBfYWNjb3VudFNlbGVjdCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjb3VudEluZGV4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY291bnQtc2VsZWN0Jykuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zZXRQcmltYXJ5QWNjb3VudChhY2NvdW50c0FuZEJhbGFuY2VzW2FjY291bnRJbmRleF0uYWRkcmVzcyk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgd2luZG93LmFjY291bnRTZWxlY3QgPSBfYWNjb3VudFNlbGVjdDtcbiAgICAgICAgICAgICAgd2luZG93LmxvYWRNb3JlQWNjb3VudHMgPSBsb2FkTW9yZUFjY291bnRzO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGhlYWRpbmc6IGhlYWRpbmcgfHwgJ1NlbGVjdCBBY2NvdW50JyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgXCJQbGVhc2Ugc2VsZWN0IHdoaWNoIGFjY291bnQgeW91IHdvdWxkIGxpa2UgdG8gdXNlIHdpdGggdGhpcyBEYXBwOlwiLFxuICAgICAgICAgICAgICAgIGV2ZW50Q29kZTogJ2FjY291bnRTZWxlY3QnLFxuICAgICAgICAgICAgICAgIGh0bWw6IGxvYWRpbmdBY2NvdW50cyA/IFwiPGRpdiBjbGFzcz1cXFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1sb2FkaW5nXFxcIj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1maXJzdFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctc2Vjb25kXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy10aGlyZFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9XFxcIlwiLmNvbmNhdChtc2dTdHlsZXMsIFwiXFxcIj5Mb2FkaW5nIE1vcmUgQWNjb3VudHMuLi48L3NwYW4+XFxuICAgICAgICAgICAgXCIpIDogXCJcXG4gICAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjtcXFwiPlxcbiAgICAgICAgICAgIDxzZWxlY3QgaWQ9XFxcImFjY291bnQtc2VsZWN0XFxcIiBvbmNoYW5nZT1cXFwid2luZG93LmFjY291bnRTZWxlY3QoKTtcXFwiIGNsYXNzPVxcXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLWFjY291bnQtc2VsZWN0PlxcbiAgICAgICAgICAgICAgXCIuY29uY2F0KGFjY291bnRzQW5kQmFsYW5jZXMubWFwKGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCI8b3B0aW9uPlwiLmNvbmNhdChhY2NvdW50LmFkZHJlc3MsIFwiIC0tLSBcIikuY29uY2F0KGFjY291bnQuYmFsYW5jZSAhPSBudWxsID8gbmV3IEJpZ051bWJlcihhY2NvdW50LmJhbGFuY2UpLmRpdignMTAwMDAwMDAwMDAwMDAwMDAwMCcpLnRvRml4ZWQoMykgOiAnMCcsIFwiIEVUSDwvb3B0aW9uPlwiKTtcbiAgICAgICAgICAgICAgICB9KSwgXCJcXG4gICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICA8YnV0dG9uIHN0eWxlPVxcXCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGhlaWdodDogMS41cmVtOyBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgbWFyZ2luOiAwIDAuMjVyZW07IHBhZGRpbmc6IDAgMC41cmVtOyBib3JkZXItcmFkaXVzOiA0MHB4OyBjdXJzb3I6IHBvaW50ZXI7IGNvbG9yOiBpbmhlcml0OyBib3JkZXItY29sb3I6IGluaGVyaXQ7IGJvcmRlci13aWR0aDogMXB4OyBib3JkZXItc3R5bGU6IHNvbGlkO1xcXCIgb25jbGljaz1cXFwid2luZG93LmxvYWRNb3JlQWNjb3VudHMoKVxcXCI+TG9hZCBNb3JlPC9idXR0b24+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCIpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gb25jbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlV2luZG93UHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdEb25lJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbiB8fCB1c2JJY29uXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMTApO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX2NoZWNrTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjaGVja01vZHVsZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBhY2NvdW50c0FuZEJhbGFuY2VzID0gW107XG4gICAgbG9hZGluZ0FjY291bnRzID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIGNoZWNrTW9kdWxlO1xufVxuXG52YXIgYWNjb3VudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgJ2RlZmF1bHQnOiBhY2NvdW50U2VsZWN0XG59KTtcbnZhciBkZXJpdmF0aW9uUGF0aHMgPSB7XG4gIExlZGdlcjogW3tcbiAgICBwYXRoOiBcIm0vNDQnLzYwJy8wJ1wiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0nXG4gIH0sIHtcbiAgICBwYXRoOiBcIm0vNDQnLzYwJ1wiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0gTGVkZ2VyIExpdmUnXG4gIH1dLFxuICBUcmV6b3I6IFt7XG4gICAgcGF0aDogXCJtLzQ0Jy82MCcvMCcvMFwiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0nXG4gIH1dLFxuICBMYXR0aWNlOiBbe1xuICAgIHBhdGg6IFwibS80NCcvNjAnLzAnLzBcIixcbiAgICBsYWJlbDogJ0V0aGVyZXVtJ1xuICB9XVxufTtcbnZhciBzdHlsZXMgPSBcIlxcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXCI7XG52YXIgYmFzZVN0eWxlcyA9IFwiXFxuICBiYWNrZ3JvdW5kOiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiAwLjg4OWVtO1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICBib3JkZXItcmFkaXVzOiA0MHB4O1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZzogMC41NWVtIDEuNGVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMTUwbXMgZWFzZS1pbi1vdXQ7XFxuICBsaW5lLWhlaWdodDogMS4xNTtcXG5cIjtcbnZhciBidXR0b25TdHlsZXMgPSBcIlxcbiAgY3Vyc29yOiBwb2ludGVyO1xcblwiO1xudmFyIHNlbGVjdGVkU3R5bGVzID0gXCJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM0YTkwZTI7XFxuXCI7XG52YXIgZXJyb3JTdHlsZXMgPSBcIlxcbiAgYm9yZGVyOiAxcHggc29saWQgI2UyNTA0YTtcXG5cIjtcbnZhciBtc2dTdHlsZXMkMSA9IFwiXFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc2l6ZTogMC44ODllbTtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuXCI7XG52YXIgZXJyb3JNc2dTdHlsZXMgPSBcIlxcbiAgY29sb3I6ICNlMjUwNGE7XFxuXCI7XG5cbmZ1bmN0aW9uIGRlcml2YXRpb25QYXRoKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBoZWFkaW5nID0gb3B0aW9ucy5oZWFkaW5nLFxuICAgICAgZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgaWNvbiA9IG9wdGlvbnMuaWNvbjtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgc2hvd0N1c3RvbUlucHV0OiBmYWxzZSxcbiAgICBkUGF0aDogJycsXG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgZXJyb3I6ICcnXG4gIH07XG5cbiAgdmFyIGN1c3RvbUlucHV0SHRtbFN0cmluZyA9IGZ1bmN0aW9uIGN1c3RvbUlucHV0SHRtbFN0cmluZyhlcnJvcikge1xuICAgIHJldHVybiBcIlxcbiAgICAgIDxpbnB1dCBcXG4gICAgICAgIGlkPVxcXCJjdXN0b20tZGVyaXZhdGlvbi1pbnB1dFxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwiXCIuY29uY2F0KGJhc2VTdHlsZXMgKyBzZWxlY3RlZFN0eWxlcyArIChlcnJvciA/IGVycm9yU3R5bGVzIDogJycpLCBcIlxcXCIgXFxuICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIiBcXG4gICAgICAgIHZhbHVlPVxcXCJcIikuY29uY2F0KHN0YXRlLmRQYXRoLCBcIlxcXCJcXG4gICAgICAgIHBsYWNlaG9sZGVyPVxcXCJjdXN0b20gZGVyaXZhdGlvbiBwYXRoXFxcIiBcXG4gICAgICAgIG9uY2hhbmdlPVxcXCJ3aW5kb3cuaGFuZGxlQ3VzdG9tSW5wdXQodGhpcy52YWx1ZSlcXFwiIC8+XFxuICAgICAgXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRlcml2YXRpb25TZWxlY3RIdG1sU3RyaW5nKHdhbGxldE5hbWUpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICA8ZGl2IGlkPVxcXCJkZXJpdmF0aW9uLXNlbGVjdFxcXCIgc3R5bGU9XFxcIlwiLmNvbmNhdChzdHlsZXMsIFwiXFxcIj5cXG4gICAgICAgIFwiKS5jb25jYXQoZGVyaXZhdGlvblBhdGhzW3dhbGxldE5hbWVdLm1hcChmdW5jdGlvbiAoZGVyaXZhdGlvbikge1xuICAgICAgdmFyIHBhdGggPSBkZXJpdmF0aW9uLnBhdGgsXG4gICAgICAgICAgbGFiZWwgPSBkZXJpdmF0aW9uLmxhYmVsO1xuICAgICAgcmV0dXJuIFwiXFxuICAgICAgICAgICAgICA8YnV0dG9uIHN0eWxlPVxcXCJcIi5jb25jYXQoYmFzZVN0eWxlcyArIGJ1dHRvblN0eWxlcyArIChzdGF0ZS5kUGF0aCA9PT0gcGF0aCAmJiAhc3RhdGUuc2hvd0N1c3RvbUlucHV0ID8gc2VsZWN0ZWRTdHlsZXMgOiAnJyksIFwiXFxcIiBvbmNsaWNrPVxcXCJ3aW5kb3cuaGFuZGxlRGVyaXZhdGlvbkNsaWNrKHRoaXMpXFxcIiBkYXRhLXBhdGg9XFxcIlwiKS5jb25jYXQocGF0aCwgXCJcXFwiPlxcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KGxhYmVsLCBcIiAtIFwiKS5jb25jYXQocGF0aCwgXCJcXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIFwiKTtcbiAgICB9KS5qb2luKCcgJyksIFwiXFxuICAgICAgICBcIikuY29uY2F0KHN0YXRlLnNob3dDdXN0b21JbnB1dCA/IGN1c3RvbUlucHV0SHRtbFN0cmluZyhzdGF0ZS5lcnJvcikgOiBcIjxidXR0b24gc3R5bGU9XFxcIlwiLmNvbmNhdChiYXNlU3R5bGVzICsgYnV0dG9uU3R5bGVzLCBcIlxcXCIgb25jbGljaz1cXFwid2luZG93LmhhbmRsZURlcml2YXRpb25DbGljayh0aGlzKVxcXCIgZGF0YS1wYXRoPVxcXCJjdXN0b21cXFwiPkN1c3RvbSBQYXRoPC9idXR0b24+XCIpLCBcIlxcbiAgICAgICAgXCIpLmNvbmNhdChzdGF0ZS5sb2FkaW5nID8gXCI8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLWxvYWRpbmdcXFwiIHN0eWxlPVxcXCJtYXJnaW4tdG9wOiAxcmVtO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1maXJzdFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1zZWNvbmRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctdGhpcmRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cXFwiXCIuY29uY2F0KG1zZ1N0eWxlcyQxLCBcIlxcXCI+TG9hZGluZyBBY2NvdW50cy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICAgIFwiKSA6IHN0YXRlLmVycm9yID8gXCI8c3BhbiBzdHlsZT1cXFwiXCIuY29uY2F0KG1zZ1N0eWxlcyQxICsgZXJyb3JNc2dTdHlsZXMsIFwiXFxcIj5cIikuY29uY2F0KHN0YXRlLmVycm9yLCBcIjwvc3Bhbj5cIikgOiAnJywgXCJcXG4gICAgICA8L2Rpdj5cXG4gICAgXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgICBzdGF0ZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5zaG93Q3VzdG9tSW5wdXQgPSBmYWxzZTtcbiAgICBzdGF0ZS5kUGF0aCA9ICcnO1xuICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICBzdGF0ZS5lcnJvciA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tNb2R1bGUoc3RhdGVBbmRIZWxwZXJzKSB7XG4gICAgdmFyIHdhbGxldCA9IHN0YXRlQW5kSGVscGVycy53YWxsZXQ7XG5cbiAgICBpZiAod2FsbGV0ICYmIHdhbGxldC50eXBlID09PSAnaGFyZHdhcmUnICYmICFzdGF0ZS5jb21wbGV0ZWQpIHtcbiAgICAgIHZhciBoYW5kbGVDdXN0b21JbnB1dCA9IGZ1bmN0aW9uIGhhbmRsZUN1c3RvbUlucHV0KCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VzdG9tLWRlcml2YXRpb24taW5wdXQnKTtcbiAgICAgICAgc3RhdGUuZFBhdGggPSBpbnB1dCAmJiBpbnB1dC52YWx1ZTtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSAnJztcbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVEZXJpdmF0aW9uQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVEZXJpdmF0aW9uQ2xpY2soYnV0dG9uKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFBhdGggPSBidXR0b24uZGF0YXNldC5wYXRoO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFBhdGggPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgc3RhdGUuc2hvd0N1c3RvbUlucHV0ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXN0b20tZGVyaXZhdGlvbi1pbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQgJiYgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gJyc7XG4gICAgICAgICAgc3RhdGUuc2hvd0N1c3RvbUlucHV0ID0gZmFsc2U7XG4gICAgICAgICAgc3RhdGUuZFBhdGggPSBzZWxlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVsZXRlV2luZG93UHJvcGVydGllcygpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5oYW5kbGVDdXN0b21JbnB1dDtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5oYW5kbGVEZXJpdmF0aW9uU2VsZWN0O1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmhhbmRsZUN1c3RvbUlucHV0ID0gaGFuZGxlQ3VzdG9tSW5wdXQ7XG4gICAgICB3aW5kb3cuaGFuZGxlRGVyaXZhdGlvbkNsaWNrID0gaGFuZGxlRGVyaXZhdGlvbkNsaWNrO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGluZzogaGVhZGluZyB8fCAnSGFyZHdhcmUgV2FsbGV0IENvbm5lY3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgXCJNYWtlIHN1cmUgeW91ciBcIi5jb25jYXQod2FsbGV0Lm5hbWUsIFwiIGlzIHBsdWdnZWQgaW4sIFwiKS5jb25jYXQod2FsbGV0Lm5hbWUgPT09ICdMZWRnZXInID8gJ2FuZCB0aGUgRXRoZXJldW0gYXBwIGlzIG9wZW4sICcgOiAnJywgXCJ0aGVuIHNlbGVjdCBhIGRlcml2YXRpb24gcGF0aCB0byBjb25uZWN0IHlvdXIgYWNjb3VudHM6XCIpLFxuICAgICAgICBldmVudENvZGU6ICdkZXJpdmF0aW9uUGF0aCcsXG4gICAgICAgIGh0bWw6IGRlcml2YXRpb25TZWxlY3RIdG1sU3RyaW5nKHdhbGxldC5uYW1lKSxcbiAgICAgICAgYnV0dG9uOiB7XG4gICAgICAgICAgdGV4dDogJ0Nvbm5lY3QnLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfb25jbGljayA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKCkge1xuICAgICAgICAgICAgICB2YXIgcGF0aCwgdmFsaWRQYXRoO1xuICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gc3RhdGUuZFBhdGggfHwgZGVyaXZhdGlvblBhdGhzW3dhbGxldC5uYW1lXVswXS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LnByb3ZpZGVyLnNldFBhdGgocGF0aCwgc3RhdGUuc2hvd0N1c3RvbUlucHV0KTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgdmFsaWRQYXRoID0gX2NvbnRleHQxMS5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lcnJvciA9IFwiXCIuY29uY2F0KHBhdGgsIFwiIGlzIG5vdCBhIHZhbGlkIGRlcml2YXRpb24gcGF0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLnQwID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gX2NvbnRleHQxMS50MDtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXJyb3IgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQuY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmNvbm5lY3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlV2luZG93UHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgX2NhbGxlZTExLCBudWxsLCBbWzIsIDEyXV0pO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbmNsaWNrKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX29uY2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9uY2xpY2s7XG4gICAgICAgICAgfSgpXG4gICAgICAgIH0sXG4gICAgICAgIGljb246IGljb24gfHwgdXNiSWNvblxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBjaGVja01vZHVsZS5yZXNldCA9IHJlc2V0U3RhdGU7XG4gIHJldHVybiBjaGVja01vZHVsZTtcbn1cblxudmFyIGRlcml2YXRpb25QYXRoJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgJ2RlZmF1bHQnOiBkZXJpdmF0aW9uUGF0aFxufSk7XG4vKiBzcmMvdmlld3MvT25ib2FyZC5zdmVsdGUgZ2VuZXJhdGVkIGJ5IFN2ZWx0ZSB2My4yNC4wICovXG5cbmZ1bmN0aW9uIGFkZF9jc3MkYigpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLTF5eHk2MTItc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcIi5ibi1vbmJvYXJkLWN1c3RvbS5ibi1vbmJvYXJkLWRhcmstbW9kZXtiYWNrZ3JvdW5kOiMyODM5NDQ7Y29sb3I6I2ZmZmZmZn0uYm4tb25ib2FyZC1jdXN0b20uYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZC1ob3Zlcjpob3ZlciwgLmJuLW9uYm9hcmQtY3VzdG9tLmJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmR7YmFja2dyb3VuZDojMGUyMTJhfS5ibi1vbmJvYXJkLWNsaWNrYWJsZXt0ZXh0LWRlY29yYXRpb246bm9uZX0uYm4tb25ib2FyZC1jbGlja2FibGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uYm4tb25ib2FyZC1jdXN0b20uYm4tb25ib2FyZC1kYXJrLW1vZGUtbGlua3tjb2xvcjojOTFiY2VkO2JvcmRlci1jb2xvcjojOTFiY2VkfS5ibi1vbmJvYXJkLXdhbGxldC1jaGVjay1zZWN0aW9uIHNlbGVjdHtwYWRkaW5nOjAuNXJlbX1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDQwOjApIHsjaWYgJGFwcC53YWxsZXRTZWxlY3RJblByb2dyZXNzfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18yJDMoY3R4KSB7XG4gIHZhciB3YWxsZXRzZWxlY3Q7XG4gIHZhciBjdXJyZW50O1xuICB3YWxsZXRzZWxlY3QgPSBuZXcgV2FsbGV0U2VsZWN0KHtcbiAgICBwcm9wczoge1xuICAgICAgbW9kdWxlOlxuICAgICAgLyp3YWxsZXRTZWxlY3RNb2R1bGUqL1xuICAgICAgY3R4WzBdXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudCh3YWxsZXRzZWxlY3QuJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KHdhbGxldHNlbGVjdCwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciB3YWxsZXRzZWxlY3RfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qd2FsbGV0U2VsZWN0TW9kdWxlKi9cbiAgICAgIDEpIHdhbGxldHNlbGVjdF9jaGFuZ2VzLm1vZHVsZSA9XG4gICAgICAvKndhbGxldFNlbGVjdE1vZHVsZSovXG4gICAgICBjdHhbMF07XG4gICAgICB3YWxsZXRzZWxlY3QuJHNldCh3YWxsZXRzZWxlY3RfY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbih3YWxsZXRzZWxlY3QuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQod2FsbGV0c2VsZWN0LiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQod2FsbGV0c2VsZWN0LCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDQ0OjApIHsjaWYgJGFwcC53YWxsZXRDaGVja0luUHJvZ3Jlc3N9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzEkNShjdHgpIHtcbiAgdmFyIHdhbGxldGNoZWNrO1xuICB2YXIgY3VycmVudDtcbiAgd2FsbGV0Y2hlY2sgPSBuZXcgV2FsbGV0Q2hlY2soe1xuICAgIHByb3BzOiB7XG4gICAgICB3YWxsZXRTZWxlY3Q6XG4gICAgICAvKndhbGxldFNlbGVjdCovXG4gICAgICBjdHhbMV1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KHdhbGxldGNoZWNrLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudCh3YWxsZXRjaGVjaywgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciB3YWxsZXRjaGVja19jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp3YWxsZXRTZWxlY3QqL1xuICAgICAgMikgd2FsbGV0Y2hlY2tfY2hhbmdlcy53YWxsZXRTZWxlY3QgPVxuICAgICAgLyp3YWxsZXRTZWxlY3QqL1xuICAgICAgY3R4WzFdO1xuICAgICAgd2FsbGV0Y2hlY2suJHNldCh3YWxsZXRjaGVja19jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHdhbGxldGNoZWNrLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KHdhbGxldGNoZWNrLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQod2FsbGV0Y2hlY2ssIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoNDg6MCkgeyNpZiAkYXBwLmFjY291bnRTZWxlY3RJblByb2dyZXNzfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQ5KGN0eCkge1xuICB2YXIgd2FsbGV0Y2hlY2s7XG4gIHZhciBjdXJyZW50O1xuICB3YWxsZXRjaGVjayA9IG5ldyBXYWxsZXRDaGVjayh7XG4gICAgcHJvcHM6IHtcbiAgICAgIG1vZHVsZXM6IFtkZXJpdmF0aW9uUGF0aCgpLCBhY2NvdW50U2VsZWN0KCldXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudCh3YWxsZXRjaGVjay4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQod2FsbGV0Y2hlY2ssIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogbm9vcCxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbih3YWxsZXRjaGVjay4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dCh3YWxsZXRjaGVjay4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHdhbGxldGNoZWNrLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JGIoY3R4KSB7XG4gIHZhciB0MDtcbiAgdmFyIHQxO1xuICB2YXIgaWZfYmxvY2syX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBpZl9ibG9jazAgPVxuICAvKiRhcHAqL1xuICBjdHhbMl0ud2FsbGV0U2VsZWN0SW5Qcm9ncmVzcyAmJiBjcmVhdGVfaWZfYmxvY2tfMiQzKGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKiRhcHAqL1xuICBjdHhbMl0ud2FsbGV0Q2hlY2tJblByb2dyZXNzICYmIGNyZWF0ZV9pZl9ibG9ja18xJDUoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrMiA9XG4gIC8qJGFwcCovXG4gIGN0eFsyXS5hY2NvdW50U2VsZWN0SW5Qcm9ncmVzcyAmJiBjcmVhdGVfaWZfYmxvY2skOSgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuYygpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmMoKTtcbiAgICAgIHQxID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazIpIGlmX2Jsb2NrMi5jKCk7XG4gICAgICBpZl9ibG9jazJfYW5jaG9yID0gZW1wdHkoKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQwLCBhbmNob3IpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDEsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpZl9ibG9jazJfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjM1KSB7XG4gICAgICB2YXIgX3JlZjM2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjM1LCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYzNlswXTtcblxuICAgICAgaWYgKFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFsyXS53YWxsZXRTZWxlY3RJblByb2dyZXNzKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgICBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyokYXBwKi9cbiAgICAgICAgICA0KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IGNyZWF0ZV9pZl9ibG9ja18yJDMoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazAubSh0MC5wYXJlbnROb2RlLCB0MCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazAsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazAgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbMl0ud2FsbGV0Q2hlY2tJblByb2dyZXNzKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgICBpZl9ibG9jazEucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyokYXBwKi9cbiAgICAgICAgICA0KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9ja18xJDUoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazEubSh0MS5wYXJlbnROb2RlLCB0MSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazEsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazEgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbMl0uYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMikge1xuICAgICAgICAgIGlmX2Jsb2NrMi5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5ICZcbiAgICAgICAgICAvKiRhcHAqL1xuICAgICAgICAgIDQpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2syLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2syID0gY3JlYXRlX2lmX2Jsb2NrJDkoKTtcbiAgICAgICAgICBpZl9ibG9jazIuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2syLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazIubShpZl9ibG9jazJfYW5jaG9yLnBhcmVudE5vZGUsIGlmX2Jsb2NrMl9hbmNob3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMikge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2syLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2syID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2syKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMSk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazIpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDApO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MSk7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGlmX2Jsb2NrMl9hbmNob3IpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkYigkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgJGFwcDtcbiAgY29tcG9uZW50X3N1YnNjcmliZSgkJHNlbGYsIGFwcCwgZnVuY3Rpb24gKCQkdmFsdWUpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDIsICRhcHAgPSAkJHZhbHVlKTtcbiAgfSk7XG4gIHZhciB3YWxsZXRTZWxlY3RNb2R1bGUgPSAkJHByb3BzLndhbGxldFNlbGVjdE1vZHVsZTtcbiAgdmFyIHdhbGxldFNlbGVjdCA9ICQkcHJvcHMud2FsbGV0U2VsZWN0O1xuXG4gICQkc2VsZi4kc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJ3YWxsZXRTZWxlY3RNb2R1bGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgd2FsbGV0U2VsZWN0TW9kdWxlID0gJCRwcm9wcy53YWxsZXRTZWxlY3RNb2R1bGUpO1xuICAgIGlmIChcIndhbGxldFNlbGVjdFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCB3YWxsZXRTZWxlY3QgPSAkJHByb3BzLndhbGxldFNlbGVjdCk7XG4gIH07XG5cbiAgcmV0dXJuIFt3YWxsZXRTZWxlY3RNb2R1bGUsIHdhbGxldFNlbGVjdCwgJGFwcF07XG59XG5cbnZhciBPbmJvYXJkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50MTIpIHtcbiAgX2luaGVyaXRzKE9uYm9hcmQsIF9TdmVsdGVDb21wb25lbnQxMik7XG5cbiAgdmFyIF9zdXBlcjEyID0gX2NyZWF0ZVN1cGVyKE9uYm9hcmQpO1xuXG4gIGZ1bmN0aW9uIE9uYm9hcmQob3B0aW9ucykge1xuICAgIHZhciBfdGhpczEyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9uYm9hcmQpO1xuXG4gICAgX3RoaXMxMiA9IF9zdXBlcjEyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xeXh5NjEyLXN0eWxlXCIpKSBhZGRfY3NzJGIoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMiksIG9wdGlvbnMsIGluc3RhbmNlJGIsIGNyZWF0ZV9mcmFnbWVudCRiLCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgd2FsbGV0U2VsZWN0TW9kdWxlOiAwLFxuICAgICAgd2FsbGV0U2VsZWN0OiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMTI7XG4gIH1cblxuICByZXR1cm4gT25ib2FyZDtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcblxudmFyIHZlcnNpb24gPSBcIjEuMTYuMFwiOyAvLyB3YWxsZXRzIHRoYXQgcXVhbGlmeSBmb3IgZGVmYXVsdCB3YWxsZXRzIG5lZWQgdG8gaGF2ZSBub1xuLy8gaW5pdCBwYXJhbWV0ZXJzIHRoYXQgYXJlIHJlcXVpcmVkIGZvciBmdWxsIGZ1bmN0aW9uYWxpdHlcblxudmFyIGRlZmF1bHRXYWxsZXROYW1lcyA9IFsnd2ViM1dhbGxldCcsICdtZXRhbWFzaycsICdkYXBwZXInLCAnY29pbmJhc2UnLCAndHJ1c3QnLCAnYXV0aGVyZXVtJywgJ3RvcnVzJywgJ29wZXJhJywgJ29wZXJhVG91Y2gnLCAnc3RhdHVzJywgJ2h5cGVycGF5JywgJ3VuaWxvZ2luJywgJ3Rva2VucG9ja2V0JywgJ2RjZW50J107XG5cbmZ1bmN0aW9uIHNlbGVjdCh3YWxsZXRzLCBuZXR3b3JrSWQpIHtcbiAgaWYgKHdhbGxldHMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FsbGV0cy5tYXAoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgaWYgKGlzV2FsbGV0SW5pdCh3YWxsZXQpKSB7XG4gICAgICAgIHZhciB3YWxsZXROYW1lID0gd2FsbGV0LndhbGxldE5hbWUsXG4gICAgICAgICAgICBpbml0UGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHdhbGxldCwgW1wid2FsbGV0TmFtZVwiXSk7XG5cbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZSh3YWxsZXROYW1lKTtcblxuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh3YWxsZXROYW1lLCBcIiBpcyBub3QgYSB2YWxpZCB3YWxsZXROYW1lLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kdWxlICYmIG1vZHVsZS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaW5pdFBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2FsbGV0KTtcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwoZGVmYXVsdFdhbGxldE5hbWVzLm1hcChmdW5jdGlvbiAod2FsbGV0TmFtZSkge1xuICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGUod2FsbGV0TmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGUobmFtZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdtZWV0b25lJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbWVldG9uZS00OThkNWIzOS5qcycpO1xuXG4gICAgY2FzZSAnbWV0YW1hc2snOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9tZXRhbWFzay1kZjkxOGFjOS5qcycpO1xuXG4gICAgY2FzZSAnZGFwcGVyJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vZGFwcGVyLWJlOTViMGU2LmpzJyk7XG5cbiAgICBjYXNlICdwb3J0aXMnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9wb3J0aXMtY2JiNTM3NTMuanMnKTtcblxuICAgIGNhc2UgJ2ZvcnRtYXRpYyc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2ZvcnRtYXRpYy0yMjU1MDdkMS5qcycpO1xuXG4gICAgY2FzZSAnc3F1YXJlbGluayc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3NxdWFyZWxpbmstMTUwYTlkODMuanMnKTtcblxuICAgIGNhc2UgJ2F1dGhlcmV1bSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2F1dGhlcmV1bS01N2FlMzM4MS5qcycpO1xuXG4gICAgY2FzZSAndHJ1c3QnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi90cnVzdC02N2U0N2ZmYS5qcycpO1xuXG4gICAgY2FzZSAnY29pbmJhc2UnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9jb2luYmFzZS1jMGJiNDQ0OS5qcycpO1xuXG4gICAgY2FzZSAnd2FsbGV0Q29ubmVjdCc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3dhbGxldC1jb25uZWN0LTc0YmZhMzE3LmpzJyk7XG5cbiAgICBjYXNlICdvcGVyYSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL29wZXJhLWM4YmU4NTI2LmpzJyk7XG5cbiAgICBjYXNlICdvcGVyYVRvdWNoJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vb3BlcmEtdG91Y2gtMzZkNDQxMjIuanMnKTtcblxuICAgIGNhc2UgJ3RvcnVzJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vdG9ydXMtMGRiY2RlZDkuanMnKTtcblxuICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3N0YXR1cy0xN2FhY2MwNi5qcycpO1xuXG4gICAgY2FzZSAndHJlem9yJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vdHJlem9yLTA1MzQ1ZmNjLmpzJyk7XG5cbiAgICBjYXNlICdsYXR0aWNlJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbGF0dGljZS02M2U3MmE4Zi5qcycpO1xuXG4gICAgY2FzZSAnbGVkZ2VyJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbGVkZ2VyLTcxNjU3Y2M2LmpzJyk7XG5cbiAgICBjYXNlICd3YWxsZXRMaW5rJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vd2FsbGV0LWxpbmstYTRlNDQwNTMuanMnKTtcblxuICAgIGNhc2UgJ2ltVG9rZW4nOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9pbXRva2VuLWRmNjIxZDVhLmpzJyk7XG5cbiAgICBjYXNlICd1bmlsb2dpbic6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3VuaWxvZ2luLWZjNWQ4Mzg2LmpzJyk7XG5cbiAgICBjYXNlICdteWtleSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL215a2V5LWY5YTIzOGVkLmpzJyk7XG5cbiAgICBjYXNlICd3ZWIzV2FsbGV0JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vd2ViM1dhbGxldC1jNjFjNDk2My5qcycpO1xuXG4gICAgY2FzZSAnaHVvYml3YWxsZXQnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9odW9iaXdhbGxldC0xMTljY2MyOC5qcycpO1xuXG4gICAgY2FzZSAnd2FsbGV0LmlvJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vd2FsbGV0LWlvLWFkMzVhZTc3LmpzJyk7XG5cbiAgICBjYXNlICdoeXBlcnBheSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2h5cGVycGF5LWRhMzg2NWI0LmpzJyk7XG5cbiAgICBjYXNlICd0b2tlbnBvY2tldCc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3Rva2VucG9ja2V0LTZmY2U2YmM1LmpzJyk7XG5cbiAgICBjYXNlICdkY2VudCc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2RjZW50LWViNzZiOTVkLmpzJyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBkZWZhdWx0Q2hlY2tzID0gWydjb25uZWN0JywgJ25ldHdvcmsnXTtcblxuZnVuY3Rpb24gY2hlY2soX3gxMCwgX3gxMSkge1xuICByZXR1cm4gX2NoZWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jaGVjaygpIHtcbiAgX2NoZWNrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIod2FsbGV0Q2hlY2tzLCBuZXR3b3JrSWQpIHtcbiAgICB2YXIgY2hlY2tzO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF3YWxsZXRDaGVja3MpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrcyA9IHdhbGxldENoZWNrcy5tYXAoZnVuY3Rpb24gKGNoZWNrT3JNb2R1bGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1dhbGxldENoZWNrTW9kdWxlKGNoZWNrT3JNb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrTmFtZSA9IGNoZWNrT3JNb2R1bGUuY2hlY2tOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvdGhlclBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhjaGVja09yTW9kdWxlLCBbXCJjaGVja05hbWVcIl0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZSQxKGNoZWNrTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZSAmJiBtb2R1bGUudGhlbihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3RoZXJQYXJhbXMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZFxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGVja09yTW9kdWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UuYWxsKGNoZWNrcykpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UuYWxsKGRlZmF1bHRDaGVja3MubWFwKGZ1bmN0aW9uIChjaGVja05hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZSQxKGNoZWNrTmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBtb2R1bGUgJiYgbW9kdWxlLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbVtcImRlZmF1bHRcIl0oe1xuICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9jaGVjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGUkMShuYW1lKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9jb25uZWN0LTQyZjg2YTM4LmpzJyk7XG5cbiAgICBjYXNlICduZXR3b3JrJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbmV0d29yay0yYzY0MTJhNS5qcycpO1xuXG4gICAgY2FzZSAnYmFsYW5jZSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2JhbGFuY2UtMzdhOWFiMGUuanMnKTtcblxuICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdkZXJpdmF0aW9uUGF0aCc6XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmF0aW9uUGF0aCQxO1xuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtb2R1bGUgbmFtZTogXCIuY29uY2F0KG5hbWUpKTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdEhlYWRpbmcgPSAnU2VsZWN0IGEgV2FsbGV0JztcbnZhciBkZWZhdWx0RGVzY3JpcHRpb24gPSAnUGxlYXNlIHNlbGVjdCBhIHdhbGxldCB0byBjb25uZWN0IHRvIHRoaXMgZGFwcDonO1xudmFyIGRlZmF1bHRXYWxsZXRFeHBsYW5hdGlvbiA9IFwiV2FsbGV0cyBhcmUgdXNlZCB0byBzZW5kLCByZWNlaXZlLCBhbmQgc3RvcmUgZGlnaXRhbCBhc3NldHMgbGlrZSBFdGhlci4gV2FsbGV0cyBjb21lIGluIG1hbnkgZm9ybXMuIFRoZXkgYXJlIGVpdGhlciBidWlsdCBpbnRvIHlvdXIgYnJvd3NlciwgYW4gZXh0ZW5zaW9uIGFkZGVkIHRvIHlvdXIgYnJvd3NlciwgYSBwaWVjZSBvZiBoYXJkd2FyZSBwbHVnZ2VkIGludG8geW91ciBjb21wdXRlciBvciBldmVuIGFuIGFwcCBvbiB5b3VyIHBob25lLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3YWxsZXRzLCBzZWUgPGEgc3R5bGU9XFxcImNvbG9yOiAjNGE5MGUyOyBmb250LXNpemU6IDAuODg5cmVtOyBmb250LWZhbWlseTogaW5oZXJpdDtcXFwiIGNsYXNzPVxcXCJibi1vbmJvYXJkLWNsaWNrYWJsZVxcXCIgaHJlZj1cXFwiaHR0cHM6Ly9kb2NzLmV0aGh1Yi5pby91c2luZy1ldGhlcmV1bS93YWxsZXRzL2ludHJvLXRvLWV0aGVyZXVtLXdhbGxldHMvXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgcmVsPVxcXCJub29wZW5lciBub3JlZmVycmVyXFxcIj50aGlzIGV4cGxhbmF0aW9uPC9hPi5cIjtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZU1vZHVsZXMobmV0d29ya0lkLCB3YWxsZXRTZWxlY3QsIHdhbGxldENoZWNrKSB7XG4gIHZhciB3YWxsZXRzID0gc2VsZWN0KHdhbGxldFNlbGVjdCAmJiB3YWxsZXRTZWxlY3Qud2FsbGV0cywgbmV0d29ya0lkKTtcbiAgcmV0dXJuIHtcbiAgICB3YWxsZXRTZWxlY3Q6IHtcbiAgICAgIGhlYWRpbmc6IHdhbGxldFNlbGVjdCAmJiB3YWxsZXRTZWxlY3QuaGVhZGluZyB8fCBkZWZhdWx0SGVhZGluZyxcbiAgICAgIGRlc2NyaXB0aW9uOiB3YWxsZXRTZWxlY3QgJiYgd2FsbGV0U2VsZWN0LmRlc2NyaXB0aW9uIHx8IGRlZmF1bHREZXNjcmlwdGlvbixcbiAgICAgIHdhbGxldHM6IHdhbGxldHMsXG4gICAgICBleHBsYW5hdGlvbjogd2FsbGV0U2VsZWN0ICYmIHdhbGxldFNlbGVjdC5leHBsYW5hdGlvbiB8fCBkZWZhdWx0V2FsbGV0RXhwbGFuYXRpb25cbiAgICB9LFxuICAgIHdhbGxldENoZWNrOiBjaGVjayh3YWxsZXRDaGVjaywgbmV0d29ya0lkKVxuICB9O1xufVxuXG52YXIgb25ib2FyZDtcblxuZnVuY3Rpb24gaW5pdCQxKGluaXRpYWxpemF0aW9uKSB7XG4gIGlmIChvbmJvYXJkKSB7XG4gICAgY29uc29sZS53YXJuKCdvbmJvYXJkIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICBvbmJvYXJkLiRkZXN0cm95KCk7XG4gIH1cblxuICB2YWxpZGF0ZUluaXQoaW5pdGlhbGl6YXRpb24pO1xuICB2YXIgc3Vic2NyaXB0aW9ucyA9IGluaXRpYWxpemF0aW9uLnN1YnNjcmlwdGlvbnMsXG4gICAgICBkYXBwSWQgPSBpbml0aWFsaXphdGlvbi5kYXBwSWQsXG4gICAgICBuZXR3b3JrSWQgPSBpbml0aWFsaXphdGlvbi5uZXR3b3JrSWQsXG4gICAgICBkYXJrTW9kZSA9IGluaXRpYWxpemF0aW9uLmRhcmtNb2RlLFxuICAgICAgYXBpVXJsID0gaW5pdGlhbGl6YXRpb24uYXBpVXJsLFxuICAgICAgaGlkZUJyYW5kaW5nID0gaW5pdGlhbGl6YXRpb24uaGlkZUJyYW5kaW5nO1xuXG4gIHZhciBfZ2V0RGV2aWNlSW5mbyA9IGdldERldmljZUluZm8oKSxcbiAgICAgIG9zID0gX2dldERldmljZUluZm8ub3MsXG4gICAgICBicm93c2VyID0gX2dldERldmljZUluZm8uYnJvd3NlcixcbiAgICAgIGlzTW9iaWxlID0gX2dldERldmljZUluZm8uaXNNb2JpbGU7XG5cbiAgdmFyIGluaXRpYWxpemVkTW9kdWxlcyA9IGluaXRpYWxpemVNb2R1bGVzKG5ldHdvcmtJZCwgaW5pdGlhbGl6YXRpb24ud2FsbGV0U2VsZWN0LCBpbml0aWFsaXphdGlvbi53YWxsZXRDaGVjayk7XG4gIHZhciBkaXNwbGF5QnJhbmRpbmc7XG5cbiAgaWYgKGRhcHBJZCkge1xuICAgIGlmIChoaWRlQnJhbmRpbmcgIT09IGZhbHNlKSB7XG4gICAgICBkaXNwbGF5QnJhbmRpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhpZGVCcmFuZGluZyAhPT0gdHJ1ZSkge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICBkYXBwSWQ6IGRhcHBJZCxcbiAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIG1vYmlsZURldmljZTogaXNNb2JpbGUsXG4gICAgICBvczogb3MsXG4gICAgICBicm93c2VyOiBicm93c2VyLFxuICAgICAgZGFya01vZGU6IGRhcmtNb2RlLFxuICAgICAgZGlzcGxheUJyYW5kaW5nOiBkaXNwbGF5QnJhbmRpbmcsXG4gICAgICBjaGVja01vZHVsZXM6IGluaXRpYWxpemVkTW9kdWxlcy53YWxsZXRDaGVja1xuICAgIH0pO1xuICB9KTtcbiAgaW5pdGlhbGl6ZVN0b3JlcygpO1xuXG4gIGlmIChkYXBwSWQpIHtcbiAgICBpbml0aWFsaXplQmxvY2tuYXRpdmUoZGFwcElkLCBuZXR3b3JrSWQsIGFwaVVybCk7XG4gIH1cblxuICBvbmJvYXJkID0gbmV3IE9uYm9hcmQoe1xuICAgIHRhcmdldDogZG9jdW1lbnQuYm9keSxcbiAgICBwcm9wczoge1xuICAgICAgd2FsbGV0U2VsZWN0TW9kdWxlOiBpbml0aWFsaXplZE1vZHVsZXMud2FsbGV0U2VsZWN0LFxuICAgICAgd2FsbGV0U2VsZWN0OiB3YWxsZXRTZWxlY3RcbiAgICB9XG4gIH0pOyAvLyByZWdpc3RlciBzdWJzY3JpcHRpb25zXG5cbiAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9ucy5hZGRyZXNzKSB7XG4gICAgICBhZGRyZXNzLnN1YnNjcmliZShmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMuYWRkcmVzcyAmJiBzdWJzY3JpcHRpb25zLmFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWJzY3JpcHRpb25zLm5ldHdvcmspIHtcbiAgICAgIG5ldHdvcmsuc3Vic2NyaWJlKGZ1bmN0aW9uIChuZXR3b3JrSWQpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtJZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMubmV0d29yayAmJiBzdWJzY3JpcHRpb25zLm5ldHdvcmsobmV0d29ya0lkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMuYmFsYW5jZSkge1xuICAgICAgYmFsYW5jZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGJhbGFuY2UpIHtcbiAgICAgICAgaWYgKGJhbGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmJhbGFuY2UgJiYgc3Vic2NyaXB0aW9ucy5iYWxhbmNlKGJhbGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9ucy53YWxsZXQpIHtcbiAgICAgIHdhbGxldC5zdWJzY3JpYmUoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgICBpZiAod2FsbGV0LnByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy53YWxsZXQgJiYgc3Vic2NyaXB0aW9ucy53YWxsZXQod2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2FsbGV0U2VsZWN0KGF1dG9TZWxlY3RXYWxsZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICB3YWxsZXRTZWxlY3RJblByb2dyZXNzOiB0cnVlLFxuICAgICAgICAgIGF1dG9TZWxlY3RXYWxsZXQ6IHR5cGVvZiBhdXRvU2VsZWN0V2FsbGV0ID09PSAnc3RyaW5nJyAmJiBhdXRvU2VsZWN0V2FsbGV0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgYXBwVW5zdWJzY3JpYmUgPSBhcHAuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICB2YXIgd2FsbGV0U2VsZWN0SW5Qcm9ncmVzcyA9IHN0b3JlLndhbGxldFNlbGVjdEluUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3YWxsZXRTZWxlY3RDb21wbGV0ZWQgPSBzdG9yZS53YWxsZXRTZWxlY3RDb21wbGV0ZWQsXG4gICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSSA9IHN0b3JlLndhbGxldFNlbGVjdERpc3BsYXllZFVJO1xuXG4gICAgICAgIGlmICh3YWxsZXRTZWxlY3RJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgIGFwcFVuc3Vic2NyaWJlKCk7IC8vIHRpbWVvdXQgZm9yIFVJIHRyYW5zaXRpb25zIGlmIGl0IHdhcyBkaXNwbGF5ZWRcblxuICAgICAgICAgIHdhbGxldFNlbGVjdERpc3BsYXllZFVJID8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKHdhbGxldFNlbGVjdENvbXBsZXRlZCk7XG4gICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkVUk6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTAwKSA6IHJlc29sdmUod2FsbGV0U2VsZWN0Q29tcGxldGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWxsZXRDaGVjaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmICghZ2V0X3N0b3JlX3ZhbHVlKHdhbGxldEludGVyZmFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRTZWxlY3QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHdhbGxldENoZWNrJyk7XG4gICAgICB9XG5cbiAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICB3YWxsZXRDaGVja0luUHJvZ3Jlc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhcHBVbnN1YnNjcmliZSA9IGFwcC5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHZhciB3YWxsZXRDaGVja0luUHJvZ3Jlc3MgPSBzdG9yZS53YWxsZXRDaGVja0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3YWxsZXRDaGVja0NvbXBsZXRlZCA9IHN0b3JlLndhbGxldENoZWNrQ29tcGxldGVkLFxuICAgICAgICAgICAgd2FsbGV0Q2hlY2tEaXNwbGF5ZWRVSSA9IHN0b3JlLndhbGxldENoZWNrRGlzcGxheWVkVUk7XG5cbiAgICAgICAgaWYgKHdhbGxldENoZWNrSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBhcHBVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIHdhbGxldENoZWNrRGlzcGxheWVkVUkgPyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUod2FsbGV0Q2hlY2tDb21wbGV0ZWQpO1xuICAgICAgICAgICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXllZFVJOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDUwMCkgOiByZXNvbHZlKHdhbGxldENoZWNrQ29tcGxldGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWxsZXRSZXNldCgpIHtcbiAgICByZXNldFdhbGxldFN0YXRlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhY2NvdW50U2VsZWN0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIF9nZXRfc3RvcmVfdmFsdWU0ID0gZ2V0X3N0b3JlX3ZhbHVlKHdhbGxldCksXG4gICAgICAgICAgdHlwZSA9IF9nZXRfc3RvcmVfdmFsdWU0LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnaGFyZHdhcmUnKSB7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhcHBVbnN1YnNjcmliZSA9IGFwcC5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHZhciBhY2NvdW50U2VsZWN0SW5Qcm9ncmVzcyA9IHN0b3JlLmFjY291bnRTZWxlY3RJblByb2dyZXNzLFxuICAgICAgICAgICAgd2FsbGV0U2VsZWN0RGlzcGxheWVkVUkgPSBzdG9yZS53YWxsZXRTZWxlY3REaXNwbGF5ZWRVSTtcblxuICAgICAgICBpZiAoYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYXBwVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSSA/IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5ZWRVSTogZmFsc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCA1MDApIDogcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICAgIHZhbGlkYXRlQ29uZmlnKG9wdGlvbnMpO1xuICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGdldF9zdG9yZV92YWx1ZShzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdhbGxldFNlbGVjdDogd2FsbGV0U2VsZWN0LFxuICAgIHdhbGxldENoZWNrOiB3YWxsZXRDaGVjayxcbiAgICB3YWxsZXRSZXNldDogd2FsbGV0UmVzZXQsXG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIGFjY291bnRTZWxlY3Q6IGFjY291bnRTZWxlY3RcbiAgfTtcbn1cblxuZXhwb3J0IHsgbmV0d29ya1RvSWQgYXMgYSwgYmFsYW5jZUljb24gYXMgYiwgY29ubmVjdEljb24gYXMgYywgaW5pdCQxIGFzIGksIG5ldHdvcmtOYW1lIGFzIG4sIG9wZW5MaW5rIGFzIG8gfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard-197ee608.js\n");

/***/ }),

/***/ "./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/@pooltogether/bnc-onboard/node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onboard_197ee608_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onboard-197ee608.js */ \"./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard-197ee608.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _onboard_197ee608_js__WEBPACK_IMPORTED_MODULE_1__[\"i\"]; });\n\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bnc-sdk */ \"./node_modules/bnc-sdk/dist/esm/index.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb29sdG9nZXRoZXIvYm5jLW9uYm9hcmQvZGlzdC9lc20vb25ib2FyZC5qcz80MjA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDZ0I7QUFDL0I7QUFDTCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AcG9vbHRvZ2V0aGVyL2JuYy1vbmJvYXJkL2Rpc3QvZXNtL29uYm9hcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSc7XG5leHBvcnQgeyBpIGFzIGRlZmF1bHQgfSBmcm9tICcuL29uYm9hcmQtMTk3ZWU2MDguanMnO1xuaW1wb3J0ICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICdibmMtc2RrJztcbmltcG9ydCAnYm93c2VyJzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@pooltogether/bnc-onboard/dist/esm/onboard.js\n");

/***/ }),

/***/ "./node_modules/@pooltogether/bnc-onboard/node_modules/regenerator-runtime/runtime.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@pooltogether/bnc-onboard/node_modules/regenerator-runtime/runtime.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb29sdG9nZXRoZXIvYm5jLW9uYm9hcmQvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz84YjU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixTQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AcG9vbHRvZ2V0aGVyL2JuYy1vbmJvYXJkL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@pooltogether/bnc-onboard/node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.0.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                    // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if only one character,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.$|[+-.\\s]|(.).*\\1/.test(v)) {\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on ±Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and ±Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = ±Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return ±0, else return ±Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, ±Infinity or ±0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return ±Infinity if either is ±Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return ±0 if either is ±0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return ±Infinity if either ±Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '1e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanM/OTAxZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUF3RDtBQUN6Rjs7O0FBR0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCOztBQUVBO0FBQ0EsWUFBWSxPQUFPOztBQUVuQjtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsS0FBSzs7QUFFdkM7QUFDQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxNQUFNO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxhQUFhOztBQUUzQjtBQUNBLHNCQUFzQixTQUFTO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixnREFBZ0QsSUFBSSxPQUFPLElBQUk7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxNQUFNO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxNQUFNO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRyxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0Esb0NBQW9DLDRCQUE0QixJQUFJLEdBQUc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxnQ0FBZ0MsbURBQW1ELEdBQUcsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQkFBMEI7O0FBRWhEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPOztBQUV0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF5QztBQUMvQyxJQUFJLG1DQUFPLGFBQWEsa0JBQWtCLEVBQUU7QUFBQSxvR0FBQzs7QUFFN0M7QUFDQSxHQUFHLE1BQU0sRUFVTjtBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMFxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDE5IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCkge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgb25seSBvbmUgY2hhcmFjdGVyLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4kfFsrLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzFlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCkge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bignumber.js/bignumber.js\n");

/***/ }),

/***/ "./node_modules/bnc-sdk/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/bnc-sdk/dist/esm/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-es */ \"./node_modules/crypto-es/lib/index.js\");\n\n\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    retryMs,\n    limitRules,\n    blockedMsg\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0___default.a(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = crypto_es__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Blocknative);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JuYy1zZGsvZGlzdC9lc20vaW5kZXguanM/ZmQzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNkO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkMsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdJQUFnSTs7QUFFaEksK0JBQStCOztBQUUvQixrQ0FBa0M7O0FBRWxDLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnSUFBZ0k7O0FBRWhJLDBFQUEwRTs7QUFFMUUsa0NBQWtDOztBQUVsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBLHdHQUF3Rzs7QUFFeEcsaUdBQWlHOztBQUVqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxtREFBbUQsY0FBYztBQUNqRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHdCQUF3Qix1QkFBdUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx3QkFBd0IsdUJBQXVCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esd0JBQXdCLHNCQUFzQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFNBQVM7O0FBRWQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBLHdCQUF3QixLQUFLLHFCQUFxQixLQUFLLG1CQUFtQixhQUFhLGVBQWUsTUFBTTtBQUM1Rzs7QUFFQTtBQUNBLHdCQUF3QixNQUFNLG9CQUFvQixLQUFLO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFdBQVcsZ0NBQWdDLGFBQWEsbURBQW1ELHVCQUF1QjtBQUN6SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLHVEQUFlO0FBQ3RDO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaURBQVEsU0FBUyxPQUFPLEtBQUssS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRWUsMEVBQVcsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibmMtc2RrL2Rpc3QvZXNtL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0dXJkeVdlYlNvY2tldCBmcm9tICdzdHVyZHktd2Vic29ja2V0JztcbmltcG9ydCBDcnlwdG9FcyBmcm9tICdjcnlwdG8tZXMnO1xuY29uc3QgbmV0d29ya3MgPSB7XG4gIGJpdGNvaW46IHtcbiAgICAnMSc6ICdtYWluJyxcbiAgICAnMic6ICd0ZXN0bmV0J1xuICB9LFxuICBldGhlcmV1bToge1xuICAgICcxJzogJ21haW4nLFxuICAgICczJzogJ3JvcHN0ZW4nLFxuICAgICc0JzogJ3JpbmtlYnknLFxuICAgICc1JzogJ2dvZXJsaScsXG4gICAgJzQyJzogJ2tvdmFuJyxcbiAgICAnMTAwJzogJ3hkYWknXG4gIH1cbn07XG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVRfUlVMRVMgPSB7XG4gIHBvaW50czogMTUwLFxuICBkdXJhdGlvbjogMVxufTtcbmNvbnN0IFFVRVVFX0xJTUlUID0gMTAwMDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gIHJldHVybiB7XG4gICAgbGlzdGVuZXJzOiB7fSxcbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50Q29kZSwgbGlzdGVuZXIpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHZhbGlkIGV2ZW50Q29kZVxuICAgICAgc3dpdGNoIChldmVudENvZGUpIHtcbiAgICAgICAgY2FzZSAndHhTZW50JzpcbiAgICAgICAgY2FzZSAndHhQb29sJzpcbiAgICAgICAgY2FzZSAndHhDb25maXJtZWQnOlxuICAgICAgICBjYXNlICd0eFNwZWVkVXAnOlxuICAgICAgICBjYXNlICd0eENhbmNlbCc6XG4gICAgICAgIGNhc2UgJ3R4RmFpbGVkJzpcbiAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtldmVudENvZGV9IGlzIG5vdCBhIHZhbGlkIGV2ZW50IGNvZGUsIGZvciBhIGxpc3Qgb2YgdmFsaWQgZXZlbnQgY29kZXMgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmxvY2tuYXRpdmUvc2RrYCk7XG4gICAgICB9IC8vIGNoZWNrIHRoYXQgbGlzdGVuZXIgaXMgYSBmdW5jdGlvblxuXG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH0gLy8gYWRkIGxpc3RlbmVyIGZvciB0aGUgZXZlbnRDb2RlXG5cblxuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRDb2RlXSA9IGxpc3RlbmVyO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNbc3RhdGUuZXZlbnRDb2RlXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnNbc3RhdGUuZXZlbnRDb2RlXShzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5hbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFsbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrTmFtZShibG9ja2NoYWluLCBpZCkge1xuICByZXR1cm4gbmV0d29ya3NbYmxvY2tjaGFpbl1baWRdO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXJFY2hvKGV2ZW50Q29kZSkge1xuICBzd2l0Y2ggKGV2ZW50Q29kZSkge1xuICAgIGNhc2UgJ3R4UmVxdWVzdCc6XG4gICAgY2FzZSAnbnNmRmFpbCc6XG4gICAgY2FzZSAndHhSZXBlYXQnOlxuICAgIGNhc2UgJ3R4QXdhaXRpbmdBcHByb3ZhbCc6XG4gICAgY2FzZSAndHhDb25maXJtUmVtaW5kZXInOlxuICAgIGNhc2UgJ3R4U2VuZEZhaWwnOlxuICAgIGNhc2UgJ3R4RXJyb3InOlxuICAgIGNhc2UgJ3R4VW5kZXJQcmljZWQnOlxuICAgIGNhc2UgJ3R4U2VudCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgcmV0dXJuIGFyci5yZXZlcnNlKClbMF07XG59IC8vIGlzQWRkcmVzcyBhbmQgaXNUeGlkIGFyZSBub3QgbWVhbnQgdG8gcGVyZm9ybSByZWFsIHZhbGlkYXRpb24sXG4vLyBqdXN0IG5lZWRzIHRvIHdvcmsgb3V0IGlmIGl0IGlzIGFuIGFkZHJlc3Mgb3IgYSB0cmFuc2FjdGlvbiBpZFxuLy8gdGhlIHNlcnZlciB3aWxsIGRvIG1vcmUgdGhvcm91Z2ggdmFsaWRhdGlvblxuXG5cbmZ1bmN0aW9uIGlzQWRkcmVzcyhibG9ja2NoYWluLCBhZGRyZXNzT3JIYXNoKSB7XG4gIHN3aXRjaCAoYmxvY2tjaGFpbikge1xuICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNDI7XG5cbiAgICBjYXNlICdiaXRjb2luJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCAhPT0gNjQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHhpZChibG9ja2NoYWluLCBhZGRyZXNzT3JIYXNoKSB7XG4gIHN3aXRjaCAoYmxvY2tjaGFpbikge1xuICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNjY7XG5cbiAgICBjYXNlICdiaXRjb2luJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNjQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhaXQodGltZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGhhc2gsIGlkKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpOyAvLyBjcmVhdGUgc3RhcnRUaW1lIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIGNyZWF0ZSBlbWl0dGVyIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGVtaXR0ZXIgPSBjcmVhdGVFbWl0dGVyKCk7IC8vIGNyZWF0ZSBldmVudENvZGUgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZXZlbnRDb2RlID0gJ3R4U2VudCc7IC8vIHB1dCBpbiBxdWV1ZVxuXG4gIHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMucHVzaCh7XG4gICAgaGFzaCxcbiAgICBlbWl0dGVyXG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgIFt0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyAnaGFzaCcgOiAndHhpZCddOiBoYXNoLFxuICAgIGlkOiBpZCB8fCBoYXNoLFxuICAgIHN0YXJ0VGltZSxcbiAgICBzdGF0dXM6ICdzZW50J1xuICB9O1xuICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgZXZlbnRDb2RlXG4gIH07IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICBldmVudENvZGUsXG4gICAgY2F0ZWdvcnlDb2RlOiAnYWN0aXZlVHJhbnNhY3Rpb24nLFxuICAgIHRyYW5zYWN0aW9uXG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uT2JqID0ge1xuICAgIGRldGFpbHM6IHRyYW5zYWN0aW9uLFxuICAgIGVtaXR0ZXJcbiAgfTtcblxuICBmdW5jdGlvbiBlbWl0U3RhdGUoKSB7XG4gICAgY29uc3QgZW1pdHRlclJlc3VsdCA9IGVtaXR0ZXIuZW1pdChuZXdTdGF0ZSk7XG5cbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKHtcbiAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgIGVtaXR0ZXJSZXN1bHRcbiAgICB9KSk7XG4gIH0gLy8gZW1pdCBhZnRlciBkZWxheSB0byBhbGxvdyBmb3IgbGlzdGVuZXIgdG8gYmUgcmVnaXN0ZXJlZFxuXG5cbiAgc2V0VGltZW91dChlbWl0U3RhdGUuYmluZCh0aGlzKSwgNSk7XG4gIHJldHVybiB0cmFuc2FjdGlvbk9iajtcbn1cblxuZnVuY3Rpb24gYWNjb3VudChhZGRyZXNzKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpOyAvLyBsb3dlcmNhc2UgdGhlIGFkZHJlc3MgaWYgRXRoZXJldW1cblxuICBhZGRyZXNzID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gYWRkcmVzcy50b0xvd2VyQ2FzZSgpIDogYWRkcmVzczsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNyZWF0ZUVtaXR0ZXIoKTsgLy8gY3JlYXRlIGV2ZW50Q29kZSBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBldmVudENvZGUgPSAnd2F0Y2gnO1xuXG4gIGNvbnN0IGV4aXN0aW5nQWRkcmVzc1dhdGNoZXIgPSB0aGlzLl93YXRjaGVkQWNjb3VudHMuZmluZChhYyA9PiBhYy5hZGRyZXNzID09PSBhZGRyZXNzKTtcblxuICBpZiAoZXhpc3RpbmdBZGRyZXNzV2F0Y2hlcikge1xuICAgIC8vIGFkZCB0byBleGlzdGluZyBlbWl0dGVycyBhcnJheVxuICAgIGV4aXN0aW5nQWRkcmVzc1dhdGNoZXIuZW1pdHRlcnMucHVzaChlbWl0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwdXQgaW4gYWNjb3VudHMgcXVldWVcbiAgICB0aGlzLl93YXRjaGVkQWNjb3VudHMucHVzaCh7XG4gICAgICBhZGRyZXNzLFxuICAgICAgZW1pdHRlcnM6IFtlbWl0dGVyXVxuICAgIH0pO1xuICB9IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGV2ZW50Q29kZSxcbiAgICBjYXRlZ29yeUNvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgYWNjb3VudDoge1xuICAgICAgYWRkcmVzc1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbWl0dGVyLFxuICAgIGRldGFpbHM6IHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2ZW50KGV2ZW50T2JqKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKGV2ZW50T2JqKTtcbn1cblxuZnVuY3Rpb24gdW5zdWJzY3JpYmUoYWRkcmVzc09ySGFzaCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgY29uc3QgYWRkcmVzcyA9IGlzQWRkcmVzcyh0aGlzLl9zeXN0ZW0sIGFkZHJlc3NPckhhc2gpO1xuICBjb25zdCB0eGlkID0gaXNUeGlkKHRoaXMuX3N5c3RlbSwgYWRkcmVzc09ySGFzaCk7IC8vIGNoZWNrIGlmIGl0IGlzIGFuIGFkZHJlc3Mgb3IgYSBoYXNoXG5cbiAgaWYgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGFkZHJlc3NPckhhc2gudG9Mb3dlckNhc2UoKSA6IGFkZHJlc3NPckhhc2g7IC8vIHJlbW92ZSBhZGRyZXNzIGZyb20gYWNjb3VudHNcblxuICAgIHRoaXMuX3dhdGNoZWRBY2NvdW50cyA9IHRoaXMuX3dhdGNoZWRBY2NvdW50cy5maWx0ZXIoYWMgPT4gYWMuYWRkcmVzcyAhPT0gbm9ybWFsaXplZEFkZHJlc3MpOyAvLyBsb2dFdmVudCB0byBzZXJ2ZXJcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIGNhdGVnb3J5Q29kZTogJ2FjY291bnRBZGRyZXNzJyxcbiAgICAgIGV2ZW50Q29kZTogJ3Vud2F0Y2gnLFxuICAgICAgYWNjb3VudDoge1xuICAgICAgICBhZGRyZXNzOiBub3JtYWxpemVkQWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR4aWQpIHtcbiAgICAvLyByZW1vdmUgdHJhbnNhY3Rpb24gZnJvbSB0cmFuc2FjdGlvbnNcbiAgICB0aGlzLl93YXRjaGVkVHJhbnNhY3Rpb25zID0gdGhpcy5fd2F0Y2hlZFRyYW5zYWN0aW9ucy5maWx0ZXIodHggPT4gdHguaGFzaCAhPT0gYWRkcmVzc09ySGFzaCk7IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgY2F0ZWdvcnlDb2RlOiAnYWN0aXZlVHJhbnNhY3Rpb24nLFxuICAgICAgZXZlbnRDb2RlOiAndW53YXRjaCcsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICBbdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gJ2hhc2gnIDogJ3R4aWQnXTogYWRkcmVzc09ySGFzaCxcbiAgICAgICAgaWQ6IGFkZHJlc3NPckhhc2gsXG4gICAgICAgIHN0YXR1czogJ3Vuc3Vic2NyaWJlZCdcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHRyeWluZyB0byB1bnN1YnNjcmliZSAke2FkZHJlc3NPckhhc2h9OiBub3QgYSB2YWxpZCBhZGRyZXNzIG9yIHRyYW5zYWN0aW9uIGlkL2hhc2hgKTtcbiAgfVxufVxuXG52YXIgdmVyc2lvbiA9IFwiMi4xLjVcIjtcblxuZnVuY3Rpb24gc2VuZE1lc3NhZ2UobXNnKSB7XG4gIGlmICh0aGlzLl9xdWV1ZWRNZXNzYWdlcy5sZW5ndGggPiBRVUVVRV9MSU1JVCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgUXVldWUgbGltaXQgb2YgJHtRVUVVRV9MSU1JVH0gbWVzc2FnZXMgaGFzIGJlZW4gcmVhY2hlZC5gKTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLnB1c2goY3JlYXRlRXZlbnRMb2cuYmluZCh0aGlzKShtc2cpKTtcblxuICBpZiAoIXRoaXMuX3Byb2Nlc3NpbmdRdWV1ZSkge1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcblxuICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25uZWN0aW9uT3Blbi5iaW5kKHRoaXMpKCk7XG4gIH1cblxuICB3aGlsZSAodGhpcy5fcXVldWVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIHNtYWxsIHdhaXQgdG8gYWxsb3cgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIgdG8gdGFrZSBhZmZlY3RcbiAgICBhd2FpdCB3YWl0KDEpO1xuXG4gICAgaWYgKHRoaXMuX3dhaXRUb1JldHJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXZlIGJlZW4gcmF0ZSBsaW1pdGVkIHNvIHdhaXRcbiAgICAgIGF3YWl0IHRoaXMuX3dhaXRUb1JldHJ5O1xuICAgICAgdGhpcy5fd2FpdFRvUmV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG1zZyA9IHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLnNoaWZ0KCk7XG5cbiAgICBjb25zdCBkZWxheSA9IHRoaXMuX2xpbWl0UnVsZXMuZHVyYXRpb24gLyB0aGlzLl9saW1pdFJ1bGVzLnBvaW50cyAqIDEwMDA7XG4gICAgYXdhaXQgd2FpdChkZWxheSk7XG5cbiAgICB0aGlzLl9zb2NrZXQuc2VuZChtc2cpO1xuICB9XG5cbiAgdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gIHRoaXMuX2xpbWl0UnVsZXMgPSBERUZBVUxUX1JBVEVfTElNSVRfUlVMRVM7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobXNnKSB7XG4gIGNvbnN0IHtcbiAgICBzdGF0dXMsXG4gICAgcmVhc29uLFxuICAgIGV2ZW50LFxuICAgIGNvbm5lY3Rpb25JZCxcbiAgICByZXRyeU1zLFxuICAgIGxpbWl0UnVsZXMsXG4gICAgYmxvY2tlZE1zZ1xuICB9ID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cbiAgaWYgKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX3N0b3JhZ2VLZXksIGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICB9IC8vIGhhbmRsZSBhbnkgZXJyb3JzIGZyb20gdGhlIHNlcnZlclxuXG5cbiAgaWYgKHN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ3JhdGVsaW1pdCcpKSB7XG4gICAgICB0aGlzLl93YWl0VG9SZXRyeSA9IHdhaXQocmV0cnlNcyk7XG4gICAgICB0aGlzLl9saW1pdFJ1bGVzID0gbGltaXRSdWxlczsgLy8gYWRkIGJsb2NrZWQgbXNnIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcblxuICAgICAgYmxvY2tlZE1zZyAmJiB0aGlzLl9xdWV1ZWRNZXNzYWdlcy51bnNoaWZ0KGJsb2NrZWRNc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEFQSSBrZXknKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25ldHdvcmsgbm90IHN1cHBvcnRlZCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbWF4aW11bSBhbGxvd2VkIGFtb3VudCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgYml0Y29pbiB0eGlkIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgdHhpZCcpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC50cmFuc2FjdGlvbi50eGlkfSBpcyBhbiBpbnZhbGlkIHR4aWRgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGV2ZW50LnRyYW5zYWN0aW9uLnR4aWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gdHJhbnNhY3Rpb24gaGFzaCBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGhhc2gnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQudHJhbnNhY3Rpb24uaGFzaH0gaXMgYW4gaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoYDtcblxuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBldmVudC50cmFuc2FjdGlvbi5oYXNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGdlbmVyYWwgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGFkZHJlc3MnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQuYWNjb3VudC5hZGRyZXNzfSBpcyBhbiBpbnZhbGlkIGFkZHJlc3NgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGJpdGNvaW4gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBCaXRjb2luJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBFdGhlcmV1bScpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gdGhyb3cgZXJyb3IgdGhhdCBjb21lcyBiYWNrIGZyb20gdGhlIHNlcnZlciB3aXRob3V0IGZvcm1hdHRpbmcgdGhlIG1lc3NhZ2VcblxuXG4gICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudCAmJiBldmVudC50cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgY29udHJhY3RDYWxsXG4gICAgfSA9IGV2ZW50OyAvLyBmbGF0dGVuIGluIHRvIG9uZSBvYmplY3RcblxuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8geyAuLi50cmFuc2FjdGlvbixcbiAgICAgIGV2ZW50Q29kZSxcbiAgICAgIGNvbnRyYWN0Q2FsbFxuICAgIH0gOiB7IC4uLnRyYW5zYWN0aW9uLFxuICAgICAgZXZlbnRDb2RlXG4gICAgfTsgLy8gaWdub3JlIHNlcnZlciBlY2hvIGFuZCB1bnN1YnNjcmliZSBtZXNzYWdlc1xuXG4gICAgaWYgKHNlcnZlckVjaG8oZXZlbnRDb2RlKSB8fCB0cmFuc2FjdGlvbi5zdGF0dXMgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBoYW5kbGUgY2hhbmdlIG9mIGhhc2ggaW4gc3BlZWR1cCBhbmQgY2FuY2VsIGV2ZW50c1xuXG5cbiAgICBpZiAoZXZlbnRDb2RlID09PSAndHhTcGVlZFVwJyB8fCBldmVudENvZGUgPT09ICd0eENhbmNlbCcpIHtcbiAgICAgIHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLl93YXRjaGVkVHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB7XG4gICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbi5vcmlnaW5hbEhhc2gpIHtcbiAgICAgICAgICAvLyByZWFzc2lnbiBoYXNoIHBhcmFtZXRlciBpbiB0cmFuc2FjdGlvbiBxdWV1ZSB0byBuZXcgaGFzaCBvciB0eGlkXG4gICAgICAgICAgdHguaGFzaCA9IHRyYW5zYWN0aW9uLmhhc2ggfHwgdHJhbnNhY3Rpb24udHhpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHdhdGNoZWRBZGRyZXNzID0gdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3MgJiYgdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSA6IHRyYW5zYWN0aW9uLndhdGNoZWRBZGRyZXNzO1xuXG4gICAgaWYgKHdhdGNoZWRBZGRyZXNzKSB7XG4gICAgICBjb25zdCBhY2NvdW50T2JqID0gdGhpcy5fd2F0Y2hlZEFjY291bnRzLmZpbmQoYWMgPT4gYWMuYWRkcmVzcyA9PT0gd2F0Y2hlZEFkZHJlc3MpO1xuXG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gYWNjb3VudE9iaiA/IGxhc3QoYWNjb3VudE9iai5lbWl0dGVycy5tYXAoZW1pdHRlciA9PiBlbWl0dGVyLmVtaXQobmV3U3RhdGUpKSkgOiBmYWxzZTtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbk9iaiA9IHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMuZmluZCh0eCA9PiB0eC5oYXNoID09PSB0cmFuc2FjdGlvbi5oYXNoIHx8IHRyYW5zYWN0aW9uLnR4aWQpO1xuXG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gdHJhbnNhY3Rpb25PYmogJiYgdHJhbnNhY3Rpb25PYmouZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudExvZyhtc2cpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB0aW1lU3RhbXA6IG5ldyBEYXRlKCksXG4gICAgZGFwcElkOiB0aGlzLl9kYXBwSWQsXG4gICAgdmVyc2lvbixcbiAgICBibG9ja2NoYWluOiB7XG4gICAgICBzeXN0ZW06IHRoaXMuX3N5c3RlbSxcbiAgICAgIG5ldHdvcms6IG5ldHdvcmtOYW1lKHRoaXMuX3N5c3RlbSwgdGhpcy5fbmV0d29ya0lkKSB8fCAnbG9jYWwnXG4gICAgfSxcbiAgICAuLi5tc2dcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JDb25uZWN0aW9uT3BlbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICBvcHRpb25hbCxcbiAgICBjdXN0b21WYWxpZGF0aW9uXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghb3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgaXMgcmVxdWlyZWRgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlID09PSAnYXJyYXknID8gQXJyYXkuaXNBcnJheSh0eXBlKSA6IHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgb2YgdHlwZTogJHt0eXBlfSwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgdmFsdWV9IGZyb20gdmFsdWU6ICR7dmFsdWV9YCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBjdXN0b21WYWxpZGF0aW9uICYmICFjdXN0b21WYWxpZGF0aW9uKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIFwiJHtuYW1lfVwiYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc2RrIG9wdGlvbnMnLFxuICAgIHZhbHVlOiBvcHRpb25zLFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuICBjb25zdCB7XG4gICAgZGFwcElkLFxuICAgIHN5c3RlbSxcbiAgICBuYW1lLFxuICAgIG5ldHdvcmtJZCxcbiAgICB0cmFuc2FjdGlvbkhhbmRsZXJzLFxuICAgIGFwaVVybCxcbiAgICB3cyxcbiAgICBvbm9wZW4sXG4gICAgb25kb3duLFxuICAgIG9ucmVvcGVuLFxuICAgIG9uZXJyb3IsXG4gICAgb25jbG9zZSxcbiAgICAuLi5vdGhlclBhcmFtc1xuICB9ID0gb3B0aW9ucztcbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydkYXBwSWQnLCAnc3lzdGVtJywgJ25hbWUnLCAnbmV0d29ya0lkJywgJ3RyYW5zYWN0aW9uSGFuZGxlcnMnLCAnYXBpVXJsJywgJ3dzJywgJ29ub3BlbicsICdvbmRvd24nLCAnb25yZW9wZW4nLCAnb25lcnJvcicsICdvbmNsb3NlJ10sICdJbml0aWFsaXphdGlvbiBPcHRpb25zJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcHBJZCcsXG4gICAgdmFsdWU6IGRhcHBJZCxcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc3lzdGVtJyxcbiAgICB2YWx1ZTogc3lzdGVtLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGN1c3RvbVZhbGlkYXRpb246IHZhbGlkU3lzdGVtXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduYW1lJyxcbiAgICB2YWx1ZTogbmFtZSxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29ya0lkJyxcbiAgICB2YWx1ZTogbmV0d29ya0lkLFxuICAgIHR5cGU6ICdudW1iZXInXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd0cmFuc2FjdGlvbkhhbmRsZXInLFxuICAgIHZhbHVlOiB0cmFuc2FjdGlvbkhhbmRsZXJzLFxuICAgIHR5cGU6ICdhcnJheScsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHRyYW5zYWN0aW9uSGFuZGxlcnMpIHtcbiAgICB0cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ3RyYW5zYWN0aW9uSGFuZGxlcicsXG4gICAgICB2YWx1ZTogaGFuZGxlcixcbiAgICAgIHR5cGU6ICdmdW5jdGlvbidcbiAgICB9KSk7XG4gIH1cblxuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhcGlVcmwnLFxuICAgIHZhbHVlOiBhcGlVcmwsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dzJyxcbiAgICB2YWx1ZTogd3MsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25vcGVuJyxcbiAgICB2YWx1ZTogb25vcGVuLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uZG93bicsXG4gICAgdmFsdWU6IG9uZG93bixcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbnJlb3BlbicsXG4gICAgdmFsdWU6IG9ucmVvcGVuLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uZXJyb3InLFxuICAgIHZhbHVlOiBvbmVycm9yLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uY2xvc2UnLFxuICAgIHZhbHVlOiBvbmNsb3NlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkU3lzdGVtKHN5c3RlbSkge1xuICByZXR1cm4gISFuZXR3b3Jrc1tzeXN0ZW1dO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1zKHBhcmFtcywgdmFsaWRQYXJhbXMsIGZ1bmN0aW9uTmFtZSkge1xuICBjb25zdCBpbnZhbGlkID0gT2JqZWN0LmtleXMocGFyYW1zKTtcblxuICBpZiAoaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ludmFsaWRbMF19IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciBmb3IgJHtmdW5jdGlvbk5hbWV9LCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbGlkIHBhcmFtZXRlcnM6ICR7dmFsaWRQYXJhbXMuam9pbignLCAnKX1gKTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX05BTUUgPSAndW5rbm93bic7XG5jb25zdCBERUZBVUxUX1NZU1RFTSA9ICdldGhlcmV1bSc7XG5cbmNsYXNzIEJsb2NrbmF0aXZlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXBwSWQsXG4gICAgICBzeXN0ZW0gPSBERUZBVUxUX1NZU1RFTSxcbiAgICAgIG5hbWUgPSBERUZBVUxUX05BTUUsXG4gICAgICBuZXR3b3JrSWQsXG4gICAgICB0cmFuc2FjdGlvbkhhbmRsZXJzID0gW10sXG4gICAgICBhcGlVcmwsXG4gICAgICB3cyxcbiAgICAgIG9ub3BlbixcbiAgICAgIG9uZG93bixcbiAgICAgIG9ucmVvcGVuLFxuICAgICAgb25lcnJvcixcbiAgICAgIG9uY2xvc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzb2NrZXQgPSBuZXcgU3R1cmR5V2ViU29ja2V0KGFwaVVybCB8fCAnd3NzOi8vYXBpLmJsb2NrbmF0aXZlLmNvbS92MCcsIHdzID8ge1xuICAgICAgd3NDb25zdHJ1Y3Rvcjogd3NcbiAgICB9IDoge30pO1xuICAgIHNvY2tldC5vbm9wZW4gPSBvbk9wZW4uYmluZCh0aGlzLCBvbm9wZW4pO1xuICAgIHNvY2tldC5vbmRvd24gPSBvbkRvd24uYmluZCh0aGlzLCBvbmRvd24pO1xuICAgIHNvY2tldC5vbnJlb3BlbiA9IG9uUmVvcGVuLmJpbmQodGhpcywgb25yZW9wZW4pO1xuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICBzb2NrZXQub25lcnJvciA9IGVycm9yID0+IG9uZXJyb3IgJiYgb25lcnJvcih7XG4gICAgICBtZXNzYWdlOiAnVGhlcmUgd2FzIGEgV2ViU29ja2V0IGVycm9yJyxcbiAgICAgIGVycm9yXG4gICAgfSk7XG5cbiAgICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVvdXQpO1xuICAgICAgb25jbG9zZSAmJiBvbmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBDcnlwdG9Fcy5TSEExKGAke2RhcHBJZH0gLSAke25hbWV9YCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgdGhpcy5fc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gc3RvcmVkQ29ubmVjdGlvbklkIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kYXBwSWQgPSBkYXBwSWQ7XG4gICAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuICAgIHRoaXMuX25ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzID0gdHJhbnNhY3Rpb25IYW5kbGVycztcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UgPSBzZW5kTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICB0aGlzLl93YXRjaGVkQWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLl9waW5nVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9vbmVycm9yID0gb25lcnJvcjtcbiAgICB0aGlzLl9xdWV1ZWRNZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMuX2xpbWl0UnVsZXMgPSBERUZBVUxUX1JBVEVfTElNSVRfUlVMRVM7XG4gICAgdGhpcy5fd2FpdFRvUmV0cnkgPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3NpbmdRdWV1ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IHByb2Nlc3NRdWV1ZS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3NvY2tldC53cy5vbikge1xuICAgICAgdGhpcy5faGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXQpO1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIHRlcm1pbmF0ZSBjb25uZWN0aW9uIGlmIHdlIGhhdmVuJ3QgaGVhcmQgdGhlIHNlcnZlciBwaW5nIGFmdGVyIHNlcnZlciB0aW1lb3V0IHBsdXMgY29uc2VydmF0aXZlIGxhdGVuY3kgZGVsYXlcbiAgICAgICAgICAvLyBTdHVyZHkgV2Vic29ja2V0IHdpbGwgaGFuZGxlIHRoZSBuZXcgY29ubmVjdGlvbiBsb2dpY1xuICAgICAgICAgIHRoaXMuX3NvY2tldC53cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfSwgMzAwMDAgKyAxMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NvY2tldC53cy5vbigncGluZycsICgpID0+IHtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0ICYmIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICAgICAgfSk7XG4gICAgfSAvLyBwdWJsaWMgQVBJXG5cblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NvY2tldC5jbG9zZSgpO1xuXG4gICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlOyAvLyBjYWxsIG9uY2xvc2UgbWFudWFsbHkgaGVyZSBhcyBTdHVyZHlXZWJTb2NrZXQgZG9lc24ndCBjdXJyZW50bHkgd29yayBhcyBleHBlY3RlZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RwaGlsaXBzb24vc3R1cmR5LXdlYnNvY2tldC9pc3N1ZXMvNVxuXG4gICAgICB0aGlzLl9zb2NrZXQub25jbG9zZSgpO1xuICAgIH07XG4gIH1cblxufVxuXG5mdW5jdGlvbiBvbk9wZW4oaGFuZGxlcikge1xuICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICBjb25zdCBtc2cgPSB7XG4gICAgY2F0ZWdvcnlDb2RlOiAnaW5pdGlhbGl6ZScsXG4gICAgZXZlbnRDb2RlOiAnY2hlY2tEYXBwSWQnLFxuICAgIGNvbm5lY3Rpb25JZDogdGhpcy5fY29ubmVjdGlvbklkXG4gIH07IC8vIHNlbmQgdGhpcyBtZXNzYWdlIGRpcmVjdGx5IHJhdGhlciB0aGFuIHB1dCBpbiBxdWV1ZVxuXG4gIHRoaXMuX3NvY2tldC5zZW5kKGNyZWF0ZUV2ZW50TG9nLmJpbmQodGhpcykobXNnKSk7XG5cbiAgdGhpcy5faGVhcnRiZWF0ICYmIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICBoYW5kbGVyICYmIGhhbmRsZXIoKTtcbn1cblxuZnVuY3Rpb24gb25Eb3duKGhhbmRsZXIsIGNsb3NlRXZlbnQpIHtcbiAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyKGNsb3NlRXZlbnQpO1xuICB9XG5cbiAgdGhpcy5fcGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX3BpbmdUaW1lb3V0KTtcbn1cblxuZnVuY3Rpb24gb25SZW9wZW4oaGFuZGxlcikge1xuICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICBjb25zdCBtc2cgPSB7XG4gICAgY2F0ZWdvcnlDb2RlOiAnaW5pdGlhbGl6ZScsXG4gICAgZXZlbnRDb2RlOiAnY2hlY2tEYXBwSWQnLFxuICAgIGNvbm5lY3Rpb25JZDogdGhpcy5fY29ubmVjdGlvbklkXG4gIH07XG5cbiAgdGhpcy5fc29ja2V0LnNlbmQoY3JlYXRlRXZlbnRMb2cuYmluZCh0aGlzKShtc2cpKTsgLy8gcmUtcmVnaXN0ZXIgYWxsIGFjY291bnRzIHRvIGJlIHdhdGNoZWQgYnkgc2VydmVyIHVwb25cbiAgLy8gcmUtY29ubmVjdGlvbiBhcyB0aGV5IGRvbid0IGdldCB0cmFuc2ZlcnJlZCBvdmVyIGF1dG9tYXRpY2FsbHlcbiAgLy8gdG8gdGhlIG5ldyBjb25uZWN0aW9uIGxpa2UgdHggaGFzaGVzIGRvXG5cblxuICB0aGlzLl93YXRjaGVkQWNjb3VudHMuZm9yRWFjaChhY2NvdW50ID0+IHtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBldmVudENvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgICBjYXRlZ29yeUNvZGU6ICd3YXRjaCcsXG4gICAgICBhY2NvdW50OiB7XG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb2NrZXQud3Mub24pIHtcbiAgICAvLyBuZWVkIHRvIHJlLXJlZ2lzdGVyIHBpbmcgZXZlbnQgc2luY2UgbmV3IGNvbm5lY3Rpb25cbiAgICB0aGlzLl9zb2NrZXQud3Mub24oJ3BpbmcnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9oZWFydGJlYXQoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCbG9ja25hdGl2ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bnc-sdk/dist/esm/index.js\n");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jvd3Nlci9lczUuanM/MzM3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixTQUEyRyxDQUFDLGtCQUFrQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGtCQUFrQixFQUFFLG1CQUFtQixhQUFhLGlDQUFpQyx5QkFBeUIsY0FBYyxxQ0FBcUMsaUJBQWlCLCtCQUErQixnQ0FBZ0MsaUJBQWlCLCtCQUErQix1Q0FBdUMsc0JBQXNCLHFDQUFxQyxVQUFVLG9CQUFvQixvQkFBb0IsMEJBQTBCLHdCQUF3QiwwQkFBMEIsMkJBQTJCLHVCQUF1Qix1QkFBdUIseUJBQXlCLHlCQUF5QixnQkFBZ0IsbUNBQW1DLGdEQUFnRCx5QkFBeUIsR0FBRyxvQ0FBb0MsdUJBQXVCLDRCQUE0QixvQkFBb0IsNkJBQTZCLHlCQUF5Qix5QkFBeUIsMkJBQTJCLHVCQUF1Qiw0QkFBNEIsdUJBQXVCLHlCQUF5QixnQkFBZ0IscUNBQXFDLGdEQUFnRCx5QkFBeUIsR0FBRyx3WUFBd1ksbUNBQW1DLDJCQUEyQixtQ0FBbUMsbUJBQW1CLHlHQUF5RywrREFBK0QsdUNBQXVDLDBDQUEwQyxhQUFhLEdBQUcsZ0NBQWdDLEtBQUssRUFBRSw0QkFBNEIsc0JBQXNCLGtCQUFrQixLQUFLLGtDQUFrQyxxQkFBcUIsV0FBVyw0REFBNEQsUUFBUSxXQUFXLHFCQUFxQixTQUFTLHNCQUFzQixRQUFRLDhEQUE4RCxtQkFBbUIsSUFBSSxNQUFNLFdBQVcsb0JB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RSw4Q0FBOEMsT0FBTyx5QkFBeUIsMERBQTBELDJCQUEyQixFQUFFLGlDQUFpQyxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jvd3Nlci9lczUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmJvd3Nlcj10KCk6ZS5ib3dzZXI9dCgpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgaT10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBpIGluIGUpci5kKG4saSxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTkwKX0oezE3OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj1yKDE4KSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5nZXRGaXJzdE1hdGNoPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5tYXRjaChlKTtyZXR1cm4gciYmci5sZW5ndGg+MCYmclsxXXx8XCJcIn0sZS5nZXRTZWNvbmRNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjEmJnJbMl18fFwiXCJ9LGUubWF0Y2hBbmRSZXR1cm5Db25zdD1mdW5jdGlvbihlLHQscil7aWYoZS50ZXN0KHQpKXJldHVybiByfSxlLmdldFdpbmRvd3NWZXJzaW9uTmFtZT1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZVwiTlRcIjpyZXR1cm5cIk5UXCI7Y2FzZVwiWFBcIjpyZXR1cm5cIlhQXCI7Y2FzZVwiTlQgNS4wXCI6cmV0dXJuXCIyMDAwXCI7Y2FzZVwiTlQgNS4xXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMlwiOnJldHVyblwiMjAwM1wiO2Nhc2VcIk5UIDYuMFwiOnJldHVyblwiVmlzdGFcIjtjYXNlXCJOVCA2LjFcIjpyZXR1cm5cIjdcIjtjYXNlXCJOVCA2LjJcIjpyZXR1cm5cIjhcIjtjYXNlXCJOVCA2LjNcIjpyZXR1cm5cIjguMVwiO2Nhc2VcIk5UIDEwLjBcIjpyZXR1cm5cIjEwXCI7ZGVmYXVsdDpyZXR1cm59fSxlLmdldE1hY09TVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIi5cIikuc3BsaWNlKDAsMikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl8fDB9KSk7aWYodC5wdXNoKDApLDEwPT09dFswXSlzd2l0Y2godFsxXSl7Y2FzZSA1OnJldHVyblwiTGVvcGFyZFwiO2Nhc2UgNjpyZXR1cm5cIlNub3cgTGVvcGFyZFwiO2Nhc2UgNzpyZXR1cm5cIkxpb25cIjtjYXNlIDg6cmV0dXJuXCJNb3VudGFpbiBMaW9uXCI7Y2FzZSA5OnJldHVyblwiTWF2ZXJpY2tzXCI7Y2FzZSAxMDpyZXR1cm5cIllvc2VtaXRlXCI7Y2FzZSAxMTpyZXR1cm5cIkVsIENhcGl0YW5cIjtjYXNlIDEyOnJldHVyblwiU2llcnJhXCI7Y2FzZSAxMzpyZXR1cm5cIkhpZ2ggU2llcnJhXCI7Y2FzZSAxNDpyZXR1cm5cIk1vamF2ZVwiO2Nhc2UgMTU6cmV0dXJuXCJDYXRhbGluYVwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRBbmRyb2lkVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIi5cIikuc3BsaWNlKDAsMikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl8fDB9KSk7aWYodC5wdXNoKDApLCEoMT09PXRbMF0mJnRbMV08NSkpcmV0dXJuIDE9PT10WzBdJiZ0WzFdPDY/XCJDdXBjYWtlXCI6MT09PXRbMF0mJnRbMV0+PTY/XCJEb251dFwiOjI9PT10WzBdJiZ0WzFdPDI/XCJFY2xhaXJcIjoyPT09dFswXSYmMj09PXRbMV0/XCJGcm95b1wiOjI9PT10WzBdJiZ0WzFdPjI/XCJHaW5nZXJicmVhZFwiOjM9PT10WzBdP1wiSG9uZXljb21iXCI6ND09PXRbMF0mJnRbMV08MT9cIkljZSBDcmVhbSBTYW5kd2ljaFwiOjQ9PT10WzBdJiZ0WzFdPDQ/XCJKZWxseSBCZWFuXCI6ND09PXRbMF0mJnRbMV0+PTQ/XCJLaXRLYXRcIjo1PT09dFswXT9cIkxvbGxpcG9wXCI6Nj09PXRbMF0/XCJNYXJzaG1hbGxvd1wiOjc9PT10WzBdP1wiTm91Z2F0XCI6OD09PXRbMF0/XCJPcmVvXCI6OT09PXRbMF0/XCJQaWVcIjp2b2lkIDB9LGUuZ2V0VmVyc2lvblByZWNpc2lvbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIi5cIikubGVuZ3RofSxlLmNvbXBhcmVWZXJzaW9ucz1mdW5jdGlvbih0LHIsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciBpPWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxzPWUuZ2V0VmVyc2lvblByZWNpc2lvbihyKSxhPU1hdGgubWF4KGkscyksbz0wLHU9ZS5tYXAoW3Qscl0sKGZ1bmN0aW9uKHQpe3ZhciByPWEtZS5nZXRWZXJzaW9uUHJlY2lzaW9uKHQpLG49dCtuZXcgQXJyYXkocisxKS5qb2luKFwiLjBcIik7cmV0dXJuIGUubWFwKG4uc3BsaXQoXCIuXCIpLChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEFycmF5KDIwLWUubGVuZ3RoKS5qb2luKFwiMFwiKStlfSkpLnJldmVyc2UoKX0pKTtmb3IobiYmKG89YS1NYXRoLm1pbihpLHMpKSxhLT0xO2E+PW87KXtpZih1WzBdW2FdPnVbMV1bYV0pcmV0dXJuIDE7aWYodVswXVthXT09PXVbMV1bYV0pe2lmKGE9PT1vKXJldHVybiAwO2EtPTF9ZWxzZSBpZih1WzBdW2FdPHVbMV1bYV0pcmV0dXJuLTF9fSxlLm1hcD1mdW5jdGlvbihlLHQpe3ZhciByLG49W107aWYoQXJyYXkucHJvdG90eXBlLm1hcClyZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGUsdCk7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrPTEpbi5wdXNoKHQoZVtyXSkpO3JldHVybiBufSxlLmZpbmQ9ZnVuY3Rpb24oZSx0KXt2YXIgcixuO2lmKEFycmF5LnByb3RvdHlwZS5maW5kKXJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUsdCk7Zm9yKHI9MCxuPWUubGVuZ3RoO3I8bjtyKz0xKXt2YXIgaT1lW3JdO2lmKHQoaSxyKSlyZXR1cm4gaX19LGUuYXNzaWduPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG49ZSxpPWFyZ3VtZW50cy5sZW5ndGgscz1uZXcgQXJyYXkoaT4xP2ktMTowKSxhPTE7YTxpO2ErKylzW2EtMV09YXJndW1lbnRzW2FdO2lmKE9iamVjdC5hc3NpZ24pcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LFtlXS5jb25jYXQocykpO3ZhciBvPWZ1bmN0aW9uKCl7dmFyIGU9c1t0XTtcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUmJk9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09ZVt0XX0pKX07Zm9yKHQ9MCxyPXMubGVuZ3RoO3Q8cjt0Kz0xKW8oKTtyZXR1cm4gZX0sZS5nZXRCcm93c2VyQWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG4uQlJPV1NFUl9BTElBU0VTX01BUFtlXX0sZS5nZXRCcm93c2VyVHlwZUJ5QWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG4uQlJPV1NFUl9NQVBbZV18fFwiXCJ9LGV9KCk7dC5kZWZhdWx0PWksZS5leHBvcnRzPXQuZGVmYXVsdH0sMTg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LkVOR0lORV9NQVA9dC5PU19NQVA9dC5QTEFURk9STVNfTUFQPXQuQlJPV1NFUl9NQVA9dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXZvaWQgMDt0LkJST1dTRVJfQUxJQVNFU19NQVA9e1wiQW1hem9uIFNpbGtcIjpcImFtYXpvbl9zaWxrXCIsXCJBbmRyb2lkIEJyb3dzZXJcIjpcImFuZHJvaWRcIixCYWRhOlwiYmFkYVwiLEJsYWNrQmVycnk6XCJibGFja2JlcnJ5XCIsQ2hyb21lOlwiY2hyb21lXCIsQ2hyb21pdW06XCJjaHJvbWl1bVwiLEVsZWN0cm9uOlwiZWxlY3Ryb25cIixFcGlwaGFueTpcImVwaXBoYW55XCIsRmlyZWZveDpcImZpcmVmb3hcIixGb2N1czpcImZvY3VzXCIsR2VuZXJpYzpcImdlbmVyaWNcIixcIkdvb2dsZSBTZWFyY2hcIjpcImdvb2dsZV9zZWFyY2hcIixHb29nbGVib3Q6XCJnb29nbGVib3RcIixcIkludGVybmV0IEV4cGxvcmVyXCI6XCJpZVwiLFwiSy1NZWxlb25cIjpcImtfbWVsZW9uXCIsTWF4dGhvbjpcIm1heHRob25cIixcIk1pY3Jvc29mdCBFZGdlXCI6XCJlZGdlXCIsXCJNWiBCcm93c2VyXCI6XCJtelwiLFwiTkFWRVIgV2hhbGUgQnJvd3NlclwiOlwibmF2ZXJcIixPcGVyYTpcIm9wZXJhXCIsXCJPcGVyYSBDb2FzdFwiOlwib3BlcmFfY29hc3RcIixQaGFudG9tSlM6XCJwaGFudG9tanNcIixQdWZmaW46XCJwdWZmaW5cIixRdXBaaWxsYTpcInF1cHppbGxhXCIsUVE6XCJxcVwiLFFRTGl0ZTpcInFxbGl0ZVwiLFNhZmFyaTpcInNhZmFyaVwiLFNhaWxmaXNoOlwic2FpbGZpc2hcIixcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIjpcInNhbXN1bmdfaW50ZXJuZXRcIixTZWFNb25rZXk6XCJzZWFtb25rZXlcIixTbGVpcG5pcjpcInNsZWlwbmlyXCIsU3dpbmc6XCJzd2luZ1wiLFRpemVuOlwidGl6ZW5cIixcIlVDIEJyb3dzZXJcIjpcInVjXCIsVml2YWxkaTpcInZpdmFsZGlcIixcIldlYk9TIEJyb3dzZXJcIjpcIndlYm9zXCIsV2VDaGF0Olwid2VjaGF0XCIsXCJZYW5kZXggQnJvd3NlclwiOlwieWFuZGV4XCIsUm9rdTpcInJva3VcIn07dC5CUk9XU0VSX01BUD17YW1hem9uX3NpbGs6XCJBbWF6b24gU2lsa1wiLGFuZHJvaWQ6XCJBbmRyb2lkIEJyb3dzZXJcIixiYWRhOlwiQmFkYVwiLGJsYWNrYmVycnk6XCJCbGFja0JlcnJ5XCIsY2hyb21lOlwiQ2hyb21lXCIsY2hyb21pdW06XCJDaHJvbWl1bVwiLGVsZWN0cm9uOlwiRWxlY3Ryb25cIixlcGlwaGFueTpcIkVwaXBoYW55XCIsZmlyZWZveDpcIkZpcmVmb3hcIixmb2N1czpcIkZvY3VzXCIsZ2VuZXJpYzpcIkdlbmVyaWNcIixnb29nbGVib3Q6XCJHb29nbGVib3RcIixnb29nbGVfc2VhcmNoOlwiR29vZ2xlIFNlYXJjaFwiLGllOlwiSW50ZXJuZXQgRXhwbG9yZXJcIixrX21lbGVvbjpcIkstTWVsZW9uXCIsbWF4dGhvbjpcIk1heHRob25cIixlZGdlOlwiTWljcm9zb2Z0IEVkZ2VcIixtejpcIk1aIEJyb3dzZXJcIixuYXZlcjpcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIixvcGVyYTpcIk9wZXJhXCIsb3BlcmFfY29hc3Q6XCJPcGVyYSBDb2FzdFwiLHBoYW50b21qczpcIlBoYW50b21KU1wiLHB1ZmZpbjpcIlB1ZmZpblwiLHF1cHppbGxhOlwiUXVwWmlsbGFcIixxcTpcIlFRIEJyb3dzZXJcIixxcWxpdGU6XCJRUSBCcm93c2VyIExpdGVcIixzYWZhcmk6XCJTYWZhcmlcIixzYWlsZmlzaDpcIlNhaWxmaXNoXCIsc2Ftc3VuZ19pbnRlcm5ldDpcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIixzZWFtb25rZXk6XCJTZWFNb25rZXlcIixzbGVpcG5pcjpcIlNsZWlwbmlyXCIsc3dpbmc6XCJTd2luZ1wiLHRpemVuOlwiVGl6ZW5cIix1YzpcIlVDIEJyb3dzZXJcIix2aXZhbGRpOlwiVml2YWxkaVwiLHdlYm9zOlwiV2ViT1MgQnJvd3NlclwiLHdlY2hhdDpcIldlQ2hhdFwiLHlhbmRleDpcIllhbmRleCBCcm93c2VyXCJ9O3QuUExBVEZPUk1TX01BUD17dGFibGV0OlwidGFibGV0XCIsbW9iaWxlOlwibW9iaWxlXCIsZGVza3RvcDpcImRlc2t0b3BcIix0djpcInR2XCJ9O3QuT1NfTUFQPXtXaW5kb3dzUGhvbmU6XCJXaW5kb3dzIFBob25lXCIsV2luZG93czpcIldpbmRvd3NcIixNYWNPUzpcIm1hY09TXCIsaU9TOlwiaU9TXCIsQW5kcm9pZDpcIkFuZHJvaWRcIixXZWJPUzpcIldlYk9TXCIsQmxhY2tCZXJyeTpcIkJsYWNrQmVycnlcIixCYWRhOlwiQmFkYVwiLFRpemVuOlwiVGl6ZW5cIixMaW51eDpcIkxpbnV4XCIsQ2hyb21lT1M6XCJDaHJvbWUgT1NcIixQbGF5U3RhdGlvbjQ6XCJQbGF5U3RhdGlvbiA0XCIsUm9rdTpcIlJva3VcIn07dC5FTkdJTkVfTUFQPXtFZGdlSFRNTDpcIkVkZ2VIVE1MXCIsQmxpbms6XCJCbGlua1wiLFRyaWRlbnQ6XCJUcmlkZW50XCIsUHJlc3RvOlwiUHJlc3RvXCIsR2Vja286XCJHZWNrb1wiLFdlYktpdDpcIldlYktpdFwifX0sOTA6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cig5MSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO2Z1bmN0aW9uIGEoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXZhciBvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe312YXIgdCxyLG47cmV0dXJuIGUuZ2V0UGFyc2VyPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBzaG91bGQgYmUgYSBzdHJpbmdcIik7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSx0KX0sZS5wYXJzZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGkuZGVmYXVsdChlKS5nZXRSZXN1bHQoKX0sdD1lLG49W3trZXk6XCJCUk9XU0VSX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLkJST1dTRVJfTUFQfX0se2tleTpcIkVOR0lORV9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5FTkdJTkVfTUFQfX0se2tleTpcIk9TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLk9TX01BUH19LHtrZXk6XCJQTEFURk9STVNfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuUExBVEZPUk1TX01BUH19XSwocj1udWxsKSYmYSh0LnByb3RvdHlwZSxyKSxuJiZhKHQsbiksZX0oKTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MTpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49dShyKDkyKSksaT11KHIoOTMpKSxzPXUocig5NCkpLGE9dShyKDk1KSksbz11KHIoMTcpKTtmdW5jdGlvbiB1KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtpZih2b2lkIDA9PT10JiYodD0hMSksbnVsbD09ZXx8XCJcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiVXNlckFnZW50IHBhcmFtZXRlciBjYW4ndCBiZSBlbXB0eVwiKTt0aGlzLl91YT1lLHRoaXMucGFyc2VkUmVzdWx0PXt9LCEwIT09dCYmdGhpcy5wYXJzZSgpfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmdldFVBPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VhfSx0LnRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVzdCh0aGlzLl91YSl9LHQucGFyc2VCcm93c2VyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKG4uZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyfSx0LmdldEJyb3dzZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj90aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyOnRoaXMucGFyc2VCcm93c2VyKCl9LHQuZ2V0QnJvd3Nlck5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/U3RyaW5nKHRoaXMuZ2V0QnJvd3NlcigpLm5hbWUpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dGhpcy5nZXRCcm93c2VyKCkubmFtZXx8XCJcIn0sdC5nZXRCcm93c2VyVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEJyb3dzZXIoKS52ZXJzaW9ufSx0LmdldE9TPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0Lm9zP3RoaXMucGFyc2VkUmVzdWx0Lm9zOnRoaXMucGFyc2VPUygpfSx0LnBhcnNlT1M9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0Lm9zPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKGkuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0Lm9zPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQub3N9LHQuZ2V0T1NOYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0T1MoKS5uYW1lO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQuZ2V0T1NWZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0T1MoKS52ZXJzaW9ufSx0LmdldFBsYXRmb3JtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtP3RoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtOnRoaXMucGFyc2VQbGF0Zm9ybSgpfSx0LmdldFBsYXRmb3JtVHlwZT1mdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHQ9dGhpcy5nZXRQbGF0Zm9ybSgpLnR5cGU7cmV0dXJuIGU/U3RyaW5nKHQpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dHx8XCJcIn0sdC5wYXJzZVBsYXRmb3JtPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChzLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtfSx0LmdldEVuZ2luZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU/dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lOnRoaXMucGFyc2VFbmdpbmUoKX0sdC5nZXRFbmdpbmVOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEVuZ2luZSgpLm5hbWUpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dGhpcy5nZXRFbmdpbmUoKS5uYW1lfHxcIlwifSx0LnBhcnNlRW5naW5lPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU9e307dmFyIHQ9by5kZWZhdWx0LmZpbmQoYS5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lfSx0LnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VCcm93c2VyKCksdGhpcy5wYXJzZU9TKCksdGhpcy5wYXJzZVBsYXRmb3JtKCksdGhpcy5wYXJzZUVuZ2luZSgpLHRoaXN9LHQuZ2V0UmVzdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdC5hc3NpZ24oe30sdGhpcy5wYXJzZWRSZXN1bHQpfSx0LnNhdGlzZmllcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9e30sbj0wLGk9e30scz0wO2lmKE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPWVbdF07XCJzdHJpbmdcIj09dHlwZW9mIGE/KGlbdF09YSxzKz0xKTpcIm9iamVjdFwiPT10eXBlb2YgYSYmKHJbdF09YSxuKz0xKX0pKSxuPjApe3ZhciBhPU9iamVjdC5rZXlzKHIpLHU9by5kZWZhdWx0LmZpbmQoYSwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXNPUyhlKX0pKTtpZih1KXt2YXIgZD10aGlzLnNhdGlzZmllcyhyW3VdKTtpZih2b2lkIDAhPT1kKXJldHVybiBkfXZhciBjPW8uZGVmYXVsdC5maW5kKGEsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzUGxhdGZvcm0oZSl9KSk7aWYoYyl7dmFyIGY9dGhpcy5zYXRpc2ZpZXMocltjXSk7aWYodm9pZCAwIT09ZilyZXR1cm4gZn19aWYocz4wKXt2YXIgbD1PYmplY3Qua2V5cyhpKSxoPW8uZGVmYXVsdC5maW5kKGwsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzQnJvd3NlcihlLCEwKX0pKTtpZih2b2lkIDAhPT1oKXJldHVybiB0aGlzLmNvbXBhcmVWZXJzaW9uKGlbaF0pfX0sdC5pc0Jyb3dzZXI9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMSk7dmFyIHI9dGhpcy5nZXRCcm93c2VyTmFtZSgpLnRvTG93ZXJDYXNlKCksbj1lLnRvTG93ZXJDYXNlKCksaT1vLmRlZmF1bHQuZ2V0QnJvd3NlclR5cGVCeUFsaWFzKG4pO3JldHVybiB0JiZpJiYobj1pLnRvTG93ZXJDYXNlKCkpLG49PT1yfSx0LmNvbXBhcmVWZXJzaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PVswXSxyPWUsbj0hMSxpPXRoaXMuZ2V0QnJvd3NlclZlcnNpb24oKTtpZihcInN0cmluZ1wiPT10eXBlb2YgaSlyZXR1cm5cIj5cIj09PWVbMF18fFwiPFwiPT09ZVswXT8ocj1lLnN1YnN0cigxKSxcIj1cIj09PWVbMV0/KG49ITAscj1lLnN1YnN0cigyKSk6dD1bXSxcIj5cIj09PWVbMF0/dC5wdXNoKDEpOnQucHVzaCgtMSkpOlwiPVwiPT09ZVswXT9yPWUuc3Vic3RyKDEpOlwiflwiPT09ZVswXSYmKG49ITAscj1lLnN1YnN0cigxKSksdC5pbmRleE9mKG8uZGVmYXVsdC5jb21wYXJlVmVyc2lvbnMoaSxyLG4pKT4tMX0sdC5pc09TPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldE9TTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pc1BsYXRmb3JtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldFBsYXRmb3JtVHlwZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pc0VuZ2luZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRFbmdpbmVOYW1lKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0aGlzLmlzQnJvd3NlcihlLHQpfHx0aGlzLmlzT1MoZSl8fHRoaXMuaXNQbGF0Zm9ybShlKX0sdC5zb21lPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHZvaWQgMD09PWUmJihlPVtdKSxlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzKGUpfSkpfSxlfSgpO3QuZGVmYXVsdD1kLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dmFyIHM9L3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksYT1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGVib3RcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3BlcmEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcGVyYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3ByXFwvfG9waW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHMvXShcXFMrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1NhbXN1bmdCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpTYW1zdW5nQnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvV2hhbGUvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OndoYWxlKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01aQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1aIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TVpCcm93c2VyKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZvY3VzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRm9jdXNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc3dpbmcvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTd2luZ1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpzd2luZylbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jb2FzdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhIENvYXN0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcHRcXC9cXGQrKD86Lj9fP1xcZCspKy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhIFRvdWNoXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsveWFicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiWWFuZGV4IEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86eWFicm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy91Y2Jyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJVQyBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTWF4dGhvbnxteGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1heHRob25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TWF4dGhvbnxteGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZXBpcGhhbnkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFcGlwaGFueVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplcGlwaGFueSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcHVmZmluL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUHVmZmluXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2xlaXBuaXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTbGVpcG5pclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpzbGVpcG5pcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvay1tZWxlb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJLLU1lbGVvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzprLW1lbGVvbilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvbWljcm9tZXNzZW5nZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJXZUNoYXRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86bWljcm9tZXNzZW5nZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3FxYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTovcXFicm93c2VybGl0ZS9pLnRlc3QoZSk/XCJRUSBCcm93c2VyIExpdGVcIjpcIlFRIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXFicm93c2VybGl0ZXxxcWJyb3dzZXIpWy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21zaWV8dHJpZGVudC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkludGVybmV0IEV4cGxvcmVyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvXFxzZWRnXFwvL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxzZWRnXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VkZyhbZWFdfGlvcykvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaWNyb3NvZnQgRWRnZVwifSxyPWkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCgvZWRnKFtlYV18aW9zKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy92aXZhbGRpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVml2YWxkaVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NlYW1vbmtleS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNlYU1vbmtleVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2FpbGZpc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYWlsZmlzaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zYWlsZmlzaFxccz9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NpbGsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJBbWF6b24gU2lsa1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3BoYW50b20vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQaGFudG9tSlNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsaW1lcmpzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xpbWVySlNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQmxhY2tCZXJyeVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcZF0rXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLyh3ZWJ8aHB3KVtvMF1zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2ViT1MgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93KD86ZWIpP1tvMF1zYnJvd3NlclxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9iYWRhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQmFkYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9kb2xmaW5cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdGl6ZW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJUaXplblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp0aXplblxccz8pP2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcXVwemlsbGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJRdXBaaWxsYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJGaXJlZm94XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lbGVjdHJvbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkVsZWN0cm9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmVsZWN0cm9uKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NaXVpQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pdWlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TWl1aUJyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9taXVtL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21pdW1cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9tZXxjcmlvc3xjcm1vL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21lXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9HU0EvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGUgU2VhcmNoXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OkdTQSlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PSFlLnRlc3QoL2xpa2UgYW5kcm9pZC9pKSxyPWUudGVzdCgvYW5kcm9pZC9pKTtyZXR1cm4gdCYmcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJBbmRyb2lkIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3BsYXlzdGF0aW9uIDQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQbGF5U3RhdGlvbiA0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zYWZhcml8YXBwbGV3ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYWZhcmlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLy4qL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PS0xIT09ZS5zZWFyY2goXCJcXFxcKFwiKT8vXiguKilcXC8oLiopWyBcXHRdXFwoKC4qKS86L14oLiopXFwvKC4qKSAvO3JldHVybntuYW1lOmkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHQsZSksdmVyc2lvbjppLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2godCxlKX19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpbL1Jva3VcXC9EVlAvXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvUm9rdVxcL0RWUC0oXFxkK1xcLlxcZCspL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuUm9rdSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzIHBob25lL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXHM/KFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3NQaG9uZSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzIC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvV2luZG93cyAoKE5UfFhQKSggXFxkXFxkPy5cXGQpPykvaSxlKSxyPWkuZGVmYXVsdC5nZXRXaW5kb3dzVmVyc2lvbk5hbWUodCk7cmV0dXJue25hbWU6cy5PU19NQVAuV2luZG93cyx2ZXJzaW9uOnQsdmVyc2lvbk5hbWU6cn19fSx7dGVzdDpbL01hY2ludG9zaCguKj8pIEZ4aU9TKC4qPylcXC8vXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLk9TX01BUC5pT1N9LHI9aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKC8oVmVyc2lvblxcLykoXFxkW1xcZC5dKykvLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21hY2ludG9zaC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvbWFjIG9zIHggKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpLnJlcGxhY2UoL1tfXFxzXS9nLFwiLlwiKSxyPWkuZGVmYXVsdC5nZXRNYWNPU1ZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuTWFjT1MsdmVyc2lvbjp0fTtyZXR1cm4gciYmKG4udmVyc2lvbk5hbWU9ciksbn19LHt0ZXN0OlsvKGlwb2R8aXBob25lfGlwYWQpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIik7cmV0dXJue25hbWU6cy5PU19NQVAuaU9TLHZlcnNpb246dH19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD0hZS50ZXN0KC9saWtlIGFuZHJvaWQvaSkscj1lLnRlc3QoL2FuZHJvaWQvaSk7cmV0dXJuIHQmJnJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9hbmRyb2lkW1xccy8tXShcXGQrKFxcLlxcZCspKikvaSxlKSxyPWkuZGVmYXVsdC5nZXRBbmRyb2lkVmVyc2lvbk5hbWUodCksbj17bmFtZTpzLk9TX01BUC5BbmRyb2lkLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyh3ZWJ8aHB3KVtvMF1zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KVtvMF1zXFwvKFxcZCsoXFwuXFxkKykqKS9pLGUpLHI9e25hbWU6cy5PU19NQVAuV2ViT1N9O3JldHVybiB0JiZ0Lmxlbmd0aCYmKHIudmVyc2lvbj10KSxyfX0se3Rlc3Q6Wy9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLC9yaW1cXHN0YWJsZXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3JpbVxcc3RhYmxldFxcc29zXFxzKFxcZCsoXFwuXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVxcZCtcXC8oXFxkKyhbX1xcc11cXGQrKSopL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9cXGJiYihcXGQrKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLkJsYWNrQmVycnksdmVyc2lvbjp0fX19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CYWRhLHZlcnNpb246dH19fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC90aXplblsvXFxzXShcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5UaXplbix2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy9saW51eC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkxpbnV4fX19LHt0ZXN0OlsvQ3JPUy9dLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5PU19NQVAuQ2hyb21lT1N9fX0se3Rlc3Q6Wy9QbGF5U3RhdGlvbiA0L10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1BsYXlTdGF0aW9uIDRbL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuUGxheVN0YXRpb240LHZlcnNpb246dH19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTQ6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpbL2dvb2dsZWJvdC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOlwiYm90XCIsdmVuZG9yOlwiR29vZ2xlXCJ9fX0se3Rlc3Q6Wy9odWF3ZWkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyhjYW4tbDAxKS9pLGUpJiZcIk5vdmFcIixyPXt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiSHVhd2VpXCJ9O3JldHVybiB0JiYoci5tb2RlbD10KSxyfX0se3Rlc3Q6Wy9uZXh1c1xccyooPzo3fDh8OXwxMCkuKi9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiTmV4dXNcIn19fSx7dGVzdDpbL2lwYWQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6XCJpUGFkXCJ9fX0se3Rlc3Q6Wy9NYWNpbnRvc2goLio/KSBGeGlPUyguKj8pXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6XCJpUGFkXCJ9fX0se3Rlc3Q6Wy9rZnR0IGJ1aWxkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIixtb2RlbDpcIktpbmRsZSBGaXJlIEhEIDdcIn19fSx7dGVzdDpbL3NpbGsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFtYXpvblwifX19LHt0ZXN0OlsvdGFibGV0KD8hIHBjKS9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50ZXN0KC9pcG9kfGlwaG9uZS9pKSxyPWUudGVzdCgvbGlrZSAoaXBvZHxpcGhvbmUpL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZSkvaSxlKTtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6dH19fSx7dGVzdDpbL25leHVzXFxzKlswLTZdLiovaSwvZ2FsYXh5IG5leHVzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJOZXh1c1wifX19LHt0ZXN0OlsvW14tXW1vYmkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmxhY2tiZXJyeVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJCbGFja0JlcnJ5XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJiYWRhXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwid2luZG93cyBwaG9uZVwiPT09ZS5nZXRCcm93c2VyTmFtZSgpfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTWljcm9zb2Z0XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9TnVtYmVyKFN0cmluZyhlLmdldE9TVmVyc2lvbigpKS5zcGxpdChcIi5cIilbMF0pO3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApJiZ0Pj0zfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJhbmRyb2lkXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1hY29zXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3AsdmVuZG9yOlwiQXBwbGVcIn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3NcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImxpbnV4XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJwbGF5c3RhdGlvbiA0XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnR2fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicm9rdVwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTU6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1pY3Jvc29mdCBlZGdlXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7aWYoL1xcc2VkZ1xcLy9pLnRlc3QoZSkpcmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfTt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZWRnZVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuRWRnZUhUTUwsdmVyc2lvbjp0fX19LHt0ZXN0OlsvdHJpZGVudC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuVHJpZGVudH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdHJpZGVudFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVzdCgvcHJlc3RvL2kpfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuUHJlc3RvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9wcmVzdG9cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvZ2Vja28vaSkscj1lLnRlc3QoL2xpa2UgZ2Vja28vaSk7cmV0dXJuIHQmJiFyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuR2Vja299LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuQmxpbmt9fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuV2ViS2l0fSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93ZWJraXRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19XTt0LmRlZmF1bHQ9YSxlLmV4cG9ydHM9dC5kZWZhdWx0fX0pfSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bowser/es5.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/aes.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/aes.js ***!
  \*******************************************/
/*! exports provided: AESAlgo, AES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AESAlgo\", function() { return AESAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AES\", function() { return AES; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nclass AESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipher\"] {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nconst AES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipher\"]._createHelper(AESAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvYWVzLmpzP2VhYWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sc0JBQXNCLDJEQUFXO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxZQUFZLDJEQUFXIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvYWVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvY2tDaXBoZXIsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG4vLyBMb29rdXAgdGFibGVzXG5jb25zdCBfU0JPWCA9IFtdO1xuY29uc3QgSU5WX1NCT1ggPSBbXTtcbmNvbnN0IF9TVUJfTUlYXzAgPSBbXTtcbmNvbnN0IF9TVUJfTUlYXzEgPSBbXTtcbmNvbnN0IF9TVUJfTUlYXzIgPSBbXTtcbmNvbnN0IF9TVUJfTUlYXzMgPSBbXTtcbmNvbnN0IElOVl9TVUJfTUlYXzAgPSBbXTtcbmNvbnN0IElOVl9TVUJfTUlYXzEgPSBbXTtcbmNvbnN0IElOVl9TVUJfTUlYXzIgPSBbXTtcbmNvbnN0IElOVl9TVUJfTUlYXzMgPSBbXTtcblxuLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cbi8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5jb25zdCBkID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gIGlmIChpIDwgMTI4KSB7XG4gICAgZFtpXSA9IGkgPDwgMTtcbiAgfSBlbHNlIHtcbiAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgfVxufVxuXG4vLyBXYWxrIEdGKDJeOClcbmxldCB4ID0gMDtcbmxldCB4aSA9IDA7XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gIC8vIENvbXB1dGUgc2JveFxuICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICBfU0JPWFt4XSA9IHN4O1xuICBJTlZfU0JPWFtzeF0gPSB4O1xuXG4gIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgY29uc3QgeDIgPSBkW3hdO1xuICBjb25zdCB4NCA9IGRbeDJdO1xuICBjb25zdCB4OCA9IGRbeDRdO1xuXG4gIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICBfU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICBfU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgX1NVQl9NSVhfMlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgX1NVQl9NSVhfM1t4XSA9IHQ7XG5cbiAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cbiAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgaWYgKCF4KSB7XG4gICAgeGkgPSAxO1xuICAgIHggPSB4aTtcbiAgfSBlbHNlIHtcbiAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgIHhpIF49IGRbZFt4aV1dO1xuICB9XG59XG5cbi8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5jb25zdCBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG4vKipcbiAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgQUVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgbGV0IHQ7XG5cbiAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG4gICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuICAgIGNvbnN0IGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG4gICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG4gICAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuICAgIGNvbnN0IG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG4gICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcbiAgICBjb25zdCBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG4gICAgdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcbiAgICBjb25zdCBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlO1xuICAgIGZvciAobGV0IGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93ICs9IDEpIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cbiAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuICAgICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IChfU0JPWFt0ID4+PiAyNF0gPDwgMjQpXG4gICAgICAgICAgICB8IChfU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpXG4gICAgICAgICAgICB8IChfU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KVxuICAgICAgICAgICAgfCBfU0JPWFt0ICYgMHhmZl07XG5cbiAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IChfU0JPWFt0ID4+PiAyNF0gPDwgMjQpXG4gICAgICAgICAgICB8IChfU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpXG4gICAgICAgICAgICB8IChfU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KVxuICAgICAgICAgICAgfCBfU0JPWFt0ICYgMHhmZl07XG4gICAgICAgIH1cblxuICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcbiAgICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGU7XG4gICAgZm9yIChsZXQgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3cgKz0gMSkge1xuICAgICAgY29uc3Qga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuICAgICAgaWYgKGludktzUm93ICUgNCkge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtfU0JPWFt0ID4+PiAyNF1dXG4gICAgICAgICAgXiBJTlZfU1VCX01JWF8xW19TQk9YWyh0ID4+PiAxNikgJiAweGZmXV1cbiAgICAgICAgICBeIElOVl9TVUJfTUlYXzJbX1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dXG4gICAgICAgICAgXiBJTlZfU1VCX01JWF8zW19TQk9YW3QgJiAweGZmXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5jcnlwdEJsb2NrKE0sIG9mZnNldCkge1xuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhcbiAgICAgIE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIF9TVUJfTUlYXzAsIF9TVUJfTUlYXzEsIF9TVUJfTUlYXzIsIF9TVUJfTUlYXzMsIF9TQk9YLFxuICAgICk7XG4gIH1cblxuICBkZWNyeXB0QmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgbGV0IHQgPSBfTVtvZmZzZXQgKyAxXTtcbiAgICBfTVtvZmZzZXQgKyAxXSA9IF9NW29mZnNldCArIDNdO1xuICAgIF9NW29mZnNldCArIDNdID0gdDtcblxuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhcbiAgICAgIF9NLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5faW52S2V5U2NoZWR1bGUsXG4gICAgICBJTlZfU1VCX01JWF8wLFxuICAgICAgSU5WX1NVQl9NSVhfMSxcbiAgICAgIElOVl9TVUJfTUlYXzIsXG4gICAgICBJTlZfU1VCX01JWF8zLFxuICAgICAgSU5WX1NCT1gsXG4gICAgKTtcblxuICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3NcbiAgICB0ID0gX01bb2Zmc2V0ICsgMV07XG4gICAgX01bb2Zmc2V0ICsgMV0gPSBfTVtvZmZzZXQgKyAzXTtcbiAgICBfTVtvZmZzZXQgKyAzXSA9IHQ7XG4gIH1cblxuICBfZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuICAgIGNvbnN0IF9NID0gTTtcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cbiAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcbiAgICBsZXQgczAgPSBfTVtvZmZzZXRdIF4ga2V5U2NoZWR1bGVbMF07XG4gICAgbGV0IHMxID0gX01bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcbiAgICBsZXQgczIgPSBfTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuICAgIGxldCBzMyA9IF9NW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cbiAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcbiAgICBsZXQga3NSb3cgPSA0O1xuXG4gICAgLy8gUm91bmRzXG4gICAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kICs9IDEpIHtcbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcbiAgICAgIGNvbnN0IHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF1cbiAgICAgICAgXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl1cbiAgICAgICAgXiBTVUJfTUlYXzNbczMgJiAweGZmXVxuICAgICAgICBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIGtzUm93ICs9IDE7XG4gICAgICBjb25zdCB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdXG4gICAgICAgIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl1cbiAgICAgICAgXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdXG4gICAgICAgIF4gU1VCX01JWF8zW3MwICYgMHhmZl1cbiAgICAgICAgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICBrc1JvdyArPSAxO1xuICAgICAgY29uc3QgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XVxuICAgICAgICBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdXG4gICAgICAgIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdXG4gICAgICAgIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcbiAgICAgIGNvbnN0IHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF1cbiAgICAgICAgXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl1cbiAgICAgICAgXiBTVUJfTUlYXzNbczIgJiAweGZmXVxuICAgICAgICBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIGtzUm93ICs9IDE7XG5cbiAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgczAgPSB0MDtcbiAgICAgIHMxID0gdDE7XG4gICAgICBzMiA9IHQyO1xuICAgICAgczMgPSB0MztcbiAgICB9XG5cbiAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICBjb25zdCB0MCA9IChcbiAgICAgIChTQk9YW3MwID4+PiAyNF0gPDwgMjQpXG4gICAgICAgIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNilcbiAgICAgICAgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOClcbiAgICAgICAgfCBTQk9YW3MzICYgMHhmZl1cbiAgICApIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgIGtzUm93ICs9IDE7XG4gICAgY29uc3QgdDEgPSAoXG4gICAgICAoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KVxuICAgICAgICB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpXG4gICAgICAgIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpXG4gICAgICAgIHwgU0JPWFtzMCAmIDB4ZmZdXG4gICAgKSBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICBrc1JvdyArPSAxO1xuICAgIGNvbnN0IHQyID0gKFxuICAgICAgKFNCT1hbczIgPj4+IDI0XSA8PCAyNClcbiAgICAgICAgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KVxuICAgICAgICB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KVxuICAgICAgICB8IFNCT1hbczEgJiAweGZmXVxuICAgICkgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAga3NSb3cgKz0gMTtcbiAgICBjb25zdCB0MyA9IChcbiAgICAgIChTQk9YW3MzID4+PiAyNF0gPDwgMjQpXG4gICAgICAgIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl1cbiAgICApIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgIGtzUm93ICs9IDE7XG5cbiAgICAvLyBTZXQgb3V0cHV0XG4gICAgX01bb2Zmc2V0XSA9IHQwO1xuICAgIF9NW29mZnNldCArIDFdID0gdDE7XG4gICAgX01bb2Zmc2V0ICsgMl0gPSB0MjtcbiAgICBfTVtvZmZzZXQgKyAzXSA9IHQzO1xuICB9XG59XG5BRVNBbGdvLmtleVNpemUgPSAyNTYgLyAzMjtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cbmV4cG9ydCBjb25zdCBBRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFU0FsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/aes.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/cipher-core.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-es/lib/cipher-core.js ***!
  \***************************************************/
/*! exports provided: Cipher, StreamCipher, BlockCipherMode, CBC, Pkcs7, BlockCipher, CipherParams, OpenSSLFormatter, SerializableCipher, OpenSSLKdf, PasswordBasedCipher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cipher\", function() { return Cipher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StreamCipher\", function() { return StreamCipher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockCipherMode\", function() { return BlockCipherMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CBC\", function() { return CBC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pkcs7\", function() { return Pkcs7; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockCipher\", function() { return BlockCipher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CipherParams\", function() { return CipherParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpenSSLFormatter\", function() { return OpenSSLFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SerializableCipher\", function() { return SerializableCipher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpenSSLKdf\", function() { return OpenSSLKdf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PasswordBasedCipher\", function() { return PasswordBasedCipher; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _enc_base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enc-base64.js */ \"./node_modules/crypto-es/lib/enc-base64.js\");\n/* harmony import */ var _evpkdf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./evpkdf.js */ \"./node_modules/crypto-es/lib/evpkdf.js\");\n/* eslint-disable no-use-before-define */\n\n\n\n\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nclass Cipher extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"BufferedBlockAlgorithm\"] {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nclass StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nclass BlockCipherMode extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nclass CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nconst Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nclass BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nclass CipherParams extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nconst OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(_enc_base64_js__WEBPACK_IMPORTED_MODULE_1__[\"Base64\"]);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = _enc_base64_js__WEBPACK_IMPORTED_MODULE_1__[\"Base64\"].parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nclass SerializableCipher extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nconst OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = _evpkdf_js__WEBPACK_IMPORTED_MODULE_2__[\"EvpKDFAlgo\"].create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nclass PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvY2lwaGVyLWNvcmUuanM/NTVlZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNbUI7QUFDc0I7QUFDQTs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ08scUJBQXFCLCtEQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLGlDQUFpQyw2Q0FBSTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNqQyxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyw2Q0FBSTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxrQkFBa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9jaXBoZXItY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbmltcG9ydCB7XG4gIEJhc2UsXG4gIFdvcmRBcnJheSxcbiAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gJy4vZW5jLWJhc2U2NC5qcyc7XG5pbXBvcnQgeyBFdnBLREZBbGdvIH0gZnJvbSAnLi9ldnBrZGYuanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENpcGhlciBleHRlbmRzIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShcbiAgICogICAgICAgQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH1cbiAgICogICAgICk7XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmNmZyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2UoKSwgY2ZnKTtcblxuICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcbiAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG4gICAgdGhpcy5fa2V5ID0ga2V5O1xuXG4gICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUhlbHBlcihTdWJDaXBoZXIpIHtcbiAgICBjb25zdCBzZWxlY3RDaXBoZXJTdHJhdGVneSA9IChrZXkpID0+IHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBlbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoU3ViQ2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG4gICAgICB9LFxuXG4gICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoU3ViQ2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG4gICAqL1xuICByZXNldCgpIHtcbiAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuICAgIHN1cGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuICAgIHRoaXMuX2RvUmVzZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcbiAgICogICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG4gICAqL1xuICBwcm9jZXNzKGRhdGFVcGRhdGUpIHtcbiAgICAvLyBBcHBlbmRcbiAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cbiAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcbiAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG4gICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG4gICAqICAgICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICovXG4gIGZpbmFsaXplKGRhdGFVcGRhdGUpIHtcbiAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuICAgIGlmIChkYXRhVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcbiAgICBjb25zdCBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cbiAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuICB9XG59XG5DaXBoZXIuX0VOQ19YRk9STV9NT0RFID0gMTtcbkNpcGhlci5fREVDX1hGT1JNX01PREUgPSAyO1xuQ2lwaGVyLmtleVNpemUgPSAxMjggLyAzMjtcbkNpcGhlci5pdlNpemUgPSAxMjggLyAzMjtcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZVxuICpcbiAqICAgICBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUNpcGhlciBleHRlbmRzIENpcGhlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuYmxvY2tTaXplID0gMTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcbiAgICBjb25zdCBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcbiAgfVxufVxuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja0NpcGhlck1vZGUgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNpcGhlciwgaXYpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuICAgIHRoaXMuX2l2ID0gaXY7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdikge1xuICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdikge1xuICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG4gIH1cbn1cblxuZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG4gIGNvbnN0IF93b3JkcyA9IHdvcmRzO1xuICBsZXQgYmxvY2s7XG5cbiAgLy8gU2hvcnRjdXRcbiAgY29uc3QgaXYgPSB0aGlzLl9pdjtcblxuICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG4gIGlmIChpdikge1xuICAgIGJsb2NrID0gaXY7XG5cbiAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG4gICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG4gIH1cblxuICAvLyBYT1IgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpICs9IDEpIHtcbiAgICBfd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG4gIH1cbn1cblxuLyoqXG4gKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDQkMgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge1xufVxuLyoqXG4gKiBDQkMgZW5jcnlwdG9yLlxuICovXG5DQkMuRW5jcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDQkMge1xuICAvKipcbiAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuICAgKi9cbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3QgeyBibG9ja1NpemUgfSA9IGNpcGhlcjtcblxuICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcbiAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG4gICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG4gICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuICB9XG59O1xuLyoqXG4gKiBDQkMgZGVjcnlwdG9yLlxuICovXG5DQkMuRGVjcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDQkMge1xuICAvKipcbiAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuICAgKi9cbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3QgeyBibG9ja1NpemUgfSA9IGNpcGhlcjtcblxuICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuICAgIGNvbnN0IHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG4gICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcbiAgfVxufTtcblxuLyoqXG4gKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IFBrY3M3ID0ge1xuICAvKipcbiAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG4gICAqL1xuICBwYWQoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcyk7XG5cbiAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG4gICAgY29uc3QgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNClcbiAgICAgIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpXG4gICAgICB8IChuUGFkZGluZ0J5dGVzIDw8IDgpXG4gICAgICB8IG5QYWRkaW5nQnl0ZXM7XG5cbiAgICAvLyBDcmVhdGUgcGFkZGluZ1xuICAgIGNvbnN0IHBhZGRpbmdXb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG4gICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cbiAgICAvLyBBZGQgcGFkZGluZ1xuICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG4gICAqL1xuICB1bnBhZChkYXRhKSB7XG4gICAgY29uc3QgX2RhdGEgPSBkYXRhO1xuXG4gICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IF9kYXRhLndvcmRzWyhfZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cbiAgICAvLyBSZW1vdmUgcGFkZGluZ1xuICAgIF9kYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG4gIH0sXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemVcbiAqXG4gKiAgICBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja0NpcGhlciBleHRlbmRzIENpcGhlciB7XG4gIGNvbnN0cnVjdG9yKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcbiAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuICAgICAqL1xuICAgIHN1cGVyKHhmb3JtTW9kZSwga2V5LCBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBtb2RlOiBDQkMsXG4gICAgICAgIHBhZGRpbmc6IFBrY3M3LFxuICAgICAgfSxcbiAgICAgIGNmZyxcbiAgICApKTtcblxuICAgIHRoaXMuYmxvY2tTaXplID0gMTI4IC8gMzI7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBsZXQgbW9kZUNyZWF0b3I7XG5cbiAgICAvLyBSZXNldCBjaXBoZXJcbiAgICBzdXBlci5yZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyBjZmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpdiwgbW9kZSB9ID0gY2ZnO1xuXG4gICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT09IHRoaXMuY29uc3RydWN0b3IuX0VOQ19YRk9STV9NT0RFKSB7XG4gICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG4gICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG4gICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG4gICAgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPSBtb2RlQ3JlYXRvcjtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICBsZXQgZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gdGhpcy5jZmc7XG5cbiAgICAvLyBGaW5hbGl6ZVxuICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT09IHRoaXMuY29uc3RydWN0b3IuX0VOQ19YRk9STV9NT0RFKSB7XG4gICAgICAvLyBQYWQgZGF0YVxuICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG4gICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG4gICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuICAgICAgLy8gVW5wYWQgZGF0YVxuICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuICB9XG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG4gKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG4gKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG4gKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cbiAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXJcbiAqICAgIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICovXG5leHBvcnQgY2xhc3MgQ2lwaGVyUGFyYW1zIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcbiAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcbiAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG4gICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcbiAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcbiAgICogICAgICAgICBibG9ja1NpemU6IDQsXG4gICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuICAgKiAgICAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaXBoZXJQYXJhbXMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG4gICAqXG4gICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG4gICAqL1xuICB0b1N0cmluZyhmb3JtYXR0ZXIpIHtcbiAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgT3BlblNTTEZvcm1hdHRlciA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG4gICAqL1xuICBzdHJpbmdpZnkoY2lwaGVyUGFyYW1zKSB7XG4gICAgbGV0IHdvcmRBcnJheTtcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHsgY2lwaGVydGV4dCwgc2FsdCB9ID0gY2lwaGVyUGFyYW1zO1xuXG4gICAgLy8gRm9ybWF0XG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKG9wZW5TU0xTdHIpIHtcbiAgICBsZXQgc2FsdDtcblxuICAgIC8vIFBhcnNlIGJhc2U2NFxuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cbiAgICAvLyBUZXN0IGZvciBzYWx0XG4gICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT09IDB4NjU2NDVmNWYpIHtcbiAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuICAgICAgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG4gICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQsIHNhbHQgfSk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXJpYWxpemFibGVDaXBoZXIgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKi9cbiAgc3RhdGljIGVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpO1xuXG4gICAgLy8gRW5jcnlwdFxuICAgIGNvbnN0IGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBfY2ZnKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcbiAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAgICBjaXBoZXJ0ZXh0LFxuICAgICAga2V5LFxuICAgICAgaXY6IGNpcGhlckNmZy5pdixcbiAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG4gICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcbiAgICAgIGJsb2NrU2l6ZTogZW5jcnlwdG9yLmJsb2NrU2l6ZSxcbiAgICAgIGZvcm1hdHRlcjogX2NmZy5mb3JtYXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlclxuICAgKiAgICAgICAuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LFxuICAgKiAgICAgICAgIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXJcbiAgICogICAgICAgLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSxcbiAgICogICAgICAgICB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICovXG4gIHN0YXRpYyBkZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcbiAgICBsZXQgX2NpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0O1xuXG4gICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG4gICAgY29uc3QgX2NmZyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2UoKSwgdGhpcy5jZmcsIGNmZyk7XG5cbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICBfY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKF9jaXBoZXJ0ZXh0LCBfY2ZnLmZvcm1hdCk7XG5cbiAgICAvLyBEZWNyeXB0XG4gICAgY29uc3QgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIF9jZmcpLmZpbmFsaXplKF9jaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG4gICAgcmV0dXJuIHBsYWludGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cbiAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuICAgKi9cbiAgc3RhdGljIF9wYXJzZShjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcbiAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgfVxufVxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdFxuICpcbiAqICAgIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuXG4gKiAgICBEZWZhdWx0OiBPcGVuU1NMXG4gKi9cblNlcmlhbGl6YWJsZUNpcGhlci5jZmcgPSBPYmplY3QuYXNzaWduKFxuICBuZXcgQmFzZSgpLFxuICB7IGZvcm1hdDogT3BlblNTTEZvcm1hdHRlciB9LFxuKTtcblxuLyoqXG4gKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgT3BlblNTTEtkZiA9IHtcbiAgLyoqXG4gICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdFxuICAgKiAgICAgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG4gICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuICAgKi9cbiAgZXhlY3V0ZShwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG4gICAgbGV0IF9zYWx0ID0gc2FsdDtcblxuICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG4gICAgaWYgKCFfc2FsdCkge1xuICAgICAgX3NhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0IC8gOCk7XG4gICAgfVxuXG4gICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcbiAgICBjb25zdCBrZXkgPSBFdnBLREZBbGdvLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgX3NhbHQpO1xuXG4gICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuICAgIGNvbnN0IGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG4gICAgLy8gUmV0dXJuIHBhcmFtc1xuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5LCBpdiwgc2FsdDogX3NhbHQgfSk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcbiAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXNzd29yZEJhc2VkQ2lwaGVyIGV4dGVuZHMgU2VyaWFsaXphYmxlQ2lwaGVyIHtcbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlclxuICAgKiAgICAgICAuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqL1xuICBzdGF0aWMgZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcbiAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICBjb25zdCBfY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCB0aGlzLmNmZywgY2ZnKTtcblxuICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuICAgIGNvbnN0IGRlcml2ZWRQYXJhbXMgPSBfY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cbiAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG4gICAgX2NmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cbiAgICAvLyBFbmNyeXB0XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0XG4gICAgICAuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBfY2ZnKTtcblxuICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cbiAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlclxuICAgKiAgICAgICAuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJyxcbiAgICogICAgICAgICB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXJcbiAgICogICAgICAgLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsXG4gICAqICAgICAgICAgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKi9cbiAgc3RhdGljIGRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG4gICAgbGV0IF9jaXBoZXJ0ZXh0ID0gY2lwaGVydGV4dDtcblxuICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpO1xuXG4gICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG4gICAgX2NpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShfY2lwaGVydGV4dCwgX2NmZy5mb3JtYXQpO1xuXG4gICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG4gICAgY29uc3QgZGVyaXZlZFBhcmFtcyA9IF9jZmcua2RmXG4gICAgICAuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIF9jaXBoZXJ0ZXh0LnNhbHQpO1xuXG4gICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuICAgIF9jZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG4gICAgLy8gRGVjcnlwdFxuICAgIGNvbnN0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0XG4gICAgICAuY2FsbCh0aGlzLCBjaXBoZXIsIF9jaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgX2NmZyk7XG5cbiAgICByZXR1cm4gcGxhaW50ZXh0O1xuICB9XG59XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcHJvcGVydHkge0tERn0ga2RmXG4gKiAgICAgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuICogICAgIERlZmF1bHQ6IE9wZW5TU0xcbiAqL1xuUGFzc3dvcmRCYXNlZENpcGhlci5jZmcgPSBPYmplY3QuYXNzaWduKFNlcmlhbGl6YWJsZUNpcGhlci5jZmcsIHsga2RmOiBPcGVuU1NMS2RmIH0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/cipher-core.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/core.js ***!
  \********************************************/
/*! exports provided: Base, WordArray, Hex, Latin1, Utf8, BufferedBlockAlgorithm, Hasher, HMAC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Base\", function() { return Base; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WordArray\", function() { return WordArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hex\", function() { return Hex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Latin1\", function() { return Latin1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utf8\", function() { return Utf8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferedBlockAlgorithm\", function() { return BufferedBlockAlgorithm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hasher\", function() { return Hasher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HMAC\", function() { return HMAC; });\n/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nclass Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nclass WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nconst Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nconst Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nconst Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nclass BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nclass Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nclass HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvY29yZS5qcz81NWRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjs7QUFFN0I7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjs7QUFFN0I7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL2NvcmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGluaGVyaXRhbmNlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZSB7XG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cbiAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIE15VHlwZS5taXhJbih7XG4gICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcbiAgICogICAgIH0pO1xuICAgKi9cbiAgbWl4SW4ocHJvcGVydGllcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JkQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3JkcyA9IFtdLCBzaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgbGV0IHR5cGVkQXJyYXkgPSB3b3JkcztcbiAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcbiAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuICAgIGlmIChcbiAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICAgIHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXlcbiAgICAgIHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgICAgIHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICAgICkge1xuICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcbiAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuICAgICAgLy8gRXh0cmFjdCBieXRlc1xuICAgICAgY29uc3QgX3dvcmRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX3dvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxuICAgICAgdGhpcy53b3JkcyA9IF93b3JkcztcbiAgICAgIHRoaXMuc2lnQnl0ZXMgPSB0eXBlZEFycmF5Qnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG4gICAgICB0aGlzLndvcmRzID0gd29yZHM7XG4gICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAqL1xuICBzdGF0aWMgcmFuZG9tKG5CeXRlcykge1xuICAgIGNvbnN0IHdvcmRzID0gW107XG5cbiAgICBjb25zdCByID0gKG1fdykgPT4ge1xuICAgICAgbGV0IF9tX3cgPSBtX3c7XG4gICAgICBsZXQgX21feiA9IDB4M2FkZTY4YjE7XG4gICAgICBjb25zdCBtYXNrID0gMHhmZmZmZmZmZjtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgX21feiA9ICgweDkwNjkgKiAoX21feiAmIDB4RkZGRikgKyAoX21feiA+PiAweDEwKSkgJiBtYXNrO1xuICAgICAgICBfbV93ID0gKDB4NDY1MCAqIChfbV93ICYgMHhGRkZGKSArIChfbV93ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgIGxldCByZXN1bHQgPSAoKF9tX3ogPDwgMHgxMCkgKyBfbV93KSAmIG1hc2s7XG4gICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgcmVzdWx0ICs9IDAuNTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgY29uc3QgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cbiAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29yZEFycmF5KHdvcmRzLCBuQnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG4gICAqL1xuICB0b1N0cmluZyhlbmNvZGVyID0gSGV4KSB7XG4gICAgcmV0dXJuIGVuY29kZXIuc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcbiAgICovXG4gIGNvbmNhdCh3b3JkQXJyYXkpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuICAgIGNvbnN0IHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3JkcztcbiAgICBjb25zdCB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuICAgIGNvbnN0IHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG4gICAgdGhpcy5jbGFtcCgpO1xuXG4gICAgLy8gQ29uY2F0XG4gICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcbiAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cbiAgICAvLyBDaGFpbmFibGVcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuICAgKi9cbiAgY2xhbXAoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyB3b3Jkcywgc2lnQnl0ZXMgfSA9IHRoaXM7XG5cbiAgICAvLyBDbGFtcFxuICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG4gICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG4vKipcbiAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IEhleCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHsgd29yZHMsIHNpZ0J5dGVzIH0gPSB3b3JkQXJyYXk7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3QgaGV4Q2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKGhleFN0cikge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuICAgIC8vIENvbnZlcnRcbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuICB9LFxufTtcblxuLyoqXG4gKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjb25zdCBMYXRpbjEgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICovXG4gIHN0cmluZ2lmeSh3b3JkQXJyYXkpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7IHdvcmRzLCBzaWdCeXRlcyB9ID0gd29yZEFycmF5O1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IGxhdGluMUNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAxKSB7XG4gICAgICBjb25zdCBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UobGF0aW4xU3RyKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV29yZEFycmF5KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuICB9LFxufTtcblxuLyoqXG4gKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjggPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICovXG4gIHN0cmluZ2lmeSh3b3JkQXJyYXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG4gICAqL1xuICBwYXJzZSh1dGY4U3RyKSB7XG4gICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuICpcbiAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplXG4gKlxuICogICAgIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuICovXG5leHBvcnQgY2xhc3MgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgLy8gSW5pdGlhbCB2YWx1ZXNcbiAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheSgpO1xuICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVxuICAgKlxuICAgKiAgICAgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcbiAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuICAgKi9cbiAgX2FwcGVuZChkYXRhKSB7XG4gICAgbGV0IG1fZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG4gICAgaWYgKHR5cGVvZiBtX2RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtX2RhdGEgPSBVdGY4LnBhcnNlKG1fZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kXG4gICAgdGhpcy5fZGF0YS5jb25jYXQobV9kYXRhKTtcbiAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IG1fZGF0YS5zaWdCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcbiAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuICAgKi9cbiAgX3Byb2Nlc3MoZG9GbHVzaCkge1xuICAgIGxldCBwcm9jZXNzZWRXb3JkcztcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHsgX2RhdGE6IGRhdGEsIGJsb2NrU2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuICAgIGNvbnN0IGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG4gICAgY29uc3QgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG4gICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG4gICAgbGV0IG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuICAgIGlmIChkb0ZsdXNoKSB7XG4gICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG4gICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG4gICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG4gICAgfVxuXG4gICAgLy8gQ291bnQgd29yZHMgcmVhZHlcbiAgICBjb25zdCBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG4gICAgY29uc3QgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cbiAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuICAgIGlmIChuV29yZHNSZWFkeSkge1xuICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcbiAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG4gICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZVxuICpcbiAqICAgICBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuICovXG5leHBvcnQgY2xhc3MgSGFzaGVyIGV4dGVuZHMgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDMyO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCBjZmcpO1xuXG4gICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SGFzaGVyfSBTdWJIYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcbiAgICovXG4gIHN0YXRpYyBfY3JlYXRlSGVscGVyKFN1Ykhhc2hlcikge1xuICAgIHJldHVybiAobWVzc2FnZSwgY2ZnKSA9PiBuZXcgU3ViSGFzaGVyKGNmZykuZmluYWxpemUobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtIYXNoZXJ9IFN1Ykhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVIbWFjSGVscGVyKFN1Ykhhc2hlcikge1xuICAgIHJldHVybiAobWVzc2FnZSwga2V5KSA9PiBuZXcgSE1BQyhTdWJIYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG4gICAqL1xuICByZXNldCgpIHtcbiAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuICAgIHN1cGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuICAgIHRoaXMuX2RvUmVzZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgdXBkYXRlKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAvLyBBcHBlbmRcbiAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGhhc2hcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBDaGFpbmFibGVcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG4gICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG4gICAqL1xuICBmaW5hbGl6ZShtZXNzYWdlVXBkYXRlKSB7XG4gICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcbiAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuICAgIHJldHVybiBoYXNoO1xuICB9XG59XG5cbi8qKlxuICogSE1BQyBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cbiAgICpcbiAgICogQHBhcmFtIHtIYXNoZXJ9IFN1Ykhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKFN1Ykhhc2hlciwga2V5KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGhhc2hlciA9IG5ldyBTdWJIYXNoZXIoKTtcbiAgICB0aGlzLl9oYXNoZXIgPSBoYXNoZXI7XG5cbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG4gICAgbGV0IF9rZXkgPSBrZXk7XG4gICAgaWYgKHR5cGVvZiBfa2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgX2tleSA9IFV0ZjgucGFyc2UoX2tleSk7XG4gICAgfVxuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcbiAgICBjb25zdCBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcbiAgICBpZiAoX2tleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG4gICAgICBfa2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG4gICAgfVxuXG4gICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcbiAgICBfa2V5LmNsYW1wKCk7XG5cbiAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG4gICAgY29uc3Qgb0tleSA9IF9rZXkuY2xvbmUoKTtcbiAgICB0aGlzLl9vS2V5ID0gb0tleTtcbiAgICBjb25zdCBpS2V5ID0gX2tleS5jbG9uZSgpO1xuICAgIHRoaXMuX2lLZXkgPSBpS2V5O1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qgb0tleVdvcmRzID0gb0tleS53b3JkcztcbiAgICBjb25zdCBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG4gICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkgKz0gMSkge1xuICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG4gICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcbiAgICB9XG4gICAgb0tleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuICAgIGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cbiAgICAvLyBSZXNldFxuICAgIGhhc2hlci5yZXNldCgpO1xuICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgdXBkYXRlKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG4gICAgLy8gQ2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG4gICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgZmluYWxpemUobWVzc2FnZVVwZGF0ZSkge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG4gICAgLy8gQ29tcHV0ZSBITUFDXG4gICAgY29uc3QgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuICAgIGhhc2hlci5yZXNldCgpO1xuICAgIGNvbnN0IGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuICAgIHJldHVybiBobWFjO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/core.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/enc-base64.js":
/*!**************************************************!*\
  !*** ./node_modules/crypto-es/lib/enc-base64.js ***!
  \**************************************************/
/*! exports provided: Base64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Base64\", function() { return Base64; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nconst Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLWJhc2U2NC5qcz85OTMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUVtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBUztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLWJhc2U2NC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcblxuY29uc3QgcGFyc2VMb29wID0gKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSA9PiB7XG4gIGNvbnN0IHdvcmRzID0gW107XG4gIGxldCBuQnl0ZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGkgJSA0KSB7XG4gICAgICBjb25zdCBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuICAgICAgY29uc3QgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG4gICAgICBjb25zdCBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSBiaXRzQ29tYmluZWQgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG4gICAgICBuQnl0ZXMgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG59O1xuXG4vKipcbiAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IEJhc2U2NCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyB3b3Jkcywgc2lnQnl0ZXMgfSA9IHdvcmRBcnJheTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IGJhc2U2NENoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG4gICAgICBjb25zdCBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICBjb25zdCBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICBjb25zdCBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cbiAgICAgIGNvbnN0IHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGogKz0gMSkge1xuICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgY29uc3QgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG4gICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UoYmFzZTY0U3RyKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgbGV0IGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgIGxldCByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuICAgIGlmICghcmV2ZXJzZU1hcCkge1xuICAgICAgdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHBhZGRpbmdcbiAgICBjb25zdCBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgY29uc3QgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnRcbiAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcbiAgfSxcblxuICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/enc-base64.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/enc-utf16.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/enc-utf16.js ***!
  \*************************************************/
/*! exports provided: Utf16BE, Utf16, Utf16LE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utf16BE\", function() { return Utf16BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utf16\", function() { return Utf16; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utf16LE\", function() { return Utf16LE; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst swapEndian = word => ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\n/**\n * UTF-16 BE encoding strategy.\n */\nconst Utf16BE = {\n  /**\n   * Converts a word array to a UTF-16 BE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 BE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const utf16Chars = [];\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 BE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 BE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n    }\n\n    return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(words, utf16StrLength * 2);\n  },\n};\nconst Utf16 = Utf16BE;\n\n/**\n * UTF-16 LE encoding strategy.\n */\nconst Utf16LE = {\n  /**\n   * Converts a word array to a UTF-16 LE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 LE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const utf16Chars = [];\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 LE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 LE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n    }\n\n    return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(words, utf16StrLength * 2);\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLXV0ZjE2LmpzPzU0N2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7O0FBRTdCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBLFdBQVcsa0RBQVM7QUFDcEIsR0FBRztBQUNIO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7O0FBRTdCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBLFdBQVcsa0RBQVM7QUFDcEIsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLXV0ZjE2LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgV29yZEFycmF5LFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG5jb25zdCBzd2FwRW5kaWFuID0gd29yZCA9PiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblxuLyoqXG4gKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjb25zdCBVdGYxNkJFID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyB3b3Jkcywgc2lnQnl0ZXMgfSA9IHdvcmRBcnJheTtcblxuICAgIC8vIENvbnZlcnRcbiAgICBjb25zdCB1dGYxNkNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG4gICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UodXRmMTZTdHIpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG4gIH0sXG59O1xuZXhwb3J0IGNvbnN0IFV0ZjE2ID0gVXRmMTZCRTtcblxuLyoqXG4gKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjb25zdCBVdGYxNkxFID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IExFIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICovXG4gIHN0cmluZ2lmeSh3b3JkQXJyYXkpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7IHdvcmRzLCBzaWdCeXRlcyB9ID0gd29yZEFycmF5O1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHV0ZjE2Q2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcbiAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBMRSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcbiAgICovXG4gIHBhcnNlKHV0ZjE2U3RyKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuICAgIC8vIENvbnZlcnRcbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuICB9LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/enc-utf16.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/evpkdf.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/evpkdf.js ***!
  \**********************************************/
/*! exports provided: EvpKDFAlgo, EvpKDF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EvpKDFAlgo\", function() { return EvpKDFAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EvpKDF\", function() { return EvpKDF; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/crypto-es/lib/md5.js\");\n\n\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nclass EvpKDFAlgo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](),\n      {\n        keySize: 128 / 32,\n        hasher: _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"MD5Algo\"],\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nconst EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZXZwa2RmLmpzP2QxOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdtQjtBQUNnQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsNkNBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Qsa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLFVBQVUsNkNBQUk7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFPO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrREFBUzs7QUFFaEM7QUFDQTtBQUNBLFdBQVcsc0JBQXNCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL2V2cGtkZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2UsXG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IE1ENUFsZ28gfSBmcm9tICcuL21kNS5qcyc7XG5cbi8qKlxuICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG4gKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgRXZwS0RGQWxnbyBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcbiAgICAgKi9cbiAgICB0aGlzLmNmZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICBuZXcgQmFzZSgpLFxuICAgICAge1xuICAgICAgICBrZXlTaXplOiAxMjggLyAzMixcbiAgICAgICAgaGFzaGVyOiBNRDVBbGdvLFxuICAgICAgICBpdGVyYXRpb25zOiAxLFxuICAgICAgfSxcbiAgICAgIGNmZyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG4gICAqL1xuICBjb21wdXRlKHBhc3N3b3JkLCBzYWx0KSB7XG4gICAgbGV0IGJsb2NrO1xuXG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCB7IGNmZyB9ID0gdGhpcztcblxuICAgIC8vIEluaXQgaGFzaGVyXG4gICAgY29uc3QgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuICAgIC8vIEluaXRpYWwgdmFsdWVzXG4gICAgY29uc3QgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG4gICAgY29uc3QgeyBrZXlTaXplLCBpdGVyYXRpb25zIH0gPSBjZmc7XG5cbiAgICAvLyBHZW5lcmF0ZSBrZXlcbiAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcbiAgICAgIGlmIChibG9jaykge1xuICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG4gICAgICBoYXNoZXIucmVzZXQoKTtcblxuICAgICAgLy8gSXRlcmF0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpICs9IDEpIHtcbiAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuICAgICAgICBoYXNoZXIucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuICAgIH1cbiAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cbiAgICByZXR1cm4gZGVyaXZlZEtleTtcbiAgfVxufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEV2cEtERiA9IChwYXNzd29yZCwgc2FsdCwgY2ZnKSA9PiBFdnBLREZBbGdvLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/evpkdf.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/format-hex.js":
/*!**************************************************!*\
  !*** ./node_modules/crypto-es/lib/format-hex.js ***!
  \**************************************************/
/*! exports provided: HexFormatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HexFormatter\", function() { return HexFormatter; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n\nconst HexFormatter = {\n  /**\n   * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The hexadecimally encoded string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    return cipherParams.ciphertext.toString(_core_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"]);\n  },\n\n  /**\n   * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n   *\n   * @param {string} input The hexadecimally encoded string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n   */\n  parse(input) {\n    const ciphertext = _core_js__WEBPACK_IMPORTED_MODULE_1__[\"Hex\"].parse(input);\n    return _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"CipherParams\"].create({ ciphertext });\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZm9ybWF0LWhleC5qcz84OGJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTBCO0FBR1A7O0FBRVo7QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0Q0FBRztBQUMvQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFHO0FBQzFCLFdBQVcsNERBQVksU0FBUyxhQUFhO0FBQzdDLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL2Zvcm1hdC1oZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaXBoZXJQYXJhbXMsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuaW1wb3J0IHtcbiAgSGV4LFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG5leHBvcnQgY29uc3QgSGV4Rm9ybWF0dGVyID0ge1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgICovXG4gIHN0cmluZ2lmeShjaXBoZXJQYXJhbXMpIHtcbiAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0IH0pO1xuICB9LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/format-hex.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/hmac.js ***!
  \********************************************/
/*! exports provided: HMAC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HMAC\", function() { return _core_js__WEBPACK_IMPORTED_MODULE_0__[\"HMAC\"]; });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaG1hYy5qcz9kMzg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRW1CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaG1hYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7XG4gIEhNQUMsXG59IGZyb20gJy4vY29yZS5qcyc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/hmac.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-es/lib/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/* harmony import */ var _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enc-utf16.js */ \"./node_modules/crypto-es/lib/enc-utf16.js\");\n/* harmony import */ var _enc_base64_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enc-base64.js */ \"./node_modules/crypto-es/lib/enc-base64.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/crypto-es/lib/hmac.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/crypto-es/lib/md5.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/crypto-es/lib/sha1.js\");\n/* harmony import */ var _sha224_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sha224.js */ \"./node_modules/crypto-es/lib/sha224.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sha256.js */ \"./node_modules/crypto-es/lib/sha256.js\");\n/* harmony import */ var _sha384_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sha384.js */ \"./node_modules/crypto-es/lib/sha384.js\");\n/* harmony import */ var _sha512_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sha512.js */ \"./node_modules/crypto-es/lib/sha512.js\");\n/* harmony import */ var _sha3_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sha3.js */ \"./node_modules/crypto-es/lib/sha3.js\");\n/* harmony import */ var _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ripemd160.js */ \"./node_modules/crypto-es/lib/ripemd160.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pbkdf2.js */ \"./node_modules/crypto-es/lib/pbkdf2.js\");\n/* harmony import */ var _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./evpkdf.js */ \"./node_modules/crypto-es/lib/evpkdf.js\");\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./aes.js */ \"./node_modules/crypto-es/lib/aes.js\");\n/* harmony import */ var _tripledes_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tripledes.js */ \"./node_modules/crypto-es/lib/tripledes.js\");\n/* harmony import */ var _rabbit_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./rabbit.js */ \"./node_modules/crypto-es/lib/rabbit.js\");\n/* harmony import */ var _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./rabbit-legacy.js */ \"./node_modules/crypto-es/lib/rabbit-legacy.js\");\n/* harmony import */ var _rc4_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./rc4.js */ \"./node_modules/crypto-es/lib/rc4.js\");\n/* harmony import */ var _mode_cfb_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./mode-cfb.js */ \"./node_modules/crypto-es/lib/mode-cfb.js\");\n/* harmony import */ var _mode_ctr_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./mode-ctr.js */ \"./node_modules/crypto-es/lib/mode-ctr.js\");\n/* harmony import */ var _mode_ctr_gladman_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mode-ctr-gladman.js */ \"./node_modules/crypto-es/lib/mode-ctr-gladman.js\");\n/* harmony import */ var _mode_ecb_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./mode-ecb.js */ \"./node_modules/crypto-es/lib/mode-ecb.js\");\n/* harmony import */ var _mode_ofb_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./mode-ofb.js */ \"./node_modules/crypto-es/lib/mode-ofb.js\");\n/* harmony import */ var _pad_ansix923_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./pad-ansix923.js */ \"./node_modules/crypto-es/lib/pad-ansix923.js\");\n/* harmony import */ var _pad_iso10126_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./pad-iso10126.js */ \"./node_modules/crypto-es/lib/pad-iso10126.js\");\n/* harmony import */ var _pad_iso97971_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./pad-iso97971.js */ \"./node_modules/crypto-es/lib/pad-iso97971.js\");\n/* harmony import */ var _pad_nopadding_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./pad-nopadding.js */ \"./node_modules/crypto-es/lib/pad-nopadding.js\");\n/* harmony import */ var _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./pad-zeropadding.js */ \"./node_modules/crypto-es/lib/pad-zeropadding.js\");\n/* harmony import */ var _format_hex_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./format-hex.js */ \"./node_modules/crypto-es/lib/format-hex.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  lib: {\n    Base: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"],\n    WordArray: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"],\n    BufferedBlockAlgorithm: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"BufferedBlockAlgorithm\"],\n    Hasher: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"],\n    Cipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"Cipher\"],\n    StreamCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"StreamCipher\"],\n    BlockCipherMode: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"BlockCipherMode\"],\n    BlockCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"BlockCipher\"],\n    CipherParams: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"CipherParams\"],\n    SerializableCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"SerializableCipher\"],\n    PasswordBasedCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"PasswordBasedCipher\"],\n  },\n\n  x64: {\n    Word: _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"],\n    WordArray: _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64WordArray\"],\n  },\n\n  enc: {\n    Hex: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hex\"],\n    Latin1: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Latin1\"],\n    Utf8: _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Utf8\"],\n    Utf16: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__[\"Utf16\"],\n    Utf16BE: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__[\"Utf16BE\"],\n    Utf16LE: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__[\"Utf16LE\"],\n    Base64: _enc_base64_js__WEBPACK_IMPORTED_MODULE_4__[\"Base64\"],\n  },\n\n  algo: {\n    HMAC: _hmac_js__WEBPACK_IMPORTED_MODULE_5__[\"HMAC\"],\n    MD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__[\"MD5Algo\"],\n    SHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__[\"SHA1Algo\"],\n    SHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__[\"SHA224Algo\"],\n    SHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__[\"SHA256Algo\"],\n    SHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__[\"SHA384Algo\"],\n    SHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__[\"SHA512Algo\"],\n    SHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__[\"SHA3Algo\"],\n    RIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__[\"RIPEMD160Algo\"],\n\n    PBKDF2: _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__[\"PBKDF2Algo\"],\n    EvpKDF: _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__[\"EvpKDFAlgo\"],\n\n    AES: _aes_js__WEBPACK_IMPORTED_MODULE_16__[\"AESAlgo\"],\n    DES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__[\"DESAlgo\"],\n    TripleDES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__[\"TripleDESAlgo\"],\n    Rabbit: _rabbit_js__WEBPACK_IMPORTED_MODULE_18__[\"RabbitAlgo\"],\n    RabbitLegacy: _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__[\"RabbitLegacyAlgo\"],\n    RC4: _rc4_js__WEBPACK_IMPORTED_MODULE_20__[\"RC4Algo\"],\n    RC4Drop: _rc4_js__WEBPACK_IMPORTED_MODULE_20__[\"RC4DropAlgo\"],\n  },\n\n  mode: {\n    CBC: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"CBC\"],\n    CFB: _mode_cfb_js__WEBPACK_IMPORTED_MODULE_21__[\"CFB\"],\n    CTR: _mode_ctr_js__WEBPACK_IMPORTED_MODULE_22__[\"CTR\"],\n    CTRGladman: _mode_ctr_gladman_js__WEBPACK_IMPORTED_MODULE_23__[\"CTRGladman\"],\n    ECB: _mode_ecb_js__WEBPACK_IMPORTED_MODULE_24__[\"ECB\"],\n    OFB: _mode_ofb_js__WEBPACK_IMPORTED_MODULE_25__[\"OFB\"],\n  },\n\n  pad: {\n    Pkcs7: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"Pkcs7\"],\n    AnsiX923: _pad_ansix923_js__WEBPACK_IMPORTED_MODULE_26__[\"AnsiX923\"],\n    Iso10126: _pad_iso10126_js__WEBPACK_IMPORTED_MODULE_27__[\"Iso10126\"],\n    Iso97971: _pad_iso97971_js__WEBPACK_IMPORTED_MODULE_28__[\"Iso97971\"],\n    NoPadding: _pad_nopadding_js__WEBPACK_IMPORTED_MODULE_29__[\"NoPadding\"],\n    ZeroPadding: _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_30__[\"ZeroPadding\"],\n  },\n\n  format: {\n    OpenSSL: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"OpenSSLFormatter\"],\n    Hex: _format_hex_js__WEBPACK_IMPORTED_MODULE_31__[\"HexFormatter\"],\n  },\n\n  kdf: {\n    OpenSSL: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__[\"OpenSSLKdf\"],\n  },\n\n  MD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__[\"MD5\"],\n  HmacMD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__[\"HmacMD5\"],\n  SHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__[\"SHA1\"],\n  HmacSHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__[\"HmacSHA1\"],\n  SHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__[\"SHA224\"],\n  HmacSHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__[\"HmacSHA224\"],\n  SHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__[\"SHA256\"],\n  HmacSHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__[\"HmacSHA256\"],\n  SHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__[\"SHA384\"],\n  HmacSHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__[\"HmacSHA384\"],\n  SHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__[\"SHA512\"],\n  HmacSHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__[\"HmacSHA512\"],\n  SHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__[\"SHA3\"],\n  HmacSHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__[\"HmacSHA3\"],\n  RIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__[\"RIPEMD160\"],\n  HmacRIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__[\"HmacRIPEMD160\"],\n\n  PBKDF2: _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__[\"PBKDF2\"],\n  EvpKDF: _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__[\"EvpKDF\"],\n\n  AES: _aes_js__WEBPACK_IMPORTED_MODULE_16__[\"AES\"],\n  DES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__[\"DES\"],\n  TripleDES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__[\"TripleDES\"],\n  Rabbit: _rabbit_js__WEBPACK_IMPORTED_MODULE_18__[\"Rabbit\"],\n  RabbitLegacy: _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__[\"RabbitLegacy\"],\n  RC4: _rc4_js__WEBPACK_IMPORTED_MODULE_20__[\"RC4\"],\n  RC4Drop: _rc4_js__WEBPACK_IMPORTED_MODULE_20__[\"RC4Drop\"],\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaW5kZXguanM/Y2I0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRbUI7QUFJSTtBQWFHOztBQUUrQjtBQUNoQjtBQUNSO0FBQ2dCO0FBQ0k7QUFDUTtBQUNBO0FBQ0E7QUFDQTtBQUNSO0FBQ29CO0FBQ3hCO0FBQ0E7QUFDVDtBQU1oQjtBQUN5QjtBQUNtQjtBQU1sRDtBQUNrQjtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ1M7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNKOztBQUVoQztBQUNmO0FBQ0EsSUFBSSxtREFBSTtBQUNSLElBQUksNkRBQVM7QUFDYixJQUFJLHVGQUFzQjtBQUMxQixJQUFJLHVEQUFNO0FBQ1YsSUFBSSw4REFBTTtBQUNWLElBQUksMEVBQVk7QUFDaEIsSUFBSSxnRkFBZTtBQUNuQixJQUFJLHdFQUFXO0FBQ2YsSUFBSSwwRUFBWTtBQUNoQixJQUFJLHNGQUFrQjtBQUN0QixJQUFJLHdGQUFtQjtBQUN2QixHQUFHOztBQUVIO0FBQ0EsVUFBVSxvREFBTztBQUNqQixlQUFlLHlEQUFZO0FBQzNCLEdBQUc7O0FBRUg7QUFDQSxJQUFJLGlEQUFHO0FBQ1AsSUFBSSx1REFBTTtBQUNWLElBQUksbURBQUk7QUFDUixJQUFJLDBEQUFLO0FBQ1QsSUFBSSw4REFBTztBQUNYLElBQUksOERBQU87QUFDWCxJQUFJLDZEQUFNO0FBQ1YsR0FBRzs7QUFFSDtBQUNBLElBQUksbURBQUk7QUFDUixTQUFTLCtDQUFPO0FBQ2hCLFVBQVUsaURBQVE7QUFDbEIsWUFBWSxxREFBVTtBQUN0QixZQUFZLHFEQUFVO0FBQ3RCLFlBQVksc0RBQVU7QUFDdEIsWUFBWSxzREFBVTtBQUN0QixVQUFVLGtEQUFRO0FBQ2xCLGVBQWUsNERBQWE7O0FBRTVCLFlBQVksc0RBQVU7QUFDdEIsWUFBWSxzREFBVTs7QUFFdEIsU0FBUyxnREFBTztBQUNoQixTQUFTLHNEQUFPO0FBQ2hCLGVBQWUsNERBQWE7QUFDNUIsWUFBWSxzREFBVTtBQUN0QixrQkFBa0IsbUVBQWdCO0FBQ2xDLFNBQVMsZ0RBQU87QUFDaEIsYUFBYSxvREFBVztBQUN4QixHQUFHOztBQUVIO0FBQ0EsSUFBSSx3REFBRztBQUNQLElBQUksc0RBQUc7QUFDUCxJQUFJLHNEQUFHO0FBQ1AsSUFBSSw0RUFBVTtBQUNkLElBQUksc0RBQUc7QUFDUCxJQUFJLHNEQUFHO0FBQ1AsR0FBRzs7QUFFSDtBQUNBLElBQUksNERBQUs7QUFDVCxJQUFJLG9FQUFRO0FBQ1osSUFBSSxvRUFBUTtBQUNaLElBQUksb0VBQVE7QUFDWixJQUFJLHVFQUFTO0FBQ2IsSUFBSSw2RUFBVztBQUNmLEdBQUc7O0FBRUg7QUFDQSxhQUFhLGdFQUFnQjtBQUM3QixTQUFTLDREQUFZO0FBQ3JCLEdBQUc7O0FBRUg7QUFDQSxhQUFhLDBEQUFVO0FBQ3ZCLEdBQUc7O0FBRUgsRUFBRSxnREFBRztBQUNMLEVBQUUsd0RBQU87QUFDVCxFQUFFLG1EQUFJO0FBQ04sRUFBRSwyREFBUTtBQUNWLEVBQUUseURBQU07QUFDUixFQUFFLGlFQUFVO0FBQ1osRUFBRSx5REFBTTtBQUNSLEVBQUUsaUVBQVU7QUFDWixFQUFFLDBEQUFNO0FBQ1IsRUFBRSxrRUFBVTtBQUNaLEVBQUUsMERBQU07QUFDUixFQUFFLGtFQUFVO0FBQ1osRUFBRSxvREFBSTtBQUNOLEVBQUUsNERBQVE7QUFDVixFQUFFLG1FQUFTO0FBQ1gsRUFBRSwyRUFBYTs7QUFFZixFQUFFLDBEQUFNO0FBQ1IsRUFBRSwwREFBTTs7QUFFUixFQUFFLGlEQUFHO0FBQ0wsRUFBRSx1REFBRztBQUNMLEVBQUUsbUVBQVM7QUFDWCxFQUFFLDBEQUFNO0FBQ1IsRUFBRSw2RUFBWTtBQUNkLEVBQUUsaURBQUc7QUFDTCxFQUFFLHlEQUFPO0FBQ1QsQ0FBQyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlLFxuICBXb3JkQXJyYXksXG4gIEhleCxcbiAgTGF0aW4xLFxuICBVdGY4LFxuICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBYNjRXb3JkLFxuICBYNjRXb3JkQXJyYXksXG59IGZyb20gJy4veDY0LWNvcmUuanMnO1xuaW1wb3J0IHtcbiAgQ2lwaGVyLFxuICBTdHJlYW1DaXBoZXIsXG4gIEJsb2NrQ2lwaGVyTW9kZSxcbiAgQ0JDLFxuICBQa2NzNyxcbiAgQmxvY2tDaXBoZXIsXG4gIENpcGhlclBhcmFtcyxcbiAgT3BlblNTTEZvcm1hdHRlcixcbiAgU2VyaWFsaXphYmxlQ2lwaGVyLFxuICBPcGVuU1NMS2RmLFxuICBQYXNzd29yZEJhc2VkQ2lwaGVyLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuaW1wb3J0IHsgVXRmMTYsIFV0ZjE2QkUsIFV0ZjE2TEUgfSBmcm9tICcuL2VuYy11dGYxNi5qcyc7XG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tICcuL2VuYy1iYXNlNjQuanMnO1xuaW1wb3J0IHsgSE1BQyB9IGZyb20gJy4vaG1hYy5qcyc7XG5pbXBvcnQgeyBNRDVBbGdvLCBNRDUsIEhtYWNNRDUgfSBmcm9tICcuL21kNS5qcyc7XG5pbXBvcnQgeyBTSEExQWxnbywgU0hBMSwgSG1hY1NIQTEgfSBmcm9tICcuL3NoYTEuanMnO1xuaW1wb3J0IHsgU0hBMjI0QWxnbywgU0hBMjI0LCBIbWFjU0hBMjI0IH0gZnJvbSAnLi9zaGEyMjQuanMnO1xuaW1wb3J0IHsgU0hBMjU2QWxnbywgU0hBMjU2LCBIbWFjU0hBMjU2IH0gZnJvbSAnLi9zaGEyNTYuanMnO1xuaW1wb3J0IHsgU0hBMzg0QWxnbywgU0hBMzg0LCBIbWFjU0hBMzg0IH0gZnJvbSAnLi9zaGEzODQuanMnO1xuaW1wb3J0IHsgU0hBNTEyQWxnbywgU0hBNTEyLCBIbWFjU0hBNTEyIH0gZnJvbSAnLi9zaGE1MTIuanMnO1xuaW1wb3J0IHsgU0hBM0FsZ28sIFNIQTMsIEhtYWNTSEEzIH0gZnJvbSAnLi9zaGEzLmpzJztcbmltcG9ydCB7IFJJUEVNRDE2MEFsZ28sIFJJUEVNRDE2MCwgSG1hY1JJUEVNRDE2MCB9IGZyb20gJy4vcmlwZW1kMTYwLmpzJztcbmltcG9ydCB7IFBCS0RGMkFsZ28sIFBCS0RGMiB9IGZyb20gJy4vcGJrZGYyLmpzJztcbmltcG9ydCB7IEV2cEtERkFsZ28sIEV2cEtERiB9IGZyb20gJy4vZXZwa2RmLmpzJztcbmltcG9ydCB7IEFFU0FsZ28sIEFFUyB9IGZyb20gJy4vYWVzLmpzJztcbmltcG9ydCB7XG4gIERFU0FsZ28sXG4gIERFUyxcbiAgVHJpcGxlREVTQWxnbyxcbiAgVHJpcGxlREVTLFxufSBmcm9tICcuL3RyaXBsZWRlcy5qcyc7XG5pbXBvcnQgeyBSYWJiaXRBbGdvLCBSYWJiaXQgfSBmcm9tICcuL3JhYmJpdC5qcyc7XG5pbXBvcnQgeyBSYWJiaXRMZWdhY3lBbGdvLCBSYWJiaXRMZWdhY3kgfSBmcm9tICcuL3JhYmJpdC1sZWdhY3kuanMnO1xuaW1wb3J0IHtcbiAgUkM0QWxnbyxcbiAgUkM0LFxuICBSQzREcm9wQWxnbyxcbiAgUkM0RHJvcCxcbn0gZnJvbSAnLi9yYzQuanMnO1xuaW1wb3J0IHsgQ0ZCIH0gZnJvbSAnLi9tb2RlLWNmYi5qcyc7XG5pbXBvcnQgeyBDVFIgfSBmcm9tICcuL21vZGUtY3RyLmpzJztcbmltcG9ydCB7IENUUkdsYWRtYW4gfSBmcm9tICcuL21vZGUtY3RyLWdsYWRtYW4uanMnO1xuaW1wb3J0IHsgRUNCIH0gZnJvbSAnLi9tb2RlLWVjYi5qcyc7XG5pbXBvcnQgeyBPRkIgfSBmcm9tICcuL21vZGUtb2ZiLmpzJztcbmltcG9ydCB7IEFuc2lYOTIzIH0gZnJvbSAnLi9wYWQtYW5zaXg5MjMuanMnO1xuaW1wb3J0IHsgSXNvMTAxMjYgfSBmcm9tICcuL3BhZC1pc28xMDEyNi5qcyc7XG5pbXBvcnQgeyBJc285Nzk3MSB9IGZyb20gJy4vcGFkLWlzbzk3OTcxLmpzJztcbmltcG9ydCB7IE5vUGFkZGluZyB9IGZyb20gJy4vcGFkLW5vcGFkZGluZy5qcyc7XG5pbXBvcnQgeyBaZXJvUGFkZGluZyB9IGZyb20gJy4vcGFkLXplcm9wYWRkaW5nLmpzJztcbmltcG9ydCB7IEhleEZvcm1hdHRlciB9IGZyb20gJy4vZm9ybWF0LWhleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGliOiB7XG4gICAgQmFzZSxcbiAgICBXb3JkQXJyYXksXG4gICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxcbiAgICBIYXNoZXIsXG4gICAgQ2lwaGVyLFxuICAgIFN0cmVhbUNpcGhlcixcbiAgICBCbG9ja0NpcGhlck1vZGUsXG4gICAgQmxvY2tDaXBoZXIsXG4gICAgQ2lwaGVyUGFyYW1zLFxuICAgIFNlcmlhbGl6YWJsZUNpcGhlcixcbiAgICBQYXNzd29yZEJhc2VkQ2lwaGVyLFxuICB9LFxuXG4gIHg2NDoge1xuICAgIFdvcmQ6IFg2NFdvcmQsXG4gICAgV29yZEFycmF5OiBYNjRXb3JkQXJyYXksXG4gIH0sXG5cbiAgZW5jOiB7XG4gICAgSGV4LFxuICAgIExhdGluMSxcbiAgICBVdGY4LFxuICAgIFV0ZjE2LFxuICAgIFV0ZjE2QkUsXG4gICAgVXRmMTZMRSxcbiAgICBCYXNlNjQsXG4gIH0sXG5cbiAgYWxnbzoge1xuICAgIEhNQUMsXG4gICAgTUQ1OiBNRDVBbGdvLFxuICAgIFNIQTE6IFNIQTFBbGdvLFxuICAgIFNIQTIyNDogU0hBMjI0QWxnbyxcbiAgICBTSEEyNTY6IFNIQTI1NkFsZ28sXG4gICAgU0hBMzg0OiBTSEEzODRBbGdvLFxuICAgIFNIQTUxMjogU0hBNTEyQWxnbyxcbiAgICBTSEEzOiBTSEEzQWxnbyxcbiAgICBSSVBFTUQxNjA6IFJJUEVNRDE2MEFsZ28sXG5cbiAgICBQQktERjI6IFBCS0RGMkFsZ28sXG4gICAgRXZwS0RGOiBFdnBLREZBbGdvLFxuXG4gICAgQUVTOiBBRVNBbGdvLFxuICAgIERFUzogREVTQWxnbyxcbiAgICBUcmlwbGVERVM6IFRyaXBsZURFU0FsZ28sXG4gICAgUmFiYml0OiBSYWJiaXRBbGdvLFxuICAgIFJhYmJpdExlZ2FjeTogUmFiYml0TGVnYWN5QWxnbyxcbiAgICBSQzQ6IFJDNEFsZ28sXG4gICAgUkM0RHJvcDogUkM0RHJvcEFsZ28sXG4gIH0sXG5cbiAgbW9kZToge1xuICAgIENCQyxcbiAgICBDRkIsXG4gICAgQ1RSLFxuICAgIENUUkdsYWRtYW4sXG4gICAgRUNCLFxuICAgIE9GQixcbiAgfSxcblxuICBwYWQ6IHtcbiAgICBQa2NzNyxcbiAgICBBbnNpWDkyMyxcbiAgICBJc28xMDEyNixcbiAgICBJc285Nzk3MSxcbiAgICBOb1BhZGRpbmcsXG4gICAgWmVyb1BhZGRpbmcsXG4gIH0sXG5cbiAgZm9ybWF0OiB7XG4gICAgT3BlblNTTDogT3BlblNTTEZvcm1hdHRlcixcbiAgICBIZXg6IEhleEZvcm1hdHRlcixcbiAgfSxcblxuICBrZGY6IHtcbiAgICBPcGVuU1NMOiBPcGVuU1NMS2RmLFxuICB9LFxuXG4gIE1ENSxcbiAgSG1hY01ENSxcbiAgU0hBMSxcbiAgSG1hY1NIQTEsXG4gIFNIQTIyNCxcbiAgSG1hY1NIQTIyNCxcbiAgU0hBMjU2LFxuICBIbWFjU0hBMjU2LFxuICBTSEEzODQsXG4gIEhtYWNTSEEzODQsXG4gIFNIQTUxMixcbiAgSG1hY1NIQTUxMixcbiAgU0hBMyxcbiAgSG1hY1NIQTMsXG4gIFJJUEVNRDE2MCxcbiAgSG1hY1JJUEVNRDE2MCxcblxuICBQQktERjIsXG4gIEV2cEtERixcblxuICBBRVMsXG4gIERFUyxcbiAgVHJpcGxlREVTLFxuICBSYWJiaXQsXG4gIFJhYmJpdExlZ2FjeSxcbiAgUkM0LFxuICBSQzREcm9wLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/index.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/md5.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/md5.js ***!
  \*******************************************/
/*! exports provided: MD5Algo, MD5, HmacMD5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD5Algo\", function() { return MD5Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD5\", function() { return MD5; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacMD5\", function() { return HmacMD5; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nclass MD5Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"]([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nconst MD5 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nconst HmacMD5 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(MD5Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbWQ1LmpzPzFiYjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQiwrQ0FBTTtBQUNuQztBQUNBLHFCQUFxQixrREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxZQUFZLCtDQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdCQUFnQiwrQ0FBTSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL21kNS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbiAgSGFzaGVyLFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG4vLyBDb25zdGFudHMgdGFibGVcbmNvbnN0IFQgPSBbXTtcblxuLy8gQ29tcHV0ZSBjb25zdGFudHNcbmZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkgKz0gMSkge1xuICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xufVxuXG5jb25zdCBGRiA9IChhLCBiLCBjLCBkLCB4LCBzLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcbiAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcbn07XG5cbmNvbnN0IEdHID0gKGEsIGIsIGMsIGQsIHgsIHMsIHQpID0+IHtcbiAgY29uc3QgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xufTtcblxuY29uc3QgSEggPSAoYSwgYiwgYywgZCwgeCwgcywgdCkgPT4ge1xuICBjb25zdCBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG4gIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG59O1xuXG5jb25zdCBJSSA9IChhLCBiLCBjLCBkLCB4LCBzLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcbiAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcbn07XG5cbi8qKlxuICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgTUQ1QWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5KFtcbiAgICAgIDB4Njc0NTIzMDEsXG4gICAgICAweGVmY2RhYjg5LFxuICAgICAgMHg5OGJhZGNmZSxcbiAgICAgIDB4MTAzMjU0NzYsXG4gICAgXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU3dhcCBlbmRpYW5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgICAgY29uc3QgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG4gICAgICBfTVtvZmZzZXRfaV0gPSAoXG4gICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgICAgfCAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBIID0gdGhpcy5faGFzaC53b3JkcztcblxuICAgIGNvbnN0IE1fb2Zmc2V0XzAgPSBfTVtvZmZzZXQgKyAwXTtcbiAgICBjb25zdCBNX29mZnNldF8xID0gX01bb2Zmc2V0ICsgMV07XG4gICAgY29uc3QgTV9vZmZzZXRfMiA9IF9NW29mZnNldCArIDJdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzMgPSBfTVtvZmZzZXQgKyAzXTtcbiAgICBjb25zdCBNX29mZnNldF80ID0gX01bb2Zmc2V0ICsgNF07XG4gICAgY29uc3QgTV9vZmZzZXRfNSA9IF9NW29mZnNldCArIDVdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzYgPSBfTVtvZmZzZXQgKyA2XTtcbiAgICBjb25zdCBNX29mZnNldF83ID0gX01bb2Zmc2V0ICsgN107XG4gICAgY29uc3QgTV9vZmZzZXRfOCA9IF9NW29mZnNldCArIDhdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzkgPSBfTVtvZmZzZXQgKyA5XTtcbiAgICBjb25zdCBNX29mZnNldF8xMCA9IF9NW29mZnNldCArIDEwXTtcbiAgICBjb25zdCBNX29mZnNldF8xMSA9IF9NW29mZnNldCArIDExXTtcbiAgICBjb25zdCBNX29mZnNldF8xMiA9IF9NW29mZnNldCArIDEyXTtcbiAgICBjb25zdCBNX29mZnNldF8xMyA9IF9NW29mZnNldCArIDEzXTtcbiAgICBjb25zdCBNX29mZnNldF8xNCA9IF9NW29mZnNldCArIDE0XTtcbiAgICBjb25zdCBNX29mZnNldF8xNSA9IF9NW29mZnNldCArIDE1XTtcblxuICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG4gICAgbGV0IGEgPSBIWzBdO1xuICAgIGxldCBiID0gSFsxXTtcbiAgICBsZXQgYyA9IEhbMl07XG4gICAgbGV0IGQgPSBIWzNdO1xuXG4gICAgLy8gQ29tcHV0YXRpb25cbiAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgNywgVFswXSk7XG4gICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsIDEyLCBUWzFdKTtcbiAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTcsIFRbMl0pO1xuICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAyMiwgVFszXSk7XG4gICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsIDcsIFRbNF0pO1xuICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAxMiwgVFs1XSk7XG4gICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE3LCBUWzZdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgMjIsIFRbN10pO1xuICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCA3LCBUWzhdKTtcbiAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgMTIsIFRbOV0pO1xuICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG4gICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCBUWzEyXSk7XG4gICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cbiAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNSwgVFsxNl0pO1xuICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCA5LCBUWzE3XSk7XG4gICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAyMCwgVFsxOV0pO1xuICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCA1LCBUWzIwXSk7XG4gICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCBUWzIxXSk7XG4gICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAyMCwgVFsyM10pO1xuICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCA1LCBUWzI0XSk7XG4gICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCBUWzI1XSk7XG4gICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsIDE0LCBUWzI2XSk7XG4gICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsIDIwLCBUWzI3XSk7XG4gICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCBUWzI4XSk7XG4gICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsIDksIFRbMjldKTtcbiAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgMTQsIFRbMzBdKTtcbiAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgNCwgVFszMl0pO1xuICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAxMSwgVFszM10pO1xuICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcbiAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG4gICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsIDQsIFRbMzZdKTtcbiAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgMTEsIFRbMzddKTtcbiAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgMTYsIFRbMzhdKTtcbiAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG4gICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCBUWzQwXSk7XG4gICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsIDExLCBUWzQxXSk7XG4gICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsIDE2LCBUWzQyXSk7XG4gICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsIDIzLCBUWzQzXSk7XG4gICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksIDQsIFRbNDRdKTtcbiAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG4gICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAyMywgVFs0N10pO1xuXG4gICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsIDYsIFRbNDhdKTtcbiAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgMTAsIFRbNDldKTtcbiAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG4gICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsIDIxLCBUWzUxXSk7XG4gICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCBUWzUyXSk7XG4gICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsIDEwLCBUWzUzXSk7XG4gICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAyMSwgVFs1NV0pO1xuICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCA2LCBUWzU2XSk7XG4gICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAxNSwgVFs1OF0pO1xuICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcbiAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNiwgVFs2MF0pO1xuICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcbiAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTUsIFRbNjJdKTtcbiAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgMjEsIFRbNjNdKTtcblxuICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcbiAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG4gICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuICB9XG4gIC8qIGVzbGludC1lbnNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSAobkJpdHNMZWZ0ICUgMzIpKTtcblxuICAgIGNvbnN0IG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgIGNvbnN0IG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcbiAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcbiAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgKTtcblxuICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2g7XG4gICAgY29uc3QgSCA9IGhhc2gud29yZHM7XG5cbiAgICAvLyBTd2FwIGVuZGlhblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgY29uc3QgSF9pID0gSFtpXTtcblxuICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuICovXG5leHBvcnQgY29uc3QgTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1QWxnbyk7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG4gKi9cbmV4cG9ydCBjb25zdCBIbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENUFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/md5.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-cfb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-cfb.js ***!
  \************************************************/
/*! exports provided: CFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CFB\", function() { return CFB; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Generate keystream\n  if (iv) {\n    keystream = iv.slice(0);\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n  cipher.encryptBlock(keystream, 0);\n\n  // Encrypt\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n\n/**\n * Cipher Feedback block mode.\n */\nclass CFB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipherMode\"] {\n}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jZmIuanM/MzU1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFFMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsK0RBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTs7QUFFdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL21vZGUtY2ZiLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvY2tDaXBoZXJNb2RlLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0KHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKSB7XG4gIGNvbnN0IF93b3JkcyA9IHdvcmRzO1xuICBsZXQga2V5c3RyZWFtO1xuXG4gIC8vIFNob3J0Y3V0XG4gIGNvbnN0IGl2ID0gdGhpcy5faXY7XG5cbiAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG4gIGlmIChpdikge1xuICAgIGtleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuXG4gICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGtleXN0cmVhbSA9IHRoaXMuX3ByZXZCbG9jaztcbiAgfVxuICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cbiAgLy8gRW5jcnlwdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgX3dvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcbiAgfVxufVxuXG4vKipcbiAqIENpcGhlciBGZWVkYmFjayBibG9jayBtb2RlLlxuICovXG5leHBvcnQgY2xhc3MgQ0ZCIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHtcbn1cbkNGQi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENGQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHsgYmxvY2tTaXplIH0gPSBjaXBoZXI7XG5cbiAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cbiAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcbiAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG4gIH1cbn07XG5DRkIuRGVjcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDRkIge1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuXG4gICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG4gICAgY29uc3QgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG4gICAgZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpO1xuXG4gICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-cfb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ctr-gladman.js":
/*!********************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ctr-gladman.js ***!
  \********************************************************/
/*! exports provided: CTRGladman */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CTRGladman\", function() { return CTRGladman; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nconst incWord = (word) => {\n  let _word = word;\n\n  if (((word >> 24) & 0xff) === 0xff) { // overflow\n    let b1 = (word >> 16) & 0xff;\n    let b2 = (word >> 8) & 0xff;\n    let b3 = word & 0xff;\n\n    if (b1 === 0xff) { // overflow b1\n      b1 = 0;\n      if (b2 === 0xff) {\n        b2 = 0;\n        if (b3 === 0xff) {\n          b3 = 0;\n        } else {\n          b3 += 1;\n        }\n      } else {\n        b2 += 1;\n      }\n    } else {\n      b1 += 1;\n    }\n\n    _word = 0;\n    _word += (b1 << 16);\n    _word += (b2 << 8);\n    _word += b3;\n  } else {\n    _word += (0x01 << 24);\n  }\n  return _word;\n};\n\nconst incCounter = (counter) => {\n  const _counter = counter;\n  _counter[0] = incWord(_counter[0]);\n\n  if (_counter[0] === 0) {\n    // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n    _counter[1] = incWord(_counter[1]);\n  }\n  return _counter;\n};\n\n/** @preserve\n * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n * derived from CryptoJS.mode.CTR\n * Jan Hruby jhruby.web@gmail.com\n */\nclass CTRGladman extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipherMode\"] {\n}\nCTRGladman.Encryptor = class extends CTRGladman {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n\n    incCounter(counter);\n\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTRGladman.Decryptor = CTRGladman.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHItZ2xhZG1hbi5qcz9lNTM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUUwQjs7QUFFMUI7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QiwrREFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHItZ2xhZG1hbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJsb2NrQ2lwaGVyTW9kZSxcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbmNvbnN0IGluY1dvcmQgPSAod29yZCkgPT4ge1xuICBsZXQgX3dvcmQgPSB3b3JkO1xuXG4gIGlmICgoKHdvcmQgPj4gMjQpICYgMHhmZikgPT09IDB4ZmYpIHsgLy8gb3ZlcmZsb3dcbiAgICBsZXQgYjEgPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgIGxldCBiMiA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICBsZXQgYjMgPSB3b3JkICYgMHhmZjtcblxuICAgIGlmIChiMSA9PT0gMHhmZikgeyAvLyBvdmVyZmxvdyBiMVxuICAgICAgYjEgPSAwO1xuICAgICAgaWYgKGIyID09PSAweGZmKSB7XG4gICAgICAgIGIyID0gMDtcbiAgICAgICAgaWYgKGIzID09PSAweGZmKSB7XG4gICAgICAgICAgYjMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGIzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIyICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGIxICs9IDE7XG4gICAgfVxuXG4gICAgX3dvcmQgPSAwO1xuICAgIF93b3JkICs9IChiMSA8PCAxNik7XG4gICAgX3dvcmQgKz0gKGIyIDw8IDgpO1xuICAgIF93b3JkICs9IGIzO1xuICB9IGVsc2Uge1xuICAgIF93b3JkICs9ICgweDAxIDw8IDI0KTtcbiAgfVxuICByZXR1cm4gX3dvcmQ7XG59O1xuXG5jb25zdCBpbmNDb3VudGVyID0gKGNvdW50ZXIpID0+IHtcbiAgY29uc3QgX2NvdW50ZXIgPSBjb3VudGVyO1xuICBfY291bnRlclswXSA9IGluY1dvcmQoX2NvdW50ZXJbMF0pO1xuXG4gIGlmIChfY291bnRlclswXSA9PT0gMCkge1xuICAgIC8vIGVuY3JfZGF0YSBpbiBmaWxlZW5jLmMgZnJvbSAgRHIgQnJpYW4gR2xhZG1hbidzIGNvdW50cyBvbmx5IHdpdGggRFdPUkQgaiA8IDhcbiAgICBfY291bnRlclsxXSA9IGluY1dvcmQoX2NvdW50ZXJbMV0pO1xuICB9XG4gIHJldHVybiBfY291bnRlcjtcbn07XG5cbi8qKiBAcHJlc2VydmVcbiAqIENvdW50ZXIgYmxvY2sgbW9kZSBjb21wYXRpYmxlIHdpdGggIERyIEJyaWFuIEdsYWRtYW4gZmlsZWVuYy5jXG4gKiBkZXJpdmVkIGZyb20gQ3J5cHRvSlMubW9kZS5DVFJcbiAqIEphbiBIcnVieSBqaHJ1Ynkud2ViQGdtYWlsLmNvbVxuICovXG5leHBvcnQgY2xhc3MgQ1RSR2xhZG1hbiBleHRlbmRzIEJsb2NrQ2lwaGVyTW9kZSB7XG59XG5DVFJHbGFkbWFuLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ1RSR2xhZG1hbiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgX3dvcmRzID0gd29yZHM7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3QgeyBibG9ja1NpemUgfSA9IGNpcGhlcjtcbiAgICBjb25zdCBpdiA9IHRoaXMuX2l2O1xuICAgIGxldCBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuICAgIGlmIChpdikge1xuICAgICAgdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cbiAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcbiAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGluY0NvdW50ZXIoY291bnRlcik7XG5cbiAgICBjb25zdCBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuICAgIC8vIEVuY3J5cHRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgICBfd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuICAgIH1cbiAgfVxufTtcbkNUUkdsYWRtYW4uRGVjcnlwdG9yID0gQ1RSR2xhZG1hbi5FbmNyeXB0b3I7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ctr-gladman.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ctr.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ctr.js ***!
  \************************************************/
/*! exports provided: CTR */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CTR\", function() { return CTR; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Counter block mode.\n */\n\n\nclass CTR extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipherMode\"] {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHIuanM/Yjg1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHMEI7O0FBRW5CLGtCQUFrQiwrREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL21vZGUtY3RyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3VudGVyIGJsb2NrIG1vZGUuXG4gKi9cbmltcG9ydCB7XG4gIEJsb2NrQ2lwaGVyTW9kZSxcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbmV4cG9ydCBjbGFzcyBDVFIgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge1xufVxuQ1RSLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ1RSIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfd29yZHMgPSB3b3JkcztcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuICAgIGNvbnN0IGl2ID0gdGhpcy5faXY7XG4gICAgbGV0IGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG4gICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG4gICAgaWYgKGl2KSB7XG4gICAgICB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG4gICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG4gICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG4gICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcbiAgICBjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdID0gKGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gKyAxKSB8IDA7XG5cbiAgICAvLyBFbmNyeXB0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkgKz0gMSkge1xuICAgICAgX3dvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcbiAgICB9XG4gIH1cbn07XG5DVFIuRGVjcnlwdG9yID0gQ1RSLkVuY3J5cHRvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ctr.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ecb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ecb.js ***!
  \************************************************/
/*! exports provided: ECB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ECB\", function() { return ECB; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Electronic Codebook block mode.\n */\n\n\nclass ECB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipherMode\"] {\n}\nECB.Encryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.encryptBlock(words, offset);\n  }\n};\nECB.Decryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.decryptBlock(words, offset);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1lY2IuanM/MjZjZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHMEI7O0FBRW5CLGtCQUFrQiwrREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1lY2IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVsZWN0cm9uaWMgQ29kZWJvb2sgYmxvY2sgbW9kZS5cbiAqL1xuaW1wb3J0IHtcbiAgQmxvY2tDaXBoZXJNb2RlLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuZXhwb3J0IGNsYXNzIEVDQiBleHRlbmRzIEJsb2NrQ2lwaGVyTW9kZSB7XG59XG5FQ0IuRW5jcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBFQ0Ige1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gIH1cbn07XG5FQ0IuRGVjcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBFQ0Ige1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ecb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ofb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ofb.js ***!
  \************************************************/
/*! exports provided: OFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OFB\", function() { return OFB; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Output Feedback block mode.\n */\n\n\nclass OFB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"BlockCipherMode\"] {\n}\nOFB.Encryptor = class extends OFB {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let keystream = this._keystream;\n\n    // Generate keystream\n    if (iv) {\n      this._keystream = iv.slice(0);\n      keystream = this._keystream;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    cipher.encryptBlock(keystream, 0);\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nOFB.Decryptor = OFB.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1vZmIuanM/YzI1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHMEI7O0FBRW5CLGtCQUFrQiwrREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1vZmIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE91dHB1dCBGZWVkYmFjayBibG9jayBtb2RlLlxuICovXG5pbXBvcnQge1xuICBCbG9ja0NpcGhlck1vZGUsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG5leHBvcnQgY2xhc3MgT0ZCIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHtcbn1cbk9GQi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIE9GQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgX3dvcmRzID0gd29yZHM7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3QgeyBibG9ja1NpemUgfSA9IGNpcGhlcjtcbiAgICBjb25zdCBpdiA9IHRoaXMuX2l2O1xuICAgIGxldCBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW07XG5cbiAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cbiAgICBpZiAoaXYpIHtcbiAgICAgIHRoaXMuX2tleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuICAgICAga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtO1xuXG4gICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG4gICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG4gICAgLy8gRW5jcnlwdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpICs9IDEpIHtcbiAgICAgIF93b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG4gICAgfVxuICB9XG59O1xuT0ZCLkRlY3J5cHRvciA9IE9GQi5FbmNyeXB0b3I7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ofb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-ansix923.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-ansix923.js ***!
  \****************************************************/
/*! exports provided: AnsiX923 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnsiX923\", function() { return AnsiX923; });\n/**\n * ANSI X.923 padding strategy.\n */\nconst AnsiX923 = {\n  pad(data, blockSize) {\n    const _data = data;\n\n    // Shortcuts\n    const dataSigBytes = _data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (dataSigBytes % blockSizeBytes);\n\n    // Compute last byte position\n    const lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n    // Pad\n    _data.clamp();\n    _data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n    _data.sigBytes += nPaddingBytes;\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWFuc2l4OTIzLmpzP2NiZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1hbnNpeDkyMy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQU5TSSBYLjkyMyBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgQW5zaVg5MjMgPSB7XG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhU2lnQnl0ZXMgPSBfZGF0YS5zaWdCeXRlcztcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gKGRhdGFTaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKTtcblxuICAgIC8vIENvbXB1dGUgbGFzdCBieXRlIHBvc2l0aW9uXG4gICAgY29uc3QgbGFzdEJ5dGVQb3MgPSBkYXRhU2lnQnl0ZXMgKyBuUGFkZGluZ0J5dGVzIC0gMTtcblxuICAgIC8vIFBhZFxuICAgIF9kYXRhLmNsYW1wKCk7XG4gICAgX2RhdGEud29yZHNbbGFzdEJ5dGVQb3MgPj4+IDJdIHw9IG5QYWRkaW5nQnl0ZXMgPDwgKDI0IC0gKGxhc3RCeXRlUG9zICUgNCkgKiA4KTtcbiAgICBfZGF0YS5zaWdCeXRlcyArPSBuUGFkZGluZ0J5dGVzO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbKF9kYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuICAgIC8vIFJlbW92ZSBwYWRkaW5nXG4gICAgX2RhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgfSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-ansix923.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-iso10126.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-iso10126.js ***!
  \****************************************************/
/*! exports provided: Iso10126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Iso10126\", function() { return Iso10126; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n/**\n * ISO 10126 padding strategy.\n */\nconst Iso10126 = {\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Pad\n    data\n      .concat(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].random(nPaddingBytes - 1))\n      .concat(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([nPaddingBytes << 24], 1));\n  },\n\n  unpad(data) {\n    const _data = data;\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWlzbzEwMTI2LmpzP2ZjMGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBRW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtEQUFTO0FBQ3ZCLGNBQWMsa0RBQVM7QUFDdkIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWlzbzEwMTI2LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgV29yZEFycmF5LFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG4vKipcbiAqIElTTyAxMDEyNiBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgSXNvMTAxMjYgPSB7XG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSAoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKTtcblxuICAgIC8vIFBhZFxuICAgIGRhdGFcbiAgICAgIC5jb25jYXQoV29yZEFycmF5LnJhbmRvbShuUGFkZGluZ0J5dGVzIC0gMSkpXG4gICAgICAuY29uY2F0KFdvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXMgPDwgMjRdLCAxKSk7XG4gIH0sXG5cbiAgdW5wYWQoZGF0YSkge1xuICAgIGNvbnN0IF9kYXRhID0gZGF0YTtcbiAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbKF9kYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuICAgIC8vIFJlbW92ZSBwYWRkaW5nXG4gICAgX2RhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgfSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-iso10126.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-iso97971.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-iso97971.js ***!
  \****************************************************/
/*! exports provided: Iso97971 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Iso97971\", function() { return Iso97971; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pad-zeropadding.js */ \"./node_modules/crypto-es/lib/pad-zeropadding.js\");\n\n\n\n/**\n * ISO/IEC 9797-1 Padding Method 2.\n */\nconst Iso97971 = {\n  pad(data, blockSize) {\n    // Add 0x80 byte\n    data.concat(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x80000000], 1));\n\n    // Zero pad the rest\n    _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__[\"ZeroPadding\"].pad(data, blockSize);\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Remove zero padding\n    _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__[\"ZeroPadding\"].unpad(_data);\n\n    // Remove one more byte -- the 0x80 byte\n    _data.sigBytes -= 1;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWlzbzk3OTcxLmpzPzdmMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFbUI7QUFHVzs7QUFFOUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFTOztBQUV6QjtBQUNBLElBQUksK0RBQVc7QUFDZixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLCtEQUFXOztBQUVmO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9wYWQtaXNvOTc5NzEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBaZXJvUGFkZGluZyxcbn0gZnJvbSAnLi9wYWQtemVyb3BhZGRpbmcuanMnO1xuXG4vKipcbiAqIElTTy9JRUMgOTc5Ny0xIFBhZGRpbmcgTWV0aG9kIDIuXG4gKi9cbmV4cG9ydCBjb25zdCBJc285Nzk3MSA9IHtcbiAgcGFkKGRhdGEsIGJsb2NrU2l6ZSkge1xuICAgIC8vIEFkZCAweDgwIGJ5dGVcbiAgICBkYXRhLmNvbmNhdChXb3JkQXJyYXkuY3JlYXRlKFsweDgwMDAwMDAwXSwgMSkpO1xuXG4gICAgLy8gWmVybyBwYWQgdGhlIHJlc3RcbiAgICBaZXJvUGFkZGluZy5wYWQoZGF0YSwgYmxvY2tTaXplKTtcbiAgfSxcblxuICB1bnBhZChkYXRhKSB7XG4gICAgY29uc3QgX2RhdGEgPSBkYXRhO1xuXG4gICAgLy8gUmVtb3ZlIHplcm8gcGFkZGluZ1xuICAgIFplcm9QYWRkaW5nLnVucGFkKF9kYXRhKTtcblxuICAgIC8vIFJlbW92ZSBvbmUgbW9yZSBieXRlIC0tIHRoZSAweDgwIGJ5dGVcbiAgICBfZGF0YS5zaWdCeXRlcyAtPSAxO1xuICB9LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-iso97971.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-nopadding.js":
/*!*****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-nopadding.js ***!
  \*****************************************************/
/*! exports provided: NoPadding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoPadding\", function() { return NoPadding; });\n/**\n * A noop padding strategy.\n */\nconst NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLW5vcGFkZGluZy5qcz8xMjY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1ub3BhZGRpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbm9vcCBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgTm9QYWRkaW5nID0ge1xuICBwYWQoKSB7XG4gIH0sXG5cbiAgdW5wYWQoKSB7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-nopadding.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-zeropadding.js":
/*!*******************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-zeropadding.js ***!
  \*******************************************************/
/*! exports provided: ZeroPadding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroPadding\", function() { return ZeroPadding; });\n/**\n * Zero padding strategy.\n */\nconst ZeroPadding = {\n  pad(data, blockSize) {\n    const _data = data;\n\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Pad\n    _data.clamp();\n    _data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Shortcut\n    const dataWords = _data.words;\n\n    // Unpad\n    for (let i = _data.sigBytes - 1; i >= 0; i -= 1) {\n      if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n        _data.sigBytes = i + 1;\n        break;\n      }\n    }\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLXplcm9wYWRkaW5nLmpzPzM2MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC16ZXJvcGFkZGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogWmVybyBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgWmVyb1BhZGRpbmcgPSB7XG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuICAgIC8vIFBhZFxuICAgIF9kYXRhLmNsYW1wKCk7XG4gICAgX2RhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcykgfHwgYmxvY2tTaXplQnl0ZXMpO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGRhdGFXb3JkcyA9IF9kYXRhLndvcmRzO1xuXG4gICAgLy8gVW5wYWRcbiAgICBmb3IgKGxldCBpID0gX2RhdGEuc2lnQnl0ZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKCgoZGF0YVdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZikpIHtcbiAgICAgICAgX2RhdGEuc2lnQnl0ZXMgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-zeropadding.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pbkdf2.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/pbkdf2.js ***!
  \**********************************************/
/*! exports provided: PBKDF2Algo, PBKDF2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBKDF2Algo\", function() { return PBKDF2Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBKDF2\", function() { return PBKDF2; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/crypto-es/lib/sha1.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/crypto-es/lib/hmac.js\");\n\n\n\n\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\nclass PBKDF2Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"](),\n      {\n        keySize: 128 / 32,\n        hasher: _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA1Algo\"],\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    // Shortcut\n    const { cfg } = this;\n\n    // Init HMAC\n    const hmac = _hmac_js__WEBPACK_IMPORTED_MODULE_2__[\"HMAC\"].create(cfg.hasher, password);\n\n    // Initial values\n    const derivedKey = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create();\n    const blockIndex = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x00000001]);\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset();\n\n      // Shortcuts\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length;\n\n      // Iterations\n      let intermediate = block;\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset();\n\n        // Shortcut\n        const intermediateWords = intermediate.words;\n\n        // XOR intermediate with block\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\nconst PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGJrZGYyLmpzPzQ0MTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR21CO0FBQ2tCO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw2Q0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRCxrREFBa0QsK0JBQStCO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsVUFBVSw2Q0FBSTtBQUNkO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVE7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNOztBQUVqQjtBQUNBLGlCQUFpQiw2Q0FBSTs7QUFFckI7QUFDQSx1QkFBdUIsa0RBQVM7QUFDaEMsdUJBQXVCLGtEQUFTOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Qsa0RBQWtELCtCQUErQjtBQUNqRjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGJrZGYyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZSxcbiAgV29yZEFycmF5LFxufSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IHsgU0hBMUFsZ28gfSBmcm9tICcuL3NoYTEuanMnO1xuaW1wb3J0IHsgSE1BQyB9IGZyb20gJy4vaG1hYy5qcyc7XG5cbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMiBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBQQktERjJBbGdvIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoKTtcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZS4gRGVmYXVsdDogU0hBMVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG4gICAgICovXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IEJhc2UoKSxcbiAgICAgIHtcbiAgICAgICAga2V5U2l6ZTogMTI4IC8gMzIsXG4gICAgICAgIGhhc2hlcjogU0hBMUFsZ28sXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEsXG4gICAgICB9LFxuICAgICAgY2ZnLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcbiAgICovXG4gIGNvbXB1dGUocGFzc3dvcmQsIHNhbHQpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHsgY2ZnIH0gPSB0aGlzO1xuXG4gICAgLy8gSW5pdCBITUFDXG4gICAgY29uc3QgaG1hYyA9IEhNQUMuY3JlYXRlKGNmZy5oYXNoZXIsIHBhc3N3b3JkKTtcblxuICAgIC8vIEluaXRpYWwgdmFsdWVzXG4gICAgY29uc3QgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcbiAgICBjb25zdCBibG9ja0luZGV4ID0gV29yZEFycmF5LmNyZWF0ZShbMHgwMDAwMDAwMV0pO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcbiAgICBjb25zdCBibG9ja0luZGV4V29yZHMgPSBibG9ja0luZGV4LndvcmRzO1xuICAgIGNvbnN0IHsga2V5U2l6ZSwgaXRlcmF0aW9ucyB9ID0gY2ZnO1xuXG4gICAgLy8gR2VuZXJhdGUga2V5XG4gICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG4gICAgICBjb25zdCBibG9jayA9IGhtYWMudXBkYXRlKHNhbHQpLmZpbmFsaXplKGJsb2NrSW5kZXgpO1xuICAgICAgaG1hYy5yZXNldCgpO1xuXG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIGNvbnN0IGJsb2NrV29yZHMgPSBibG9jay53b3JkcztcbiAgICAgIGNvbnN0IGJsb2NrV29yZHNMZW5ndGggPSBibG9ja1dvcmRzLmxlbmd0aDtcblxuICAgICAgLy8gSXRlcmF0aW9uc1xuICAgICAgbGV0IGludGVybWVkaWF0ZSA9IGJsb2NrO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpICs9IDEpIHtcbiAgICAgICAgaW50ZXJtZWRpYXRlID0gaG1hYy5maW5hbGl6ZShpbnRlcm1lZGlhdGUpO1xuICAgICAgICBobWFjLnJlc2V0KCk7XG5cbiAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlV29yZHMgPSBpbnRlcm1lZGlhdGUud29yZHM7XG5cbiAgICAgICAgLy8gWE9SIGludGVybWVkaWF0ZSB3aXRoIGJsb2NrXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2tXb3Jkc0xlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgYmxvY2tXb3Jkc1tqXSBePSBpbnRlcm1lZGlhdGVXb3Jkc1tqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG4gICAgICBibG9ja0luZGV4V29yZHNbMF0gKz0gMTtcbiAgICB9XG4gICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG4gICAgcmV0dXJuIGRlcml2ZWRLZXk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQpO1xuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG4gKi9cbmV4cG9ydCBjb25zdCBQQktERjIgPSAocGFzc3dvcmQsIHNhbHQsIGNmZykgPT4gUEJLREYyQWxnby5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pbkdf2.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rabbit-legacy.js":
/*!*****************************************************!*\
  !*** ./node_modules/crypto-es/lib/rabbit-legacy.js ***!
  \*****************************************************/
/*! exports provided: RabbitLegacyAlgo, RabbitLegacy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RabbitLegacyAlgo\", function() { return RabbitLegacyAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RabbitLegacy\", function() { return RabbitLegacy; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Reusable objects\nconst S = [];\nconst C_ = [];\nconst G = [];\n\nfunction nextState() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C;\n\n  // Save old counter values\n  for (let i = 0; i < 8; i += 1) {\n    C_[i] = C[i];\n  }\n\n  // Calculate new counter values\n  C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n  C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n  C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n  C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n  C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n  C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n  C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n  C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n  this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n  // Calculate the g-values\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i];\n\n    // Construct high and low argument for squaring\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16;\n\n    // Calculate high and low result of squaring\n    const gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n    const gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n    // High XOR low\n    G[i] = gh ^ gl;\n  }\n\n  // Calculate new state values\n  X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n  X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;\n  X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n  X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;\n  X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n  X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;\n  X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n  X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;\n}\n\n/**\n * Rabbit stream cipher algorithm.\n *\n * This is a legacy version that neglected to convert the key to little-endian.\n * This error doesn't affect the cipher's security,\n * but it does affect its compatibility with other implementations.\n */\nclass RabbitLegacyAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"] {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const { iv } = this.cfg;\n\n    // Generate initial state values\n    this._X = [\n      K[0], (K[3] << 16) | (K[2] >>> 16),\n      K[1], (K[0] << 16) | (K[3] >>> 16),\n      K[2], (K[1] << 16) | (K[0] >>> 16),\n      K[3], (K[2] << 16) | (K[1] >>> 16),\n    ];\n    const X = this._X;\n\n    // Generate initial counter values\n    this._C = [\n      (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n      (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n      (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n      (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff),\n    ];\n    const C = this._C;\n\n    // Carry bit\n    this._b = 0;\n\n    // Iterate the system four times\n    for (let i = 0; i < 4; i += 1) {\n      nextState.call(this);\n    }\n\n    // Modify the counters\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[(i + 4) & 7];\n    }\n\n    // IV setup\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1];\n\n      // Generate four subvectors\n      const i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff)\n        | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n      const i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff)\n        | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n      const i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n      const i3 = (i2 << 16) | (i0 & 0x0000ffff);\n\n      // Modify counter values\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3;\n\n      // Iterate the system four times\n      for (let i = 0; i < 4; i += 1) {\n        nextState.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Shortcut\n    const X = this._X;\n\n    // Iterate the system\n    nextState.call(this);\n\n    // Generate four keystream words\n    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff)\n        | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);\n\n      // Encrypt\n      _M[offset + i] ^= S[i];\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n */\nconst RabbitLegacy = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"]._createHelper(RabbitLegacyAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmFiYml0LWxlZ2FjeS5qcz8wZjQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiw0REFBWTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiw0REFBWSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3JhYmJpdC1sZWdhY3kuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBTdHJlYW1DaXBoZXIsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG4vLyBSZXVzYWJsZSBvYmplY3RzXG5jb25zdCBTID0gW107XG5jb25zdCBDXyA9IFtdO1xuY29uc3QgRyA9IFtdO1xuXG5mdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICBjb25zdCBYID0gdGhpcy5fWDtcbiAgY29uc3QgQyA9IHRoaXMuX0M7XG5cbiAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBDX1tpXSA9IENbaV07XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG4gIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG4gIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBneCA9IFhbaV0gKyBDW2ldO1xuXG4gICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcbiAgICBjb25zdCBnYSA9IGd4ICYgMHhmZmZmO1xuICAgIGNvbnN0IGdiID0gZ3ggPj4+IDE2O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcbiAgICBjb25zdCBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG4gICAgY29uc3QgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cbiAgICAvLyBIaWdoIFhPUiBsb3dcbiAgICBHW2ldID0gZ2ggXiBnbDtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG4gIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcbiAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG4gIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcbiAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG4gIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcbn1cblxuLyoqXG4gKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG4gKlxuICogVGhpcyBpcyBhIGxlZ2FjeSB2ZXJzaW9uIHRoYXQgbmVnbGVjdGVkIHRvIGNvbnZlcnQgdGhlIGtleSB0byBsaXR0bGUtZW5kaWFuLlxuICogVGhpcyBlcnJvciBkb2Vzbid0IGFmZmVjdCB0aGUgY2lwaGVyJ3Mgc2VjdXJpdHksXG4gKiBidXQgaXQgZG9lcyBhZmZlY3QgaXRzIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSYWJiaXRMZWdhY3lBbGdvIGV4dGVuZHMgU3RyZWFtQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5ibG9ja1NpemUgPSAxMjggLyAzMjtcbiAgICB0aGlzLml2U2l6ZSA9IDY0IC8gMzI7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBLID0gdGhpcy5fa2V5LndvcmRzO1xuICAgIGNvbnN0IHsgaXYgfSA9IHRoaXMuY2ZnO1xuXG4gICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZXNcbiAgICB0aGlzLl9YID0gW1xuICAgICAgS1swXSwgKEtbM10gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSxcbiAgICAgIEtbMV0sIChLWzBdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksXG4gICAgICBLWzJdLCAoS1sxXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLFxuICAgICAgS1szXSwgKEtbMl0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSxcbiAgICBdO1xuICAgIGNvbnN0IFggPSB0aGlzLl9YO1xuXG4gICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuICAgIHRoaXMuX0MgPSBbXG4gICAgICAoS1syXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLCAoS1swXSAmIDB4ZmZmZjAwMDApIHwgKEtbMV0gJiAweDAwMDBmZmZmKSxcbiAgICAgIChLWzNdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksIChLWzFdICYgMHhmZmZmMDAwMCkgfCAoS1syXSAmIDB4MDAwMGZmZmYpLFxuICAgICAgKEtbMF0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSwgKEtbMl0gJiAweGZmZmYwMDAwKSB8IChLWzNdICYgMHgwMDAwZmZmZiksXG4gICAgICAoS1sxXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLCAoS1szXSAmIDB4ZmZmZjAwMDApIHwgKEtbMF0gJiAweDAwMDBmZmZmKSxcbiAgICBdO1xuICAgIGNvbnN0IEMgPSB0aGlzLl9DO1xuXG4gICAgLy8gQ2FycnkgYml0XG4gICAgdGhpcy5fYiA9IDA7XG5cbiAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBNb2RpZnkgdGhlIGNvdW50ZXJzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIENbaV0gXj0gWFsoaSArIDQpICYgN107XG4gICAgfVxuXG4gICAgLy8gSVYgc2V0dXBcbiAgICBpZiAoaXYpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3QgSVYgPSBpdi53b3JkcztcbiAgICAgIGNvbnN0IElWXzAgPSBJVlswXTtcbiAgICAgIGNvbnN0IElWXzEgPSBJVlsxXTtcblxuICAgICAgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG4gICAgICBjb25zdCBpMCA9ICgoKElWXzAgPDwgOCkgfCAoSVZfMCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoSVZfMCA8PCAyNCkgfCAoSVZfMCA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG4gICAgICBjb25zdCBpMiA9ICgoKElWXzEgPDwgOCkgfCAoSVZfMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoSVZfMSA8PCAyNCkgfCAoSVZfMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG4gICAgICBjb25zdCBpMSA9IChpMCA+Pj4gMTYpIHwgKGkyICYgMHhmZmZmMDAwMCk7XG4gICAgICBjb25zdCBpMyA9IChpMiA8PCAxNikgfCAoaTAgJiAweDAwMDBmZmZmKTtcblxuICAgICAgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG4gICAgICBDWzBdIF49IGkwO1xuICAgICAgQ1sxXSBePSBpMTtcbiAgICAgIENbMl0gXj0gaTI7XG4gICAgICBDWzNdIF49IGkzO1xuICAgICAgQ1s0XSBePSBpMDtcbiAgICAgIENbNV0gXj0gaTE7XG4gICAgICBDWzZdIF49IGkyO1xuICAgICAgQ1s3XSBePSBpMztcblxuICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IFggPSB0aGlzLl9YO1xuXG4gICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtXG4gICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBmb3VyIGtleXN0cmVhbSB3b3Jkc1xuICAgIFNbMF0gPSBYWzBdIF4gKFhbNV0gPj4+IDE2KSBeIChYWzNdIDw8IDE2KTtcbiAgICBTWzFdID0gWFsyXSBeIChYWzddID4+PiAxNikgXiAoWFs1XSA8PCAxNik7XG4gICAgU1syXSA9IFhbNF0gXiAoWFsxXSA+Pj4gMTYpIF4gKFhbN10gPDwgMTYpO1xuICAgIFNbM10gPSBYWzZdIF4gKFhbM10gPj4+IDE2KSBeIChYWzFdIDw8IDE2KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAvLyBTd2FwIGVuZGlhblxuICAgICAgU1tpXSA9ICgoKFNbaV0gPDwgOCkgfCAoU1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoU1tpXSA8PCAyNCkgfCAoU1tpXSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cbiAgICAgIC8vIEVuY3J5cHRcbiAgICAgIF9NW29mZnNldCArIGldIF49IFNbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5leHBvcnQgY29uc3QgUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0TGVnYWN5QWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rabbit-legacy.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rabbit.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/rabbit.js ***!
  \**********************************************/
/*! exports provided: RabbitAlgo, Rabbit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RabbitAlgo\", function() { return RabbitAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rabbit\", function() { return Rabbit; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Reusable objects\nconst S = [];\nconst C_ = [];\nconst G = [];\n\nfunction nextState() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C;\n\n  // Save old counter values\n  for (let i = 0; i < 8; i += 1) {\n    C_[i] = C[i];\n  }\n\n  // Calculate new counter values\n  C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n  C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n  C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n  C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n  C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n  C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n  C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n  C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n  this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n  // Calculate the g-values\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i];\n\n    // Construct high and low argument for squaring\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16;\n\n    // Calculate high and low result of squaring\n    const gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n    const gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n    // High XOR low\n    G[i] = gh ^ gl;\n  }\n\n  // Calculate new state values\n  X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n  X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;\n  X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n  X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;\n  X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n  X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;\n  X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n  X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;\n}\n\n/**\n * Rabbit stream cipher algorithm\n */\nclass RabbitAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"] {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const { iv } = this.cfg;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff)\n        | (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);\n    }\n\n    // Generate initial state values\n    this._X = [\n      K[0], (K[3] << 16) | (K[2] >>> 16),\n      K[1], (K[0] << 16) | (K[3] >>> 16),\n      K[2], (K[1] << 16) | (K[0] >>> 16),\n      K[3], (K[2] << 16) | (K[1] >>> 16),\n    ];\n    const X = this._X;\n\n    // Generate initial counter values\n    this._C = [\n      (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n      (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n      (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n      (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff),\n    ];\n    const C = this._C;\n\n    // Carry bit\n    this._b = 0;\n\n    // Iterate the system four times\n    for (let i = 0; i < 4; i += 1) {\n      nextState.call(this);\n    }\n\n    // Modify the counters\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[(i + 4) & 7];\n    }\n\n    // IV setup\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1];\n\n      // Generate four subvectors\n      const i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff)\n        | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n      const i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff)\n        | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n      const i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n      const i3 = (i2 << 16) | (i0 & 0x0000ffff);\n\n      // Modify counter values\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3;\n\n      // Iterate the system four times\n      for (let i = 0; i < 4; i += 1) {\n        nextState.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Shortcut\n    const X = this._X;\n\n    // Iterate the system\n    nextState.call(this);\n\n    // Generate four keystream words\n    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff)\n        | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);\n\n      // Encrypt\n      _M[offset + i] ^= S[i];\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n */\nconst Rabbit = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"]._createHelper(RabbitAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmFiYml0LmpzP2ZlNGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw0REFBWTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7O0FBRWhCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsNERBQVkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9yYWJiaXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBTdHJlYW1DaXBoZXIsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG4vLyBSZXVzYWJsZSBvYmplY3RzXG5jb25zdCBTID0gW107XG5jb25zdCBDXyA9IFtdO1xuY29uc3QgRyA9IFtdO1xuXG5mdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG4gIC8vIFNob3J0Y3V0c1xuICBjb25zdCBYID0gdGhpcy5fWDtcbiAgY29uc3QgQyA9IHRoaXMuX0M7XG5cbiAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBDX1tpXSA9IENbaV07XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG4gIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG4gIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBneCA9IFhbaV0gKyBDW2ldO1xuXG4gICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcbiAgICBjb25zdCBnYSA9IGd4ICYgMHhmZmZmO1xuICAgIGNvbnN0IGdiID0gZ3ggPj4+IDE2O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcbiAgICBjb25zdCBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG4gICAgY29uc3QgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cbiAgICAvLyBIaWdoIFhPUiBsb3dcbiAgICBHW2ldID0gZ2ggXiBnbDtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG4gIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcbiAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG4gIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcbiAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG4gIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcbn1cblxuLyoqXG4gKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG1cbiAqL1xuZXhwb3J0IGNsYXNzIFJhYmJpdEFsZ28gZXh0ZW5kcyBTdHJlYW1DaXBoZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDEyOCAvIDMyO1xuICAgIHRoaXMuaXZTaXplID0gNjQgLyAzMjtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IEsgPSB0aGlzLl9rZXkud29yZHM7XG4gICAgY29uc3QgeyBpdiB9ID0gdGhpcy5jZmc7XG5cbiAgICAvLyBTd2FwIGVuZGlhblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBLW2ldID0gKCgoS1tpXSA8PCA4KSB8IChLW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChLW2ldIDw8IDI0KSB8IChLW2ldID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuICAgIHRoaXMuX1ggPSBbXG4gICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcbiAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG4gICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLFxuICAgIF07XG4gICAgY29uc3QgWCA9IHRoaXMuX1g7XG5cbiAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG4gICAgdGhpcy5fQyA9IFtcbiAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG4gICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcbiAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpLFxuICAgIF07XG4gICAgY29uc3QgQyA9IHRoaXMuX0M7XG5cbiAgICAvLyBDYXJyeSBiaXRcbiAgICB0aGlzLl9iID0gMDtcblxuICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcbiAgICB9XG5cbiAgICAvLyBJViBzZXR1cFxuICAgIGlmIChpdikge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBJViA9IGl2LndvcmRzO1xuICAgICAgY29uc3QgSVZfMCA9IElWWzBdO1xuICAgICAgY29uc3QgSVZfMSA9IElWWzFdO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcbiAgICAgIGNvbnN0IGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgIGNvbnN0IGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgIGNvbnN0IGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcbiAgICAgIGNvbnN0IGkzID0gKGkyIDw8IDE2KSB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG4gICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcbiAgICAgIENbMF0gXj0gaTA7XG4gICAgICBDWzFdIF49IGkxO1xuICAgICAgQ1syXSBePSBpMjtcbiAgICAgIENbM10gXj0gaTM7XG4gICAgICBDWzRdIF49IGkwO1xuICAgICAgQ1s1XSBePSBpMTtcbiAgICAgIENbNl0gXj0gaTI7XG4gICAgICBDWzddIF49IGkzO1xuXG4gICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIGNvbnN0IF9NID0gTTtcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgWCA9IHRoaXMuX1g7XG5cbiAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cbiAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG4gICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcbiAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG4gICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblxuICAgICAgLy8gRW5jcnlwdFxuICAgICAgX01bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cbmV4cG9ydCBjb25zdCBSYWJiaXQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rabbit.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rc4.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/rc4.js ***!
  \*******************************************/
/*! exports provided: RC4Algo, RC4, RC4DropAlgo, RC4Drop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RC4Algo\", function() { return RC4Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RC4\", function() { return RC4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RC4DropAlgo\", function() { return RC4DropAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RC4Drop\", function() { return RC4Drop; });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nfunction generateKeystreamWord() {\n  // Shortcuts\n  const S = this._S;\n  let i = this._i;\n  let j = this._j;\n\n  // Generate keystream word\n  let keystreamWord = 0;\n  for (let n = 0; n < 4; n += 1) {\n    i = (i + 1) % 256;\n    j = (j + S[i]) % 256;\n\n    // Swap\n    const t = S[i];\n    S[i] = S[j];\n    S[j] = t;\n\n    keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n  }\n\n  // Update counters\n  this._i = i;\n  this._j = j;\n\n  return keystreamWord;\n}\n\n/**\n * RC4 stream cipher algorithm.\n */\nclass RC4Algo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"] {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n    const keySigBytes = key.sigBytes;\n\n    // Init sbox\n    this._S = [];\n    const S = this._S;\n    for (let i = 0; i < 256; i += 1) {\n      S[i] = i;\n    }\n\n    // Key setup\n    for (let i = 0, j = 0; i < 256; i += 1) {\n      const keyByteIndex = i % keySigBytes;\n      const keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n      j = (j + S[i] + keyByte) % 256;\n\n      // Swap\n      const t = S[i];\n      S[i] = S[j];\n      S[j] = t;\n    }\n\n    // Counters\n    this._j = 0;\n    this._i = this._j;\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    _M[offset] ^= generateKeystreamWord.call(this);\n  }\n}\nRC4Algo.keySize = 256 / 32;\nRC4Algo.ivSize = 0;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n */\nconst RC4 = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"]._createHelper(RC4Algo);\n\n/**\n * Modified RC4 stream cipher algorithm.\n */\nclass RC4DropAlgo extends RC4Algo {\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} drop The number of keystream words to drop. Default 192\n     */\n    Object.assign(this.cfg, { drop: 192 });\n  }\n\n  _doReset() {\n    super._doReset.call(this);\n\n    // Drop\n    for (let i = this.cfg.drop; i > 0; i -= 1) {\n      generateKeystreamWord.call(this);\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n */\nconst RC4Drop = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__[\"StreamCipher\"]._createHelper(RC4DropAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmM0LmpzPzYyODIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sc0JBQXNCLDREQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFlBQVksNERBQVk7O0FBRS9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0JBQWdCLDREQUFZIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmM0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgU3RyZWFtQ2lwaGVyLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkKCkge1xuICAvLyBTaG9ydGN1dHNcbiAgY29uc3QgUyA9IHRoaXMuX1M7XG4gIGxldCBpID0gdGhpcy5faTtcbiAgbGV0IGogPSB0aGlzLl9qO1xuXG4gIC8vIEdlbmVyYXRlIGtleXN0cmVhbSB3b3JkXG4gIGxldCBrZXlzdHJlYW1Xb3JkID0gMDtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA0OyBuICs9IDEpIHtcbiAgICBpID0gKGkgKyAxKSAlIDI1NjtcbiAgICBqID0gKGogKyBTW2ldKSAlIDI1NjtcblxuICAgIC8vIFN3YXBcbiAgICBjb25zdCB0ID0gU1tpXTtcbiAgICBTW2ldID0gU1tqXTtcbiAgICBTW2pdID0gdDtcblxuICAgIGtleXN0cmVhbVdvcmQgfD0gU1soU1tpXSArIFNbal0pICUgMjU2XSA8PCAoMjQgLSBuICogOCk7XG4gIH1cblxuICAvLyBVcGRhdGUgY291bnRlcnNcbiAgdGhpcy5faSA9IGk7XG4gIHRoaXMuX2ogPSBqO1xuXG4gIHJldHVybiBrZXlzdHJlYW1Xb3JkO1xufVxuXG4vKipcbiAqIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJDNEFsZ28gZXh0ZW5kcyBTdHJlYW1DaXBoZXIge1xuICBfZG9SZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9rZXk7XG4gICAgY29uc3Qga2V5V29yZHMgPSBrZXkud29yZHM7XG4gICAgY29uc3Qga2V5U2lnQnl0ZXMgPSBrZXkuc2lnQnl0ZXM7XG5cbiAgICAvLyBJbml0IHNib3hcbiAgICB0aGlzLl9TID0gW107XG4gICAgY29uc3QgUyA9IHRoaXMuX1M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAgICAgU1tpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gS2V5IHNldHVwXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGtleUJ5dGVJbmRleCA9IGkgJSBrZXlTaWdCeXRlcztcbiAgICAgIGNvbnN0IGtleUJ5dGUgPSAoa2V5V29yZHNba2V5Qnl0ZUluZGV4ID4+PiAyXSA+Pj4gKDI0IC0gKGtleUJ5dGVJbmRleCAlIDQpICogOCkpICYgMHhmZjtcblxuICAgICAgaiA9IChqICsgU1tpXSArIGtleUJ5dGUpICUgMjU2O1xuXG4gICAgICAvLyBTd2FwXG4gICAgICBjb25zdCB0ID0gU1tpXTtcbiAgICAgIFNbaV0gPSBTW2pdO1xuICAgICAgU1tqXSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gQ291bnRlcnNcbiAgICB0aGlzLl9qID0gMDtcbiAgICB0aGlzLl9pID0gdGhpcy5fajtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICBfTVtvZmZzZXRdIF49IGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuICB9XG59XG5SQzRBbGdvLmtleVNpemUgPSAyNTYgLyAzMjtcblJDNEFsZ28uaXZTaXplID0gMDtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cbmV4cG9ydCBjb25zdCBSQzQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzRBbGdvKTtcblxuLyoqXG4gKiBNb2RpZmllZCBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBSQzREcm9wQWxnbyBleHRlbmRzIFJDNEFsZ28ge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJvcCBUaGUgbnVtYmVyIG9mIGtleXN0cmVhbSB3b3JkcyB0byBkcm9wLiBEZWZhdWx0IDE5MlxuICAgICAqL1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jZmcsIHsgZHJvcDogMTkyIH0pO1xuICB9XG5cbiAgX2RvUmVzZXQoKSB7XG4gICAgc3VwZXIuX2RvUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgIC8vIERyb3BcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jZmcuZHJvcDsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0RHJvcC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNERyb3AuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cbmV4cG9ydCBjb25zdCBSQzREcm9wID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0RHJvcEFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rc4.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/ripemd160.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/ripemd160.js ***!
  \*************************************************/
/*! exports provided: RIPEMD160Algo, RIPEMD160, HmacRIPEMD160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPEMD160Algo\", function() { return RIPEMD160Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPEMD160\", function() { return RIPEMD160; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacRIPEMD160\", function() { return HmacRIPEMD160; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/** @preserve\n(c) 2012 by Cédric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list\n    of conditions and the following disclaimer in the documentation and/or other materials\n    provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\nWAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n\n// Constants table\nconst _zl = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);\nconst _zr = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);\nconst _sl = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);\nconst _sr = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);\n\nconst _hl = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\nconst _hr = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\nconst f1 = (x, y, z) => (x) ^ (y) ^ (z);\n\nconst f2 = (x, y, z) => ((x) & (y)) | ((~x) & (z));\n\nconst f3 = (x, y, z) => ((x) | (~(y))) ^ (z);\n\nconst f4 = (x, y, z) => ((x) & (z)) | ((y) & (~(z)));\n\nconst f5 = (x, y, z) => (x) ^ ((y) | (~(z)));\n\nconst rotl = (x, n) => (x << n) | (x >>> (32 - n));\n\n/**\n * RIPEMD160 hash algorithm.\n */\nclass RIPEMD160Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  _doReset() {\n    this._hash = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = _M[offset_i];\n\n      // Swap\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n    // Shortcut\n    const H = this._hash.words;\n    const hl = _hl.words;\n    const hr = _hr.words;\n    const zl = _zl.words;\n    const zr = _zr.words;\n    const sl = _sl.words;\n    const sr = _sr.words;\n\n    // Working variables\n    let al = H[0];\n    let bl = H[1];\n    let cl = H[2];\n    let dl = H[3];\n    let el = H[4];\n    let ar = H[0];\n    let br = H[1];\n    let cr = H[2];\n    let dr = H[3];\n    let er = H[4];\n\n    // Computation\n    let t;\n    for (let i = 0; i < 80; i += 1) {\n      t = (al + _M[offset + zl[i]]) | 0;\n      if (i < 16) {\n        t += f1(bl, cl, dl) + hl[0];\n      } else if (i < 32) {\n        t += f2(bl, cl, dl) + hl[1];\n      } else if (i < 48) {\n        t += f3(bl, cl, dl) + hl[2];\n      } else if (i < 64) {\n        t += f4(bl, cl, dl) + hl[3];\n      } else { // if (i<80) {\n        t += f5(bl, cl, dl) + hl[4];\n      }\n      t |= 0;\n      t = rotl(t, sl[i]);\n      t = (t + el) | 0;\n      al = el;\n      el = dl;\n      dl = rotl(cl, 10);\n      cl = bl;\n      bl = t;\n\n      t = (ar + _M[offset + zr[i]]) | 0;\n      if (i < 16) {\n        t += f5(br, cr, dr) + hr[0];\n      } else if (i < 32) {\n        t += f4(br, cr, dr) + hr[1];\n      } else if (i < 48) {\n        t += f3(br, cr, dr) + hr[2];\n      } else if (i < 64) {\n        t += f2(br, cr, dr) + hr[3];\n      } else { // if (i<80) {\n        t += f1(br, cr, dr) + hr[4];\n      }\n      t |= 0;\n      t = rotl(t, sr[i]);\n      t = (t + er) | 0;\n      ar = er;\n      er = dr;\n      dr = rotl(cr, 10);\n      cr = br;\n      br = t;\n    }\n    // Intermediate hash value\n    t = (H[1] + cl + dr) | 0;\n    H[1] = (H[2] + dl + er) | 0;\n    H[2] = (H[3] + el + ar) | 0;\n    H[3] = (H[4] + al + br) | 0;\n    H[4] = (H[0] + bl + cr) | 0;\n    H[0] = t;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)\n    );\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 5; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      // Swap\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.RIPEMD160('message');\n *     var hash = CryptoJS.RIPEMD160(wordArray);\n */\nconst RIPEMD160 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(RIPEMD160Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n */\nconst HmacRIPEMD160 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(RIPEMD160Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmlwZW1kMTYwLmpzP2UxYzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBS21COztBQUVuQjtBQUNBLFlBQVksa0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFTO0FBQ3JCLFlBQVksa0RBQVM7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QiwrQ0FBTTtBQUN6QztBQUNBLGlCQUFpQixrREFBUztBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtCQUFrQiwrQ0FBTTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IsK0NBQU0iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9yaXBlbWQxNjAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZFxucHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1Ncbk9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SXG5DT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG5EQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG5EQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbldIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTllcbldBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHtcbiAgV29yZEFycmF5LFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbi8vIENvbnN0YW50cyB0YWJsZVxuY29uc3QgX3psID0gV29yZEFycmF5LmNyZWF0ZShbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNdKTtcbmNvbnN0IF96ciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXSk7XG5jb25zdCBfc2wgPSBXb3JkQXJyYXkuY3JlYXRlKFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZdKTtcbmNvbnN0IF9zciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMV0pO1xuXG5jb25zdCBfaGwgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXSk7XG5jb25zdCBfaHIgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXSk7XG5cbmNvbnN0IGYxID0gKHgsIHksIHopID0+ICh4KSBeICh5KSBeICh6KTtcblxuY29uc3QgZjIgPSAoeCwgeSwgeikgPT4gKCh4KSAmICh5KSkgfCAoKH54KSAmICh6KSk7XG5cbmNvbnN0IGYzID0gKHgsIHksIHopID0+ICgoeCkgfCAofih5KSkpIF4gKHopO1xuXG5jb25zdCBmNCA9ICh4LCB5LCB6KSA9PiAoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpO1xuXG5jb25zdCBmNSA9ICh4LCB5LCB6KSA9PiAoeCkgXiAoKHkpIHwgKH4oeikpKTtcblxuY29uc3Qgcm90bCA9ICh4LCBuKSA9PiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSk7XG5cbi8qKlxuICogUklQRU1EMTYwIGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgUklQRU1EMTYwQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBXb3JkQXJyYXkuY3JlYXRlKFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU3dhcCBlbmRpYW5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgICAgY29uc3QgTV9vZmZzZXRfaSA9IF9NW29mZnNldF9pXTtcblxuICAgICAgLy8gU3dhcFxuICAgICAgX01bb2Zmc2V0X2ldID0gKFxuICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICAgIHwgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgSCA9IHRoaXMuX2hhc2gud29yZHM7XG4gICAgY29uc3QgaGwgPSBfaGwud29yZHM7XG4gICAgY29uc3QgaHIgPSBfaHIud29yZHM7XG4gICAgY29uc3QgemwgPSBfemwud29yZHM7XG4gICAgY29uc3QgenIgPSBfenIud29yZHM7XG4gICAgY29uc3Qgc2wgPSBfc2wud29yZHM7XG4gICAgY29uc3Qgc3IgPSBfc3Iud29yZHM7XG5cbiAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICAgIGxldCBhbCA9IEhbMF07XG4gICAgbGV0IGJsID0gSFsxXTtcbiAgICBsZXQgY2wgPSBIWzJdO1xuICAgIGxldCBkbCA9IEhbM107XG4gICAgbGV0IGVsID0gSFs0XTtcbiAgICBsZXQgYXIgPSBIWzBdO1xuICAgIGxldCBiciA9IEhbMV07XG4gICAgbGV0IGNyID0gSFsyXTtcbiAgICBsZXQgZHIgPSBIWzNdO1xuICAgIGxldCBlciA9IEhbNF07XG5cbiAgICAvLyBDb21wdXRhdGlvblxuICAgIGxldCB0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgICAgdCA9IChhbCArIF9NW29mZnNldCArIHpsW2ldXSkgfCAwO1xuICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF07XG4gICAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICB0ICs9IGYyKGJsLCBjbCwgZGwpICsgaGxbMV07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgICB0ICs9IGYzKGJsLCBjbCwgZGwpICsgaGxbMl07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM107XG4gICAgICB9IGVsc2UgeyAvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF07XG4gICAgICB9XG4gICAgICB0IHw9IDA7XG4gICAgICB0ID0gcm90bCh0LCBzbFtpXSk7XG4gICAgICB0ID0gKHQgKyBlbCkgfCAwO1xuICAgICAgYWwgPSBlbDtcbiAgICAgIGVsID0gZGw7XG4gICAgICBkbCA9IHJvdGwoY2wsIDEwKTtcbiAgICAgIGNsID0gYmw7XG4gICAgICBibCA9IHQ7XG5cbiAgICAgIHQgPSAoYXIgKyBfTVtvZmZzZXQgKyB6cltpXV0pIHwgMDtcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgdCArPSBmNShiciwgY3IsIGRyKSArIGhyWzBdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgICAgdCArPSBmNChiciwgY3IsIGRyKSArIGhyWzFdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgICAgdCArPSBmMihiciwgY3IsIGRyKSArIGhyWzNdO1xuICAgICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcbiAgICAgICAgdCArPSBmMShiciwgY3IsIGRyKSArIGhyWzRdO1xuICAgICAgfVxuICAgICAgdCB8PSAwO1xuICAgICAgdCA9IHJvdGwodCwgc3JbaV0pO1xuICAgICAgdCA9ICh0ICsgZXIpIHwgMDtcbiAgICAgIGFyID0gZXI7XG4gICAgICBlciA9IGRyO1xuICAgICAgZHIgPSByb3RsKGNyLCAxMCk7XG4gICAgICBjciA9IGJyO1xuICAgICAgYnIgPSB0O1xuICAgIH1cbiAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgIHQgPSAoSFsxXSArIGNsICsgZHIpIHwgMDtcbiAgICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKSB8IDA7XG4gICAgSFsyXSA9IChIWzNdICsgZWwgKyBhcikgfCAwO1xuICAgIEhbM10gPSAoSFs0XSArIGFsICsgYnIpIHwgMDtcbiAgICBIWzRdID0gKEhbMF0gKyBibCArIGNyKSB8IDA7XG4gICAgSFswXSA9IHQ7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG4gICAgLy8gQWRkIHBhZGRpbmdcbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIChuQml0c0xlZnQgJSAzMikpO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICAgICk7XG4gICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG4gICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcbiAgICBjb25zdCBIID0gaGFzaC53b3JkcztcblxuICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBIX2kgPSBIW2ldO1xuXG4gICAgICAvLyBTd2FwXG4gICAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihSSVBFTUQxNjBBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNSSVBFTUQxNjAobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoUklQRU1EMTYwQWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/ripemd160.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha1.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha1.js ***!
  \********************************************/
/*! exports provided: SHA1Algo, SHA1, HmacSHA1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA1Algo\", function() { return SHA1Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA1\", function() { return SHA1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA1\", function() { return HmacSHA1; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Reusable object\nconst W = [];\n\n/**\n * SHA-1 hash algorithm.\n */\nclass SHA1Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"]([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n      0xc3d2e1f0,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const H = this._hash.words;\n\n    // Working variables\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    // Computation\n    for (let i = 0; i < 80; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n        W[i] = (n << 1) | (n >>> 31);\n      }\n\n      let t = ((a << 5) | (a >>> 27)) + e + W[i];\n      if (i < 20) {\n        t += ((b & c) | (~b & d)) + 0x5a827999;\n      } else if (i < 40) {\n        t += (b ^ c ^ d) + 0x6ed9eba1;\n      } else if (i < 60) {\n        t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n      } else /* if (i < 80) */ {\n        t += (b ^ c ^ d) - 0x359d3e2a;\n      }\n\n      e = d;\n      d = c;\n      c = (b << 30) | (b >>> 2);\n      b = a;\n      a = t;\n    }\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n    H[4] = (H[4] + e) | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Return final computed hash\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA1('message');\n *     var hash = CryptoJS.SHA1(wordArray);\n */\nconst SHA1 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(SHA1Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA1(message, key);\n */\nconst HmacSHA1 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(SHA1Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMS5qcz9iZDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLCtDQUFNO0FBQ3BDO0FBQ0EscUJBQXFCLGtEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsK0NBQU07O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUJBQWlCLCtDQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbiAgSGFzaGVyLFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG4vLyBSZXVzYWJsZSBvYmplY3RcbmNvbnN0IFcgPSBbXTtcblxuLyoqXG4gKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTFBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkoW1xuICAgICAgMHg2NzQ1MjMwMSxcbiAgICAgIDB4ZWZjZGFiODksXG4gICAgICAweDk4YmFkY2ZlLFxuICAgICAgMHgxMDMyNTQ3NixcbiAgICAgIDB4YzNkMmUxZjAsXG4gICAgXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBIID0gdGhpcy5faGFzaC53b3JkcztcblxuICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gICAgbGV0IGEgPSBIWzBdO1xuICAgIGxldCBiID0gSFsxXTtcbiAgICBsZXQgYyA9IEhbMl07XG4gICAgbGV0IGQgPSBIWzNdO1xuICAgIGxldCBlID0gSFs0XTtcblxuICAgIC8vIENvbXB1dGF0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG4gICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG4gICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcbiAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG4gICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuICAgICAgfVxuXG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG4gICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcbiAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG4gICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSAobkJpdHNMZWZ0ICUgMzIpKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG4gICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgIHJldHVybiB0aGlzLl9oYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBTSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMUFsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTFBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha1.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha224.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha224.js ***!
  \**********************************************/
/*! exports provided: SHA224Algo, SHA224, HmacSHA224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA224Algo\", function() { return SHA224Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA224\", function() { return SHA224; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA224\", function() { return HmacSHA224; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha256.js */ \"./node_modules/crypto-es/lib/sha256.js\");\n\n\n\n/**\n * SHA-224 hash algorithm.\n */\nclass SHA224Algo extends _sha256_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA256Algo\"] {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"]([\n      0xc1059ed8,\n      0x367cd507,\n      0x3070dd17,\n      0xf70e5939,\n      0xffc00b31,\n      0x68581511,\n      0x64f98fa7,\n      0xbefa4fa4,\n    ]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 4;\n\n    return hash;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA224('message');\n *     var hash = CryptoJS.SHA224(wordArray);\n */\nconst SHA224 = _sha256_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA256Algo\"]._createHelper(SHA224Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA224(message, key);\n */\nconst HmacSHA224 = _sha256_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA256Algo\"]._createHmacHelper(SHA224Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMjI0LmpzPzE0OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNDO0FBQ0c7O0FBRXpDO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixxREFBVTtBQUMxQztBQUNBLHFCQUFxQixrREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSxxREFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIscURBQVUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9zaGEyMjQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXb3JkQXJyYXkgfSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IHsgU0hBMjU2QWxnbyB9IGZyb20gJy4vc2hhMjU2LmpzJztcblxuLyoqXG4gKiBTSEEtMjI0IGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgU0hBMjI0QWxnbyBleHRlbmRzIFNIQTI1NkFsZ28ge1xuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShbXG4gICAgICAweGMxMDU5ZWQ4LFxuICAgICAgMHgzNjdjZDUwNyxcbiAgICAgIDB4MzA3MGRkMTcsXG4gICAgICAweGY3MGU1OTM5LFxuICAgICAgMHhmZmMwMGIzMSxcbiAgICAgIDB4Njg1ODE1MTEsXG4gICAgICAweDY0Zjk4ZmE3LFxuICAgICAgMHhiZWZhNGZhNCxcbiAgICBdKTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIGNvbnN0IGhhc2ggPSBzdXBlci5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG4gICAgaGFzaC5zaWdCeXRlcyAtPSA0O1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBTSEEyMjQgPSBTSEEyNTZBbGdvLl9jcmVhdGVIZWxwZXIoU0hBMjI0QWxnbyk7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjI0KG1lc3NhZ2UsIGtleSk7XG4gKi9cbmV4cG9ydCBjb25zdCBIbWFjU0hBMjI0ID0gU0hBMjU2QWxnby5fY3JlYXRlSG1hY0hlbHBlcihTSEEyMjRBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha224.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha256.js ***!
  \**********************************************/
/*! exports provided: SHA256Algo, SHA256, HmacSHA256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA256Algo\", function() { return SHA256Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA256\", function() { return SHA256; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA256\", function() { return HmacSHA256; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Initialization and round constants tables\nconst H = [];\nconst K = [];\n\n// Compute constants\nconst isPrime = (n) => {\n  const sqrtN = Math.sqrt(n);\n  for (let factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getFractionalBits = n => ((n - (n | 0)) * 0x100000000) | 0;\n\nlet n = 2;\nlet nPrime = 0;\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(n ** (1 / 2));\n    }\n    K[nPrime] = getFractionalBits(n ** (1 / 3));\n\n    nPrime += 1;\n  }\n\n  n += 1;\n}\n\n// Reusable object\nconst W = [];\n\n/**\n * SHA-256 hash algorithm.\n */\nclass SHA256Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"](H.slice(0));\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const _H = this._hash.words;\n\n    // Working variables\n    let a = _H[0];\n    let b = _H[1];\n    let c = _H[2];\n    let d = _H[3];\n    let e = _H[4];\n    let f = _H[5];\n    let g = _H[6];\n    let h = _H[7];\n\n    // Computation\n    for (let i = 0; i < 64; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = ((gamma0x << 25) | (gamma0x >>> 7))\n          ^ ((gamma0x << 14) | (gamma0x >>> 18))\n          ^ (gamma0x >>> 3);\n\n        const gamma1x = W[i - 2];\n        const gamma1 = ((gamma1x << 15) | (gamma1x >>> 17))\n          ^ ((gamma1x << 13) | (gamma1x >>> 19))\n          ^ (gamma1x >>> 10);\n\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n\n      const ch = (e & f) ^ (~e & g);\n      const maj = (a & b) ^ (a & c) ^ (b & c);\n\n      const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n      const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n\n      h = g;\n      g = f;\n      f = e;\n      e = (d + t1) | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = (t1 + t2) | 0;\n    }\n\n    // Intermediate hash value\n    _H[0] = (_H[0] + a) | 0;\n    _H[1] = (_H[1] + b) | 0;\n    _H[2] = (_H[2] + c) | 0;\n    _H[3] = (_H[3] + d) | 0;\n    _H[4] = (_H[4] + e) | 0;\n    _H[5] = (_H[5] + f) | 0;\n    _H[6] = (_H[6] + g) | 0;\n    _H[7] = (_H[7] + h) | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Return final computed hash\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\nconst SHA256 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(SHA256Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\nconst HmacSHA256 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(SHA256Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMjU2LmpzPzRkZTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QiwrQ0FBTTtBQUN0QztBQUNBLHFCQUFxQixrREFBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwrQ0FBTTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsK0NBQU0iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9zaGEyNTYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG4gIEhhc2hlcixcbn0gZnJvbSAnLi9jb3JlLmpzJztcblxuLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcbmNvbnN0IEggPSBbXTtcbmNvbnN0IEsgPSBbXTtcblxuLy8gQ29tcHV0ZSBjb25zdGFudHNcbmNvbnN0IGlzUHJpbWUgPSAobikgPT4ge1xuICBjb25zdCBzcXJ0TiA9IE1hdGguc3FydChuKTtcbiAgZm9yIChsZXQgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IgKz0gMSkge1xuICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBnZXRGcmFjdGlvbmFsQml0cyA9IG4gPT4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXG5sZXQgbiA9IDI7XG5sZXQgblByaW1lID0gMDtcbndoaWxlIChuUHJpbWUgPCA2NCkge1xuICBpZiAoaXNQcmltZShuKSkge1xuICAgIGlmIChuUHJpbWUgPCA4KSB7XG4gICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhuICoqICgxIC8gMikpO1xuICAgIH1cbiAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhuICoqICgxIC8gMykpO1xuXG4gICAgblByaW1lICs9IDE7XG4gIH1cblxuICBuICs9IDE7XG59XG5cbi8vIFJldXNhYmxlIG9iamVjdFxuY29uc3QgVyA9IFtdO1xuXG4vKipcbiAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBTSEEyNTZBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkoSC5zbGljZSgwKSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBfSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cbiAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICAgIGxldCBhID0gX0hbMF07XG4gICAgbGV0IGIgPSBfSFsxXTtcbiAgICBsZXQgYyA9IF9IWzJdO1xuICAgIGxldCBkID0gX0hbM107XG4gICAgbGV0IGUgPSBfSFs0XTtcbiAgICBsZXQgZiA9IF9IWzVdO1xuICAgIGxldCBnID0gX0hbNl07XG4gICAgbGV0IGggPSBfSFs3XTtcblxuICAgIC8vIENvbXB1dGF0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGdhbW1hMHggPSBXW2kgLSAxNV07XG4gICAgICAgIGNvbnN0IGdhbW1hMCA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpXG4gICAgICAgICAgXiAoKGdhbW1hMHggPDwgMTQpIHwgKGdhbW1hMHggPj4+IDE4KSlcbiAgICAgICAgICBeIChnYW1tYTB4ID4+PiAzKTtcblxuICAgICAgICBjb25zdCBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgIGNvbnN0IGdhbW1hMSA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKVxuICAgICAgICAgIF4gKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpXG4gICAgICAgICAgXiAoZ2FtbWExeCA+Pj4gMTApO1xuXG4gICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2ggPSAoZSAmIGYpIF4gKH5lICYgZyk7XG4gICAgICBjb25zdCBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cbiAgICAgIGNvbnN0IHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuICAgICAgY29uc3Qgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgfCAoZSA+Pj4gMjUpKTtcblxuICAgICAgY29uc3QgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcbiAgICAgIGNvbnN0IHQyID0gc2lnbWEwICsgbWFqO1xuXG4gICAgICBoID0gZztcbiAgICAgIGcgPSBmO1xuICAgICAgZiA9IGU7XG4gICAgICBlID0gKGQgKyB0MSkgfCAwO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICBfSFswXSA9IChfSFswXSArIGEpIHwgMDtcbiAgICBfSFsxXSA9IChfSFsxXSArIGIpIHwgMDtcbiAgICBfSFsyXSA9IChfSFsyXSArIGMpIHwgMDtcbiAgICBfSFszXSA9IChfSFszXSArIGQpIHwgMDtcbiAgICBfSFs0XSA9IChfSFs0XSArIGUpIHwgMDtcbiAgICBfSFs1XSA9IChfSFs1XSArIGYpIHwgMDtcbiAgICBfSFs2XSA9IChfSFs2XSArIGcpIHwgMDtcbiAgICBfSFs3XSA9IChfSFs3XSArIGgpIHwgMDtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cbiAgICBjb25zdCBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG4gICAgY29uc3QgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cbiAgICAvLyBBZGQgcGFkZGluZ1xuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gKG5CaXRzTGVmdCAlIDMyKSk7XG4gICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1NkFsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuICovXG5leHBvcnQgY29uc3QgSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTZBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha256.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha3.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha3.js ***!
  \********************************************/
/*! exports provided: SHA3Algo, SHA3, HmacSHA3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA3Algo\", function() { return SHA3Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA3\", function() { return SHA3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA3\", function() { return HmacSHA3; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n\n\n\n// Constants tables\nconst RHO_OFFSETS = [];\nconst PI_INDEXES = [];\nconst ROUND_CONSTANTS = [];\n\n// Compute Constants\n// Compute rho offset constants\nlet _x = 1;\nlet _y = 0;\nfor (let t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = ((t + 1) * (t + 2) / 2) % 64;\n\n  const newX = _y % 5;\n  const newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n}\n\n// Compute pi index constants\nfor (let x = 0; x < 5; x += 1) {\n  for (let y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n  }\n}\n\n// Compute round constants\nlet LFSR = 0x01;\nfor (let i = 0; i < 24; i += 1) {\n  let roundConstantMsw = 0;\n  let roundConstantLsw = 0;\n\n  for (let j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      const bitPosition = (1 << j) - 1;\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else /* if (bitPosition >= 32) */ {\n        roundConstantMsw ^= 1 << (bitPosition - 32);\n      }\n    }\n\n    // Compute next LFSR\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = (LFSR << 1) ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"].create(roundConstantMsw, roundConstantLsw);\n}\n\n// Reusable objects for temporary values\nconst T = [];\nfor (let i = 0; i < 25; i += 1) {\n  T[i] = _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"].create();\n}\n\n/**\n * SHA-3 hash algorithm.\n */\nclass SHA3Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  constructor(cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    super(Object.assign(\n      { outputLength: 512 },\n      cfg,\n    ));\n  }\n\n  _doReset() {\n    this._state = [];\n    const state = this._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"]();\n    }\n\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2;\n\n    // Absorb\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1];\n\n      // Swap endian\n      M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff)\n        | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\n      M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff)\n        | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\n\n      // Absorb message into state\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    }\n\n    // Rounds\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        }\n\n        // Temporary values\n        const Tx = T[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T[(x + 4) % 5];\n        const Tx1 = T[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low;\n\n        // Mix surrounding columns\n        const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n        const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      }\n\n      // Rho Pi\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw;\n        let tLsw;\n\n        // Shortcuts\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex];\n\n        // Rotate lanes\n        if (rhoOffset < 32) {\n          tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n          tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n        } else /* if (rhoOffset >= 32) */ {\n          tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n          tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n        }\n\n        // Transpose lanes\n        const TPiLane = T[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      }\n\n      // Rho pi at x = y = 0\n      const T0 = T[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low;\n\n      // Chi\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T[laneIndex];\n          const Tx1Lane = T[((x + 1) % 5) + 5 * y];\n          const Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n          // Mix rows\n          lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n          lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\n        }\n      }\n\n      // Iota\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - (nBitsLeft % 32));\n    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength / 8;\n    const outputLengthLanes = outputLengthBytes / 8;\n\n    // Squeeze\n    const hashWords = [];\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low;\n\n      // Swap endian\n      laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff)\n        | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\n      laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff)\n        | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\n\n      // Squeeze state to retrieve hash\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    }\n\n    // Return final computed hash\n    return new _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"](hashWords, outputLengthBytes);\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n\n    clone._state = this._state.slice(0);\n    const state = clone._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = state[i].clone();\n    }\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\nconst SHA3 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(SHA3Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\nconst HmacSHA3 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(SHA3Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMy5qcz8yNTk4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdtQjtBQUNxQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG9EQUFPO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsU0FBUyxvREFBTztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDTyx1QkFBdUIsK0NBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixvREFBTztBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtEQUFTO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLCtDQUFNOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlCQUFpQiwrQ0FBTSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3NoYTMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG4gIEhhc2hlcixcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IFg2NFdvcmQgfSBmcm9tICcuL3g2NC1jb3JlLmpzJztcblxuLy8gQ29uc3RhbnRzIHRhYmxlc1xuY29uc3QgUkhPX09GRlNFVFMgPSBbXTtcbmNvbnN0IFBJX0lOREVYRVMgPSBbXTtcbmNvbnN0IFJPVU5EX0NPTlNUQU5UUyA9IFtdO1xuXG4vLyBDb21wdXRlIENvbnN0YW50c1xuLy8gQ29tcHV0ZSByaG8gb2Zmc2V0IGNvbnN0YW50c1xubGV0IF94ID0gMTtcbmxldCBfeSA9IDA7XG5mb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0ICs9IDEpIHtcbiAgUkhPX09GRlNFVFNbX3ggKyA1ICogX3ldID0gKCh0ICsgMSkgKiAodCArIDIpIC8gMikgJSA2NDtcblxuICBjb25zdCBuZXdYID0gX3kgJSA1O1xuICBjb25zdCBuZXdZID0gKDIgKiBfeCArIDMgKiBfeSkgJSA1O1xuICBfeCA9IG5ld1g7XG4gIF95ID0gbmV3WTtcbn1cblxuLy8gQ29tcHV0ZSBwaSBpbmRleCBjb25zdGFudHNcbmZvciAobGV0IHggPSAwOyB4IDwgNTsgeCArPSAxKSB7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSArPSAxKSB7XG4gICAgUElfSU5ERVhFU1t4ICsgNSAqIHldID0geSArICgoMiAqIHggKyAzICogeSkgJSA1KSAqIDU7XG4gIH1cbn1cblxuLy8gQ29tcHV0ZSByb3VuZCBjb25zdGFudHNcbmxldCBMRlNSID0gMHgwMTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkgKz0gMSkge1xuICBsZXQgcm91bmRDb25zdGFudE1zdyA9IDA7XG4gIGxldCByb3VuZENvbnN0YW50THN3ID0gMDtcblxuICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGogKz0gMSkge1xuICAgIGlmIChMRlNSICYgMHgwMSkge1xuICAgICAgY29uc3QgYml0UG9zaXRpb24gPSAoMSA8PCBqKSAtIDE7XG4gICAgICBpZiAoYml0UG9zaXRpb24gPCAzMikge1xuICAgICAgICByb3VuZENvbnN0YW50THN3IF49IDEgPDwgYml0UG9zaXRpb247XG4gICAgICB9IGVsc2UgLyogaWYgKGJpdFBvc2l0aW9uID49IDMyKSAqLyB7XG4gICAgICAgIHJvdW5kQ29uc3RhbnRNc3cgXj0gMSA8PCAoYml0UG9zaXRpb24gLSAzMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBuZXh0IExGU1JcbiAgICBpZiAoTEZTUiAmIDB4ODApIHtcbiAgICAgIC8vIFByaW1pdGl2ZSBwb2x5bm9taWFsIG92ZXIgR0YoMik6IHheOCArIHheNiArIHheNSArIHheNCArIDFcbiAgICAgIExGU1IgPSAoTEZTUiA8PCAxKSBeIDB4NzE7XG4gICAgfSBlbHNlIHtcbiAgICAgIExGU1IgPDw9IDE7XG4gICAgfVxuICB9XG5cbiAgUk9VTkRfQ09OU1RBTlRTW2ldID0gWDY0V29yZC5jcmVhdGUocm91bmRDb25zdGFudE1zdywgcm91bmRDb25zdGFudExzdyk7XG59XG5cbi8vIFJldXNhYmxlIG9iamVjdHMgZm9yIHRlbXBvcmFyeSB2YWx1ZXNcbmNvbnN0IFQgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkgKz0gMSkge1xuICBUW2ldID0gWDY0V29yZC5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBTSEEtMyBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTNBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG91dHB1dExlbmd0aFxuICAgICAqICAgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIG91dHB1dCBoYXNoLlxuICAgICAqICAgT25seSB2YWx1ZXMgcGVybWl0dGVkIGFyZTogMjI0LCAyNTYsIDM4NCwgNTEyLlxuICAgICAqICAgRGVmYXVsdDogNTEyXG4gICAgICovXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgb3V0cHV0TGVuZ3RoOiA1MTIgfSxcbiAgICAgIGNmZyxcbiAgICApKTtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX3N0YXRlID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlW2ldID0gbmV3IFg2NFdvcmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrU2l6ZSA9ICgxNjAwIC0gMiAqIHRoaXMuY2ZnLm91dHB1dExlbmd0aCkgLyAzMjtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGNvbnN0IG5CbG9ja1NpemVMYW5lcyA9IHRoaXMuYmxvY2tTaXplIC8gMjtcblxuICAgIC8vIEFic29yYlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkJsb2NrU2l6ZUxhbmVzOyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgbGV0IE0yaSA9IE1bb2Zmc2V0ICsgMiAqIGldO1xuICAgICAgbGV0IE0yaTEgPSBNW29mZnNldCArIDIgKiBpICsgMV07XG5cbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBNMmkgPSAoKChNMmkgPDwgOCkgfCAoTTJpID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChNMmkgPDwgMjQpIHwgKE0yaSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG4gICAgICBNMmkxID0gKCgoTTJpMSA8PCA4KSB8IChNMmkxID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChNMmkxIDw8IDI0KSB8IChNMmkxID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblxuICAgICAgLy8gQWJzb3JiIG1lc3NhZ2UgaW50byBzdGF0ZVxuICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW2ldO1xuICAgICAgbGFuZS5oaWdoIF49IE0yaTE7XG4gICAgICBsYW5lLmxvdyBePSBNMmk7XG4gICAgfVxuXG4gICAgLy8gUm91bmRzXG4gICAgZm9yIChsZXQgcm91bmQgPSAwOyByb3VuZCA8IDI0OyByb3VuZCArPSAxKSB7XG4gICAgICAvLyBUaGV0YVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA1OyB4ICs9IDEpIHtcbiAgICAgICAgLy8gTWl4IGNvbHVtbiBsYW5lc1xuICAgICAgICBsZXQgdE1zdyA9IDA7XG4gICAgICAgIGxldCB0THN3ID0gMDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1OyB5ICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcbiAgICAgICAgICB0TXN3IF49IGxhbmUuaGlnaDtcbiAgICAgICAgICB0THN3IF49IGxhbmUubG93O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVtcG9yYXJ5IHZhbHVlc1xuICAgICAgICBjb25zdCBUeCA9IFRbeF07XG4gICAgICAgIFR4LmhpZ2ggPSB0TXN3O1xuICAgICAgICBUeC5sb3cgPSB0THN3O1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA1OyB4ICs9IDEpIHtcbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIGNvbnN0IFR4NCA9IFRbKHggKyA0KSAlIDVdO1xuICAgICAgICBjb25zdCBUeDEgPSBUWyh4ICsgMSkgJSA1XTtcbiAgICAgICAgY29uc3QgVHgxTXN3ID0gVHgxLmhpZ2g7XG4gICAgICAgIGNvbnN0IFR4MUxzdyA9IFR4MS5sb3c7XG5cbiAgICAgICAgLy8gTWl4IHN1cnJvdW5kaW5nIGNvbHVtbnNcbiAgICAgICAgY29uc3QgdE1zdyA9IFR4NC5oaWdoIF4gKChUeDFNc3cgPDwgMSkgfCAoVHgxTHN3ID4+PiAzMSkpO1xuICAgICAgICBjb25zdCB0THN3ID0gVHg0LmxvdyBeICgoVHgxTHN3IDw8IDEpIHwgKFR4MU1zdyA+Pj4gMzEpKTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1OyB5ICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcbiAgICAgICAgICBsYW5lLmhpZ2ggXj0gdE1zdztcbiAgICAgICAgICBsYW5lLmxvdyBePSB0THN3O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJobyBQaVxuICAgICAgZm9yIChsZXQgbGFuZUluZGV4ID0gMTsgbGFuZUluZGV4IDwgMjU7IGxhbmVJbmRleCArPSAxKSB7XG4gICAgICAgIGxldCB0TXN3O1xuICAgICAgICBsZXQgdExzdztcblxuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG4gICAgICAgIGNvbnN0IGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG4gICAgICAgIGNvbnN0IGxhbmVMc3cgPSBsYW5lLmxvdztcbiAgICAgICAgY29uc3QgcmhvT2Zmc2V0ID0gUkhPX09GRlNFVFNbbGFuZUluZGV4XTtcblxuICAgICAgICAvLyBSb3RhdGUgbGFuZXNcbiAgICAgICAgaWYgKHJob09mZnNldCA8IDMyKSB7XG4gICAgICAgICAgdE1zdyA9IChsYW5lTXN3IDw8IHJob09mZnNldCkgfCAobGFuZUxzdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG4gICAgICAgICAgdExzdyA9IChsYW5lTHN3IDw8IHJob09mZnNldCkgfCAobGFuZU1zdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG4gICAgICAgIH0gZWxzZSAvKiBpZiAocmhvT2Zmc2V0ID49IDMyKSAqLyB7XG4gICAgICAgICAgdE1zdyA9IChsYW5lTHN3IDw8IChyaG9PZmZzZXQgLSAzMikpIHwgKGxhbmVNc3cgPj4+ICg2NCAtIHJob09mZnNldCkpO1xuICAgICAgICAgIHRMc3cgPSAobGFuZU1zdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTHN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zcG9zZSBsYW5lc1xuICAgICAgICBjb25zdCBUUGlMYW5lID0gVFtQSV9JTkRFWEVTW2xhbmVJbmRleF1dO1xuICAgICAgICBUUGlMYW5lLmhpZ2ggPSB0TXN3O1xuICAgICAgICBUUGlMYW5lLmxvdyA9IHRMc3c7XG4gICAgICB9XG5cbiAgICAgIC8vIFJobyBwaSBhdCB4ID0geSA9IDBcbiAgICAgIGNvbnN0IFQwID0gVFswXTtcbiAgICAgIGNvbnN0IHN0YXRlMCA9IHN0YXRlWzBdO1xuICAgICAgVDAuaGlnaCA9IHN0YXRlMC5oaWdoO1xuICAgICAgVDAubG93ID0gc3RhdGUwLmxvdztcblxuICAgICAgLy8gQ2hpXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDU7IHggKz0gMSkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDU7IHkgKz0gMSkge1xuICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgIGNvbnN0IGxhbmVJbmRleCA9IHggKyA1ICogeTtcbiAgICAgICAgICBjb25zdCBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcbiAgICAgICAgICBjb25zdCBUTGFuZSA9IFRbbGFuZUluZGV4XTtcbiAgICAgICAgICBjb25zdCBUeDFMYW5lID0gVFsoKHggKyAxKSAlIDUpICsgNSAqIHldO1xuICAgICAgICAgIGNvbnN0IFR4MkxhbmUgPSBUWygoeCArIDIpICUgNSkgKyA1ICogeV07XG5cbiAgICAgICAgICAvLyBNaXggcm93c1xuICAgICAgICAgIGxhbmUuaGlnaCA9IFRMYW5lLmhpZ2ggXiAoflR4MUxhbmUuaGlnaCAmIFR4MkxhbmUuaGlnaCk7XG4gICAgICAgICAgbGFuZS5sb3cgPSBUTGFuZS5sb3cgXiAoflR4MUxhbmUubG93ICYgVHgyTGFuZS5sb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElvdGFcbiAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVswXTtcbiAgICAgIGNvbnN0IHJvdW5kQ29uc3RhbnQgPSBST1VORF9DT05TVEFOVFNbcm91bmRdO1xuICAgICAgbGFuZS5oaWdoIF49IHJvdW5kQ29uc3RhbnQuaGlnaDtcbiAgICAgIGxhbmUubG93IF49IHJvdW5kQ29uc3RhbnQubG93O1xuICAgIH1cbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgY29uc3QgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG4gICAgY29uc3QgYmxvY2tTaXplQml0cyA9IHRoaXMuYmxvY2tTaXplICogMzI7XG5cbiAgICAvLyBBZGQgcGFkZGluZ1xuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4MSA8PCAoMjQgLSAobkJpdHNMZWZ0ICUgMzIpKTtcbiAgICBkYXRhV29yZHNbKChNYXRoLmNlaWwoKG5CaXRzTGVmdCArIDEpIC8gYmxvY2tTaXplQml0cykgKiBibG9ja1NpemVCaXRzKSA+Pj4gNSkgLSAxXSB8PSAweDgwO1xuICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBvdXRwdXRMZW5ndGhCeXRlcyA9IHRoaXMuY2ZnLm91dHB1dExlbmd0aCAvIDg7XG4gICAgY29uc3Qgb3V0cHV0TGVuZ3RoTGFuZXMgPSBvdXRwdXRMZW5ndGhCeXRlcyAvIDg7XG5cbiAgICAvLyBTcXVlZXplXG4gICAgY29uc3QgaGFzaFdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGhMYW5lczsgaSArPSAxKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVtpXTtcbiAgICAgIGxldCBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuICAgICAgbGV0IGxhbmVMc3cgPSBsYW5lLmxvdztcblxuICAgICAgLy8gU3dhcCBlbmRpYW5cbiAgICAgIGxhbmVNc3cgPSAoKChsYW5lTXN3IDw8IDgpIHwgKGxhbmVNc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKGxhbmVNc3cgPDwgMjQpIHwgKGxhbmVNc3cgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgICAgbGFuZUxzdyA9ICgoKGxhbmVMc3cgPDwgOCkgfCAobGFuZUxzdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgobGFuZUxzdyA8PCAyNCkgfCAobGFuZUxzdyA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cbiAgICAgIC8vIFNxdWVlemUgc3RhdGUgdG8gcmV0cmlldmUgaGFzaFxuICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZUxzdyk7XG4gICAgICBoYXNoV29yZHMucHVzaChsYW5lTXN3KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgIHJldHVybiBuZXcgV29yZEFycmF5KGhhc2hXb3Jkcywgb3V0cHV0TGVuZ3RoQnl0ZXMpO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuXG4gICAgY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGUuc2xpY2UoMCk7XG4gICAgY29uc3Qgc3RhdGUgPSBjbG9uZS5fc3RhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSArPSAxKSB7XG4gICAgICBzdGF0ZVtpXSA9IHN0YXRlW2ldLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBTSEEzID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBM0FsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTMobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTNBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha3.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha384.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha384.js ***!
  \**********************************************/
/*! exports provided: SHA384Algo, SHA384, HmacSHA384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA384Algo\", function() { return SHA384Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA384\", function() { return SHA384; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA384\", function() { return HmacSHA384; });\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n/* harmony import */ var _sha512_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha512.js */ \"./node_modules/crypto-es/lib/sha512.js\");\n\n\n\n/**\n * SHA-384 hash algorithm.\n */\nclass SHA384Algo extends _sha512_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA512Algo\"] {\n  _doReset() {\n    this._hash = new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64WordArray\"]([\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0xcbbb9d5d, 0xc1059ed8),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x629a292a, 0x367cd507),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x9159015a, 0x3070dd17),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x152fecd8, 0xf70e5939),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x67332667, 0xffc00b31),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x8eb44a87, 0x68581511),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0xdb0c2e0d, 0x64f98fa7),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__[\"X64Word\"](0x47b5481d, 0xbefa4fa4),\n    ]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 16;\n\n    return hash;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA384('message');\n *     var hash = CryptoJS.SHA384(wordArray);\n */\nconst SHA384 = _sha512_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA512Algo\"]._createHelper(SHA384Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA384(message, key);\n */\nconst HmacSHA384 = _sha512_js__WEBPACK_IMPORTED_MODULE_1__[\"SHA512Algo\"]._createHmacHelper(SHA384Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMzg0LmpzPzY1NWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR3VCO0FBQ2tCOztBQUV6QztBQUNBO0FBQ0E7QUFDTyx5QkFBeUIscURBQVU7QUFDMUM7QUFDQSxxQkFBcUIseURBQVk7QUFDakMsVUFBVSxvREFBTztBQUNqQixVQUFVLG9EQUFPO0FBQ2pCLFVBQVUsb0RBQU87QUFDakIsVUFBVSxvREFBTztBQUNqQixVQUFVLG9EQUFPO0FBQ2pCLFVBQVUsb0RBQU87QUFDakIsVUFBVSxvREFBTztBQUNqQixVQUFVLG9EQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUscURBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLHFEQUFVIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMzg0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgWDY0V29yZCxcbiAgWDY0V29yZEFycmF5LFxufSBmcm9tICcuL3g2NC1jb3JlLmpzJztcbmltcG9ydCB7IFNIQTUxMkFsZ28gfSBmcm9tICcuL3NoYTUxMi5qcyc7XG5cbi8qKlxuICogU0hBLTM4NCBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTM4NEFsZ28gZXh0ZW5kcyBTSEE1MTJBbGdvIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkoW1xuICAgICAgbmV3IFg2NFdvcmQoMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCksXG4gICAgICBuZXcgWDY0V29yZCgweDYyOWEyOTJhLCAweDM2N2NkNTA3KSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcpLFxuICAgICAgbmV3IFg2NFdvcmQoMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSksXG4gICAgICBuZXcgWDY0V29yZCgweDY3MzMyNjY3LCAweGZmYzAwYjMxKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4OGViNDRhODcsIDB4Njg1ODE1MTEpLFxuICAgICAgbmV3IFg2NFdvcmQoMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyksXG4gICAgICBuZXcgWDY0V29yZCgweDQ3YjU0ODFkLCAweGJlZmE0ZmE0KSxcbiAgICBdKTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIGNvbnN0IGhhc2ggPSBzdXBlci5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG4gICAgaGFzaC5zaWdCeXRlcyAtPSAxNjtcblxuICAgIHJldHVybiBoYXNoO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTM4NCh3b3JkQXJyYXkpO1xuICovXG5leHBvcnQgY29uc3QgU0hBMzg0ID0gU0hBNTEyQWxnby5fY3JlYXRlSGVscGVyKFNIQTM4NEFsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTM4NChtZXNzYWdlLCBrZXkpO1xuICovXG5leHBvcnQgY29uc3QgSG1hY1NIQTM4NCA9IFNIQTUxMkFsZ28uX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMzg0QWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha384.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha512.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha512.js ***!
  \**********************************************/
/*! exports provided: SHA512Algo, SHA512, HmacSHA512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA512Algo\", function() { return SHA512Algo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHA512\", function() { return SHA512; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HmacSHA512\", function() { return HmacSHA512; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n\n\n\n// Constants\nconst K = [\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x428a2f98, 0xd728ae22),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x71374491, 0x23ef65cd),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xb5c0fbcf, 0xec4d3b2f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xe9b5dba5, 0x8189dbbc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x3956c25b, 0xf348b538),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x59f111f1, 0xb605d019),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x923f82a4, 0xaf194f9b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xab1c5ed5, 0xda6d8118),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xd807aa98, 0xa3030242),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x12835b01, 0x45706fbe),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x243185be, 0x4ee4b28c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x550c7dc3, 0xd5ffb4e2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x72be5d74, 0xf27b896f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x80deb1fe, 0x3b1696b1),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x9bdc06a7, 0x25c71235),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xc19bf174, 0xcf692694),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xe49b69c1, 0x9ef14ad2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xefbe4786, 0x384f25e3),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x0fc19dc6, 0x8b8cd5b5),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x240ca1cc, 0x77ac9c65),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x2de92c6f, 0x592b0275),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x4a7484aa, 0x6ea6e483),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x5cb0a9dc, 0xbd41fbd4),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x76f988da, 0x831153b5),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x983e5152, 0xee66dfab),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xa831c66d, 0x2db43210),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xb00327c8, 0x98fb213f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xbf597fc7, 0xbeef0ee4),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xc6e00bf3, 0x3da88fc2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xd5a79147, 0x930aa725),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x06ca6351, 0xe003826f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x14292967, 0x0a0e6e70),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x27b70a85, 0x46d22ffc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x2e1b2138, 0x5c26c926),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x4d2c6dfc, 0x5ac42aed),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x53380d13, 0x9d95b3df),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x650a7354, 0x8baf63de),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x766a0abb, 0x3c77b2a8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x81c2c92e, 0x47edaee6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x92722c85, 0x1482353b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xa2bfe8a1, 0x4cf10364),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xa81a664b, 0xbc423001),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xc24b8b70, 0xd0f89791),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xc76c51a3, 0x0654be30),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xd192e819, 0xd6ef5218),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xd6990624, 0x5565a910),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xf40e3585, 0x5771202a),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x106aa070, 0x32bbd1b8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x19a4c116, 0xb8d2d0c8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x1e376c08, 0x5141ab53),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x2748774c, 0xdf8eeb99),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x34b0bcb5, 0xe19b48a8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x391c0cb3, 0xc5c95a63),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x4ed8aa4a, 0xe3418acb),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x5b9cca4f, 0x7763e373),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x682e6ff3, 0xd6b2b8a3),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x748f82ee, 0x5defb2fc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x78a5636f, 0x43172f60),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x84c87814, 0xa1f0ab72),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x8cc70208, 0x1a6439ec),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x90befffa, 0x23631e28),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xa4506ceb, 0xde82bde9),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xbef9a3f7, 0xb2c67915),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xc67178f2, 0xe372532b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xca273ece, 0xea26619c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xd186b8c7, 0x21c0c207),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xeada7dd6, 0xcde0eb1e),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xf57d4f7f, 0xee6ed178),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x06f067aa, 0x72176fba),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x0a637dc5, 0xa2c898a6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x113f9804, 0xbef90dae),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x1b710b35, 0x131c471b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x28db77f5, 0x23047d84),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x32caab7b, 0x40c72493),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x3c9ebe0a, 0x15c9bebc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x431d67c4, 0x9c100d4c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x4cc5d4be, 0xcb3e42b6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x597f299c, 0xfc657e2a),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x5fcb6fab, 0x3ad6faec),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x6c44198c, 0x4a475817),\n];\n\n// Reusable objects\nconst W = [];\nfor (let i = 0; i < 80; i += 1) {\n  W[i] = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"]();\n}\n\n/**\n * SHA-512 hash algorithm.\n */\nclass SHA512Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"] {\n  constructor() {\n    super();\n\n    this.blockSize = 1024 / 32;\n  }\n\n  _doReset() {\n    this._hash = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64WordArray\"]([\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x6a09e667, 0xf3bcc908),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xbb67ae85, 0x84caa73b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x3c6ef372, 0xfe94f82b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0xa54ff53a, 0x5f1d36f1),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x510e527f, 0xade682d1),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x9b05688c, 0x2b3e6c1f),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x1f83d9ab, 0xfb41bd6b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__[\"X64Word\"](0x5be0cd19, 0x137e2179),\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const H = this._hash.words;\n\n    const H0 = H[0];\n    const H1 = H[1];\n    const H2 = H[2];\n    const H3 = H[3];\n    const H4 = H[4];\n    const H5 = H[5];\n    const H6 = H[6];\n    const H7 = H[7];\n\n    const H0h = H0.high;\n    let H0l = H0.low;\n    const H1h = H1.high;\n    let H1l = H1.low;\n    const H2h = H2.high;\n    let H2l = H2.low;\n    const H3h = H3.high;\n    let H3l = H3.low;\n    const H4h = H4.high;\n    let H4l = H4.low;\n    const H5h = H5.high;\n    let H5l = H5.low;\n    const H6h = H6.high;\n    let H6l = H6.low;\n    const H7h = H7.high;\n    let H7l = H7.low;\n\n    // Working variables\n    let ah = H0h;\n    let al = H0l;\n    let bh = H1h;\n    let bl = H1l;\n    let ch = H2h;\n    let cl = H2l;\n    let dh = H3h;\n    let dl = H3l;\n    let eh = H4h;\n    let el = H4l;\n    let fh = H5h;\n    let fl = H5l;\n    let gh = H6h;\n    let gl = H6l;\n    let hh = H7h;\n    let hl = H7l;\n\n    // Rounds\n    for (let i = 0; i < 80; i += 1) {\n      let Wil;\n      let Wih;\n\n      // Shortcut\n      const Wi = W[i];\n\n      // Extend message\n      if (i < 16) {\n        Wi.high = M[offset + i * 2] | 0;\n        Wih = Wi.high;\n        Wi.low = M[offset + i * 2 + 1] | 0;\n        Wil = Wi.low;\n      } else {\n        // Gamma0\n        const gamma0x = W[i - 15];\n        const gamma0xh = gamma0x.high;\n        const gamma0xl = gamma0x.low;\n        const gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31))\n          ^ ((gamma0xh >>> 8) | (gamma0xl << 24))\n          ^ (gamma0xh >>> 7);\n        const gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31))\n          ^ ((gamma0xl >>> 8) | (gamma0xh << 24))\n          ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n        // Gamma1\n        const gamma1x = W[i - 2];\n        const gamma1xh = gamma1x.high;\n        const gamma1xl = gamma1x.low;\n        const gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13))\n          ^ ((gamma1xh << 3) | (gamma1xl >>> 29))\n          ^ (gamma1xh >>> 6);\n        const gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13))\n          ^ ((gamma1xl << 3) | (gamma1xh >>> 29))\n          ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n        const Wi7 = W[i - 7];\n        const Wi7h = Wi7.high;\n        const Wi7l = Wi7.low;\n\n        const Wi16 = W[i - 16];\n        const Wi16h = Wi16.high;\n        const Wi16l = Wi16.low;\n\n        Wil = gamma0l + Wi7l;\n        Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        Wil += gamma1l;\n        Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        Wil += Wi16l;\n        Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n        Wi.high = Wih;\n        Wi.low = Wil;\n      }\n\n      const chh = (eh & fh) ^ (~eh & gh);\n      const chl = (el & fl) ^ (~el & gl);\n      const majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      const majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      const sigma0h = ((ah >>> 28) | (al << 4))\n        ^ ((ah << 30) | (al >>> 2))\n        ^ ((ah << 25) | (al >>> 7));\n      const sigma0l = ((al >>> 28) | (ah << 4))\n        ^ ((al << 30) | (ah >>> 2))\n        ^ ((al << 25) | (ah >>> 7));\n      const sigma1h = ((eh >>> 14) | (el << 18))\n        ^ ((eh >>> 18) | (el << 14))\n        ^ ((eh << 23) | (el >>> 9));\n      const sigma1l = ((el >>> 14) | (eh << 18))\n        ^ ((el >>> 18) | (eh << 14))\n        ^ ((el << 23) | (eh >>> 9));\n\n      // t1 = h + sigma1 + ch + K[i] + W[i]\n      const Ki = K[i];\n      const Kih = Ki.high;\n      const Kil = Ki.low;\n\n      let t1l = hl + sigma1l;\n      let t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += Kil;\n      t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n      t1l += Wil;\n      t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      const t2l = sigma0l + majl;\n      const t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash value\n    H0.low = (H0l + al);\n    H0l = H0.low;\n    H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n    H1.low = (H1l + bl);\n    H1l = H1.low;\n    H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n    H2.low = (H2l + cl);\n    H2l = H2.low;\n    H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n    H3.low = (H3l + dl);\n    H3l = H3.low;\n    H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n    H4.low = (H4l + el);\n    H4l = H4.low;\n    H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n    H5.low = (H5l + fl);\n    H5l = H5.low;\n    H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n    H6.low = (H6l + gl);\n    H6l = H6.low;\n    H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n    H7.low = (H7l + hl);\n    H7l = H7.low;\n    H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Convert hash to 32-bit word array before returning\n    const hash = this._hash.toX32();\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA512('message');\n *     var hash = CryptoJS.SHA512(wordArray);\n */\nconst SHA512 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHelper(SHA512Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA512(message, key);\n */\nconst HmacSHA512 = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Hasher\"]._createHmacHelper(SHA512Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhNTEyLmpzPzE3NDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW1DO0FBSVo7O0FBRXZCO0FBQ0E7QUFDQSxNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiLE1BQU0sb0RBQU87QUFDYixNQUFNLG9EQUFPO0FBQ2IsTUFBTSxvREFBTztBQUNiOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsYUFBYSxvREFBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsK0NBQU07QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlEQUFZO0FBQ2pDLFVBQVUsb0RBQU87QUFDakIsVUFBVSxvREFBTztBQUNqQixVQUFVLG9EQUFPO0FBQ2pCLFVBQVUsb0RBQU87QUFDakIsVUFBVSxvREFBTztBQUNqQixVQUFVLG9EQUFPO0FBQ2pCLFVBQVUsb0RBQU87QUFDakIsVUFBVSxvREFBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLCtDQUFNOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwrQ0FBTSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3NoYTUxMi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hlciB9IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBYNjRXb3JkLFxuICBYNjRXb3JkQXJyYXksXG59IGZyb20gJy4veDY0LWNvcmUuanMnO1xuXG4vLyBDb25zdGFudHNcbmNvbnN0IEsgPSBbXG4gIG5ldyBYNjRXb3JkKDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIpLFxuICBuZXcgWDY0V29yZCgweDcxMzc0NDkxLCAweDIzZWY2NWNkKSxcbiAgbmV3IFg2NFdvcmQoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksXG4gIG5ldyBYNjRXb3JkKDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMpLFxuICBuZXcgWDY0V29yZCgweDM5NTZjMjViLCAweGYzNDhiNTM4KSxcbiAgbmV3IFg2NFdvcmQoMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSksXG4gIG5ldyBYNjRXb3JkKDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIpLFxuICBuZXcgWDY0V29yZCgweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4KSxcbiAgbmV3IFg2NFdvcmQoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksXG4gIG5ldyBYNjRXb3JkKDB4MTI4MzViMDEsIDB4NDU3MDZmYmUpLFxuICBuZXcgWDY0V29yZCgweDI0MzE4NWJlLCAweDRlZTRiMjhjKSxcbiAgbmV3IFg2NFdvcmQoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG4gIG5ldyBYNjRXb3JkKDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYpLFxuICBuZXcgWDY0V29yZCgweDgwZGViMWZlLCAweDNiMTY5NmIxKSxcbiAgbmV3IFg2NFdvcmQoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksXG4gIG5ldyBYNjRXb3JkKDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQpLFxuICBuZXcgWDY0V29yZCgweGU0OWI2OWMxLCAweDllZjE0YWQyKSxcbiAgbmV3IFg2NFdvcmQoMHhlZmJlNDc4NiwgMHgzODRmMjVlMyksXG4gIG5ldyBYNjRXb3JkKDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUpLFxuICBuZXcgWDY0V29yZCgweDI0MGNhMWNjLCAweDc3YWM5YzY1KSxcbiAgbmV3IFg2NFdvcmQoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksXG4gIG5ldyBYNjRXb3JkKDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMpLFxuICBuZXcgWDY0V29yZCgweDVjYjBhOWRjLCAweGJkNDFmYmQ0KSxcbiAgbmV3IFg2NFdvcmQoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG4gIG5ldyBYNjRXb3JkKDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIpLFxuICBuZXcgWDY0V29yZCgweGE4MzFjNjZkLCAweDJkYjQzMjEwKSxcbiAgbmV3IFg2NFdvcmQoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksXG4gIG5ldyBYNjRXb3JkKDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQpLFxuICBuZXcgWDY0V29yZCgweGM2ZTAwYmYzLCAweDNkYTg4ZmMyKSxcbiAgbmV3IFg2NFdvcmQoMHhkNWE3OTE0NywgMHg5MzBhYTcyNSksXG4gIG5ldyBYNjRXb3JkKDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYpLFxuICBuZXcgWDY0V29yZCgweDE0MjkyOTY3LCAweDBhMGU2ZTcwKSxcbiAgbmV3IFg2NFdvcmQoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksXG4gIG5ldyBYNjRXb3JkKDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYpLFxuICBuZXcgWDY0V29yZCgweDRkMmM2ZGZjLCAweDVhYzQyYWVkKSxcbiAgbmV3IFg2NFdvcmQoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG4gIG5ldyBYNjRXb3JkKDB4NjUwYTczNTQsIDB4OGJhZjYzZGUpLFxuICBuZXcgWDY0V29yZCgweDc2NmEwYWJiLCAweDNjNzdiMmE4KSxcbiAgbmV3IFg2NFdvcmQoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksXG4gIG5ldyBYNjRXb3JkKDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IpLFxuICBuZXcgWDY0V29yZCgweGEyYmZlOGExLCAweDRjZjEwMzY0KSxcbiAgbmV3IFg2NFdvcmQoMHhhODFhNjY0YiwgMHhiYzQyMzAwMSksXG4gIG5ldyBYNjRXb3JkKDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEpLFxuICBuZXcgWDY0V29yZCgweGM3NmM1MWEzLCAweDA2NTRiZTMwKSxcbiAgbmV3IFg2NFdvcmQoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksXG4gIG5ldyBYNjRXb3JkKDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTApLFxuICBuZXcgWDY0V29yZCgweGY0MGUzNTg1LCAweDU3NzEyMDJhKSxcbiAgbmV3IFg2NFdvcmQoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG4gIG5ldyBYNjRXb3JkKDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgpLFxuICBuZXcgWDY0V29yZCgweDFlMzc2YzA4LCAweDUxNDFhYjUzKSxcbiAgbmV3IFg2NFdvcmQoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksXG4gIG5ldyBYNjRXb3JkKDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgpLFxuICBuZXcgWDY0V29yZCgweDM5MWMwY2IzLCAweGM1Yzk1YTYzKSxcbiAgbmV3IFg2NFdvcmQoMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYiksXG4gIG5ldyBYNjRXb3JkKDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMpLFxuICBuZXcgWDY0V29yZCgweDY4MmU2ZmYzLCAweGQ2YjJiOGEzKSxcbiAgbmV3IFg2NFdvcmQoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksXG4gIG5ldyBYNjRXb3JkKDB4NzhhNTYzNmYsIDB4NDMxNzJmNjApLFxuICBuZXcgWDY0V29yZCgweDg0Yzg3ODE0LCAweGExZjBhYjcyKSxcbiAgbmV3IFg2NFdvcmQoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG4gIG5ldyBYNjRXb3JkKDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgpLFxuICBuZXcgWDY0V29yZCgweGE0NTA2Y2ViLCAweGRlODJiZGU5KSxcbiAgbmV3IFg2NFdvcmQoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksXG4gIG5ldyBYNjRXb3JkKDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIpLFxuICBuZXcgWDY0V29yZCgweGNhMjczZWNlLCAweGVhMjY2MTljKSxcbiAgbmV3IFg2NFdvcmQoMHhkMTg2YjhjNywgMHgyMWMwYzIwNyksXG4gIG5ldyBYNjRXb3JkKDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUpLFxuICBuZXcgWDY0V29yZCgweGY1N2Q0ZjdmLCAweGVlNmVkMTc4KSxcbiAgbmV3IFg2NFdvcmQoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksXG4gIG5ldyBYNjRXb3JkKDB4MGE2MzdkYzUsIDB4YTJjODk4YTYpLFxuICBuZXcgWDY0V29yZCgweDExM2Y5ODA0LCAweGJlZjkwZGFlKSxcbiAgbmV3IFg2NFdvcmQoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG4gIG5ldyBYNjRXb3JkKDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQpLFxuICBuZXcgWDY0V29yZCgweDMyY2FhYjdiLCAweDQwYzcyNDkzKSxcbiAgbmV3IFg2NFdvcmQoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksXG4gIG5ldyBYNjRXb3JkKDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMpLFxuICBuZXcgWDY0V29yZCgweDRjYzVkNGJlLCAweGNiM2U0MmI2KSxcbiAgbmV3IFg2NFdvcmQoMHg1OTdmMjk5YywgMHhmYzY1N2UyYSksXG4gIG5ldyBYNjRXb3JkKDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMpLFxuICBuZXcgWDY0V29yZCgweDZjNDQxOThjLCAweDRhNDc1ODE3KSxcbl07XG5cbi8vIFJldXNhYmxlIG9iamVjdHNcbmNvbnN0IFcgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICBXW2ldID0gbmV3IFg2NFdvcmQoKTtcbn1cblxuLyoqXG4gKiBTSEEtNTEyIGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgU0hBNTEyQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDEwMjQgLyAzMjtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5KFtcbiAgICAgIG5ldyBYNjRXb3JkKDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgpLFxuICAgICAgbmV3IFg2NFdvcmQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksXG4gICAgICBuZXcgWDY0V29yZCgweDNjNmVmMzcyLCAweGZlOTRmODJiKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSksXG4gICAgICBuZXcgWDY0V29yZCgweDliMDU2ODhjLCAweDJiM2U2YzFmKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSksXG4gICAgXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cbiAgICBjb25zdCBIMCA9IEhbMF07XG4gICAgY29uc3QgSDEgPSBIWzFdO1xuICAgIGNvbnN0IEgyID0gSFsyXTtcbiAgICBjb25zdCBIMyA9IEhbM107XG4gICAgY29uc3QgSDQgPSBIWzRdO1xuICAgIGNvbnN0IEg1ID0gSFs1XTtcbiAgICBjb25zdCBINiA9IEhbNl07XG4gICAgY29uc3QgSDcgPSBIWzddO1xuXG4gICAgY29uc3QgSDBoID0gSDAuaGlnaDtcbiAgICBsZXQgSDBsID0gSDAubG93O1xuICAgIGNvbnN0IEgxaCA9IEgxLmhpZ2g7XG4gICAgbGV0IEgxbCA9IEgxLmxvdztcbiAgICBjb25zdCBIMmggPSBIMi5oaWdoO1xuICAgIGxldCBIMmwgPSBIMi5sb3c7XG4gICAgY29uc3QgSDNoID0gSDMuaGlnaDtcbiAgICBsZXQgSDNsID0gSDMubG93O1xuICAgIGNvbnN0IEg0aCA9IEg0LmhpZ2g7XG4gICAgbGV0IEg0bCA9IEg0LmxvdztcbiAgICBjb25zdCBINWggPSBINS5oaWdoO1xuICAgIGxldCBINWwgPSBINS5sb3c7XG4gICAgY29uc3QgSDZoID0gSDYuaGlnaDtcbiAgICBsZXQgSDZsID0gSDYubG93O1xuICAgIGNvbnN0IEg3aCA9IEg3LmhpZ2g7XG4gICAgbGV0IEg3bCA9IEg3LmxvdztcblxuICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gICAgbGV0IGFoID0gSDBoO1xuICAgIGxldCBhbCA9IEgwbDtcbiAgICBsZXQgYmggPSBIMWg7XG4gICAgbGV0IGJsID0gSDFsO1xuICAgIGxldCBjaCA9IEgyaDtcbiAgICBsZXQgY2wgPSBIMmw7XG4gICAgbGV0IGRoID0gSDNoO1xuICAgIGxldCBkbCA9IEgzbDtcbiAgICBsZXQgZWggPSBINGg7XG4gICAgbGV0IGVsID0gSDRsO1xuICAgIGxldCBmaCA9IEg1aDtcbiAgICBsZXQgZmwgPSBINWw7XG4gICAgbGV0IGdoID0gSDZoO1xuICAgIGxldCBnbCA9IEg2bDtcbiAgICBsZXQgaGggPSBIN2g7XG4gICAgbGV0IGhsID0gSDdsO1xuXG4gICAgLy8gUm91bmRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgICBsZXQgV2lsO1xuICAgICAgbGV0IFdpaDtcblxuICAgICAgLy8gU2hvcnRjdXRcbiAgICAgIGNvbnN0IFdpID0gV1tpXTtcblxuICAgICAgLy8gRXh0ZW5kIG1lc3NhZ2VcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgV2kuaGlnaCA9IE1bb2Zmc2V0ICsgaSAqIDJdIHwgMDtcbiAgICAgICAgV2loID0gV2kuaGlnaDtcbiAgICAgICAgV2kubG93ID0gTVtvZmZzZXQgKyBpICogMiArIDFdIHwgMDtcbiAgICAgICAgV2lsID0gV2kubG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2FtbWEwXG4gICAgICAgIGNvbnN0IGdhbW1hMHggPSBXW2kgLSAxNV07XG4gICAgICAgIGNvbnN0IGdhbW1hMHhoID0gZ2FtbWEweC5oaWdoO1xuICAgICAgICBjb25zdCBnYW1tYTB4bCA9IGdhbW1hMHgubG93O1xuICAgICAgICBjb25zdCBnYW1tYTBoID0gKChnYW1tYTB4aCA+Pj4gMSkgfCAoZ2FtbWEweGwgPDwgMzEpKVxuICAgICAgICAgIF4gKChnYW1tYTB4aCA+Pj4gOCkgfCAoZ2FtbWEweGwgPDwgMjQpKVxuICAgICAgICAgIF4gKGdhbW1hMHhoID4+PiA3KTtcbiAgICAgICAgY29uc3QgZ2FtbWEwbCA9ICgoZ2FtbWEweGwgPj4+IDEpIHwgKGdhbW1hMHhoIDw8IDMxKSlcbiAgICAgICAgICBeICgoZ2FtbWEweGwgPj4+IDgpIHwgKGdhbW1hMHhoIDw8IDI0KSlcbiAgICAgICAgICBeICgoZ2FtbWEweGwgPj4+IDcpIHwgKGdhbW1hMHhoIDw8IDI1KSk7XG5cbiAgICAgICAgLy8gR2FtbWExXG4gICAgICAgIGNvbnN0IGdhbW1hMXggPSBXW2kgLSAyXTtcbiAgICAgICAgY29uc3QgZ2FtbWExeGggPSBnYW1tYTF4LmhpZ2g7XG4gICAgICAgIGNvbnN0IGdhbW1hMXhsID0gZ2FtbWExeC5sb3c7XG4gICAgICAgIGNvbnN0IGdhbW1hMWggPSAoKGdhbW1hMXhoID4+PiAxOSkgfCAoZ2FtbWExeGwgPDwgMTMpKVxuICAgICAgICAgIF4gKChnYW1tYTF4aCA8PCAzKSB8IChnYW1tYTF4bCA+Pj4gMjkpKVxuICAgICAgICAgIF4gKGdhbW1hMXhoID4+PiA2KTtcbiAgICAgICAgY29uc3QgZ2FtbWExbCA9ICgoZ2FtbWExeGwgPj4+IDE5KSB8IChnYW1tYTF4aCA8PCAxMykpXG4gICAgICAgICAgXiAoKGdhbW1hMXhsIDw8IDMpIHwgKGdhbW1hMXhoID4+PiAyOSkpXG4gICAgICAgICAgXiAoKGdhbW1hMXhsID4+PiA2KSB8IChnYW1tYTF4aCA8PCAyNikpO1xuXG4gICAgICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgICAgICBjb25zdCBXaTcgPSBXW2kgLSA3XTtcbiAgICAgICAgY29uc3QgV2k3aCA9IFdpNy5oaWdoO1xuICAgICAgICBjb25zdCBXaTdsID0gV2k3LmxvdztcblxuICAgICAgICBjb25zdCBXaTE2ID0gV1tpIC0gMTZdO1xuICAgICAgICBjb25zdCBXaTE2aCA9IFdpMTYuaGlnaDtcbiAgICAgICAgY29uc3QgV2kxNmwgPSBXaTE2LmxvdztcblxuICAgICAgICBXaWwgPSBnYW1tYTBsICsgV2k3bDtcbiAgICAgICAgV2loID0gZ2FtbWEwaCArIFdpN2ggKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMCk7XG4gICAgICAgIFdpbCArPSBnYW1tYTFsO1xuICAgICAgICBXaWggPSBXaWggKyBnYW1tYTFoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApO1xuICAgICAgICBXaWwgKz0gV2kxNmw7XG4gICAgICAgIFdpaCA9IFdpaCArIFdpMTZoICsgKChXaWwgPj4+IDApIDwgKFdpMTZsID4+PiAwKSA/IDEgOiAwKTtcblxuICAgICAgICBXaS5oaWdoID0gV2loO1xuICAgICAgICBXaS5sb3cgPSBXaWw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaCA9IChlaCAmIGZoKSBeICh+ZWggJiBnaCk7XG4gICAgICBjb25zdCBjaGwgPSAoZWwgJiBmbCkgXiAofmVsICYgZ2wpO1xuICAgICAgY29uc3QgbWFqaCA9IChhaCAmIGJoKSBeIChhaCAmIGNoKSBeIChiaCAmIGNoKTtcbiAgICAgIGNvbnN0IG1hamwgPSAoYWwgJiBibCkgXiAoYWwgJiBjbCkgXiAoYmwgJiBjbCk7XG5cbiAgICAgIGNvbnN0IHNpZ21hMGggPSAoKGFoID4+PiAyOCkgfCAoYWwgPDwgNCkpXG4gICAgICAgIF4gKChhaCA8PCAzMCkgfCAoYWwgPj4+IDIpKVxuICAgICAgICBeICgoYWggPDwgMjUpIHwgKGFsID4+PiA3KSk7XG4gICAgICBjb25zdCBzaWdtYTBsID0gKChhbCA+Pj4gMjgpIHwgKGFoIDw8IDQpKVxuICAgICAgICBeICgoYWwgPDwgMzApIHwgKGFoID4+PiAyKSlcbiAgICAgICAgXiAoKGFsIDw8IDI1KSB8IChhaCA+Pj4gNykpO1xuICAgICAgY29uc3Qgc2lnbWExaCA9ICgoZWggPj4+IDE0KSB8IChlbCA8PCAxOCkpXG4gICAgICAgIF4gKChlaCA+Pj4gMTgpIHwgKGVsIDw8IDE0KSlcbiAgICAgICAgXiAoKGVoIDw8IDIzKSB8IChlbCA+Pj4gOSkpO1xuICAgICAgY29uc3Qgc2lnbWExbCA9ICgoZWwgPj4+IDE0KSB8IChlaCA8PCAxOCkpXG4gICAgICAgIF4gKChlbCA+Pj4gMTgpIHwgKGVoIDw8IDE0KSlcbiAgICAgICAgXiAoKGVsIDw8IDIzKSB8IChlaCA+Pj4gOSkpO1xuXG4gICAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG4gICAgICBjb25zdCBLaSA9IEtbaV07XG4gICAgICBjb25zdCBLaWggPSBLaS5oaWdoO1xuICAgICAgY29uc3QgS2lsID0gS2kubG93O1xuXG4gICAgICBsZXQgdDFsID0gaGwgKyBzaWdtYTFsO1xuICAgICAgbGV0IHQxaCA9IGhoICsgc2lnbWExaCArICgodDFsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCk7XG4gICAgICB0MWwgKz0gY2hsO1xuICAgICAgdDFoID0gdDFoICsgY2hoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMCk7XG4gICAgICB0MWwgKz0gS2lsO1xuICAgICAgdDFoID0gdDFoICsgS2loICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMCk7XG4gICAgICB0MWwgKz0gV2lsO1xuICAgICAgdDFoID0gdDFoICsgV2loICsgKCh0MWwgPj4+IDApIDwgKFdpbCA+Pj4gMCkgPyAxIDogMCk7XG5cbiAgICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgICBjb25zdCB0MmwgPSBzaWdtYTBsICsgbWFqbDtcbiAgICAgIGNvbnN0IHQyaCA9IHNpZ21hMGggKyBtYWpoICsgKCh0MmwgPj4+IDApIDwgKHNpZ21hMGwgPj4+IDApID8gMSA6IDApO1xuXG4gICAgICAvLyBVcGRhdGUgd29ya2luZyB2YXJpYWJsZXNcbiAgICAgIGhoID0gZ2g7XG4gICAgICBobCA9IGdsO1xuICAgICAgZ2ggPSBmaDtcbiAgICAgIGdsID0gZmw7XG4gICAgICBmaCA9IGVoO1xuICAgICAgZmwgPSBlbDtcbiAgICAgIGVsID0gKGRsICsgdDFsKSB8IDA7XG4gICAgICBlaCA9IChkaCArIHQxaCArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICAgICAgZGggPSBjaDtcbiAgICAgIGRsID0gY2w7XG4gICAgICBjaCA9IGJoO1xuICAgICAgY2wgPSBibDtcbiAgICAgIGJoID0gYWg7XG4gICAgICBibCA9IGFsO1xuICAgICAgYWwgPSAodDFsICsgdDJsKSB8IDA7XG4gICAgICBhaCA9ICh0MWggKyB0MmggKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICBIMC5sb3cgPSAoSDBsICsgYWwpO1xuICAgIEgwbCA9IEgwLmxvdztcbiAgICBIMC5oaWdoID0gKEgwaCArIGFoICsgKChIMGwgPj4+IDApIDwgKGFsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgSDEubG93ID0gKEgxbCArIGJsKTtcbiAgICBIMWwgPSBIMS5sb3c7XG4gICAgSDEuaGlnaCA9IChIMWggKyBiaCArICgoSDFsID4+PiAwKSA8IChibCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgIEgyLmxvdyA9IChIMmwgKyBjbCk7XG4gICAgSDJsID0gSDIubG93O1xuICAgIEgyLmhpZ2ggPSAoSDJoICsgY2ggKyAoKEgybCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKTtcbiAgICBIMy5sb3cgPSAoSDNsICsgZGwpO1xuICAgIEgzbCA9IEgzLmxvdztcbiAgICBIMy5oaWdoID0gKEgzaCArIGRoICsgKChIM2wgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgSDQubG93ID0gKEg0bCArIGVsKTtcbiAgICBINGwgPSBINC5sb3c7XG4gICAgSDQuaGlnaCA9IChINGggKyBlaCArICgoSDRsID4+PiAwKSA8IChlbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgIEg1LmxvdyA9IChINWwgKyBmbCk7XG4gICAgSDVsID0gSDUubG93O1xuICAgIEg1LmhpZ2ggPSAoSDVoICsgZmggKyAoKEg1bCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKTtcbiAgICBINi5sb3cgPSAoSDZsICsgZ2wpO1xuICAgIEg2bCA9IEg2LmxvdztcbiAgICBINi5oaWdoID0gKEg2aCArIGdoICsgKChINmwgPj4+IDApIDwgKGdsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgSDcubG93ID0gKEg3bCArIGhsKTtcbiAgICBIN2wgPSBINy5sb3c7XG4gICAgSDcuaGlnaCA9IChIN2ggKyBoaCArICgoSDdsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCkpO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSAobkJpdHNMZWZ0ICUgMzIpKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzBdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyAxMjgpID4+PiAxMCkgPDwgNSkgKyAzMV0gPSBuQml0c1RvdGFsO1xuICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgLy8gQ29udmVydCBoYXNoIHRvIDMyLWJpdCB3b3JkIGFycmF5IGJlZm9yZSByZXR1cm5pbmdcbiAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaC50b1gzMigpO1xuXG4gICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIod29yZEFycmF5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IFNIQTUxMiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMkFsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTUxMihtZXNzYWdlLCBrZXkpO1xuICovXG5leHBvcnQgY29uc3QgSG1hY1NIQTUxMiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEE1MTJBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha512.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/tripledes.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/tripledes.js ***!
  \*************************************************/
/*! exports provided: DESAlgo, DES, TripleDESAlgo, TripleDES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DESAlgo\", function() { return DESAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DES\", function() { return DES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TripleDESAlgo\", function() { return TripleDESAlgo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TripleDES\", function() { return TripleDES; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n\n// Permuted Choice 1 constants\nconst PC1 = [\n  57, 49, 41, 33, 25, 17, 9, 1,\n  58, 50, 42, 34, 26, 18, 10, 2,\n  59, 51, 43, 35, 27, 19, 11, 3,\n  60, 52, 44, 36, 63, 55, 47, 39,\n  31, 23, 15, 7, 62, 54, 46, 38,\n  30, 22, 14, 6, 61, 53, 45, 37,\n  29, 21, 13, 5, 28, 20, 12, 4,\n];\n\n// Permuted Choice 2 constants\nconst PC2 = [\n  14, 17, 11, 24, 1, 5,\n  3, 28, 15, 6, 21, 10,\n  23, 19, 12, 4, 26, 8,\n  16, 7, 27, 20, 13, 2,\n  41, 52, 31, 37, 47, 55,\n  30, 40, 51, 45, 33, 48,\n  44, 49, 39, 56, 34, 53,\n  46, 42, 50, 36, 29, 32,\n];\n\n// Cumulative bit shift constants\nconst BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n// SBOXes and round permutation constants\nconst SBOX_P = [\n  {\n    0x0: 0x808200,\n    0x10000000: 0x8000,\n    0x20000000: 0x808002,\n    0x30000000: 0x2,\n    0x40000000: 0x200,\n    0x50000000: 0x808202,\n    0x60000000: 0x800202,\n    0x70000000: 0x800000,\n    0x80000000: 0x202,\n    0x90000000: 0x800200,\n    0xa0000000: 0x8200,\n    0xb0000000: 0x808000,\n    0xc0000000: 0x8002,\n    0xd0000000: 0x800002,\n    0xe0000000: 0x0,\n    0xf0000000: 0x8202,\n    0x8000000: 0x0,\n    0x18000000: 0x808202,\n    0x28000000: 0x8202,\n    0x38000000: 0x8000,\n    0x48000000: 0x808200,\n    0x58000000: 0x200,\n    0x68000000: 0x808002,\n    0x78000000: 0x2,\n    0x88000000: 0x800200,\n    0x98000000: 0x8200,\n    0xa8000000: 0x808000,\n    0xb8000000: 0x800202,\n    0xc8000000: 0x800002,\n    0xd8000000: 0x8002,\n    0xe8000000: 0x202,\n    0xf8000000: 0x800000,\n    0x1: 0x8000,\n    0x10000001: 0x2,\n    0x20000001: 0x808200,\n    0x30000001: 0x800000,\n    0x40000001: 0x808002,\n    0x50000001: 0x8200,\n    0x60000001: 0x200,\n    0x70000001: 0x800202,\n    0x80000001: 0x808202,\n    0x90000001: 0x808000,\n    0xa0000001: 0x800002,\n    0xb0000001: 0x8202,\n    0xc0000001: 0x202,\n    0xd0000001: 0x800200,\n    0xe0000001: 0x8002,\n    0xf0000001: 0x0,\n    0x8000001: 0x808202,\n    0x18000001: 0x808000,\n    0x28000001: 0x800000,\n    0x38000001: 0x200,\n    0x48000001: 0x8000,\n    0x58000001: 0x800002,\n    0x68000001: 0x2,\n    0x78000001: 0x8202,\n    0x88000001: 0x8002,\n    0x98000001: 0x800202,\n    0xa8000001: 0x202,\n    0xb8000001: 0x808200,\n    0xc8000001: 0x800200,\n    0xd8000001: 0x0,\n    0xe8000001: 0x8200,\n    0xf8000001: 0x808002,\n  },\n  {\n    0x0: 0x40084010,\n    0x1000000: 0x4000,\n    0x2000000: 0x80000,\n    0x3000000: 0x40080010,\n    0x4000000: 0x40000010,\n    0x5000000: 0x40084000,\n    0x6000000: 0x40004000,\n    0x7000000: 0x10,\n    0x8000000: 0x84000,\n    0x9000000: 0x40004010,\n    0xa000000: 0x40000000,\n    0xb000000: 0x84010,\n    0xc000000: 0x80010,\n    0xd000000: 0x0,\n    0xe000000: 0x4010,\n    0xf000000: 0x40080000,\n    0x800000: 0x40004000,\n    0x1800000: 0x84010,\n    0x2800000: 0x10,\n    0x3800000: 0x40004010,\n    0x4800000: 0x40084010,\n    0x5800000: 0x40000000,\n    0x6800000: 0x80000,\n    0x7800000: 0x40080010,\n    0x8800000: 0x80010,\n    0x9800000: 0x0,\n    0xa800000: 0x4000,\n    0xb800000: 0x40080000,\n    0xc800000: 0x40000010,\n    0xd800000: 0x84000,\n    0xe800000: 0x40084000,\n    0xf800000: 0x4010,\n    0x10000000: 0x0,\n    0x11000000: 0x40080010,\n    0x12000000: 0x40004010,\n    0x13000000: 0x40084000,\n    0x14000000: 0x40080000,\n    0x15000000: 0x10,\n    0x16000000: 0x84010,\n    0x17000000: 0x4000,\n    0x18000000: 0x4010,\n    0x19000000: 0x80000,\n    0x1a000000: 0x80010,\n    0x1b000000: 0x40000010,\n    0x1c000000: 0x84000,\n    0x1d000000: 0x40004000,\n    0x1e000000: 0x40000000,\n    0x1f000000: 0x40084010,\n    0x10800000: 0x84010,\n    0x11800000: 0x80000,\n    0x12800000: 0x40080000,\n    0x13800000: 0x4000,\n    0x14800000: 0x40004000,\n    0x15800000: 0x40084010,\n    0x16800000: 0x10,\n    0x17800000: 0x40000000,\n    0x18800000: 0x40084000,\n    0x19800000: 0x40000010,\n    0x1a800000: 0x40004010,\n    0x1b800000: 0x80010,\n    0x1c800000: 0x0,\n    0x1d800000: 0x4010,\n    0x1e800000: 0x40080010,\n    0x1f800000: 0x84000,\n  },\n  {\n    0x0: 0x104,\n    0x100000: 0x0,\n    0x200000: 0x4000100,\n    0x300000: 0x10104,\n    0x400000: 0x10004,\n    0x500000: 0x4000004,\n    0x600000: 0x4010104,\n    0x700000: 0x4010000,\n    0x800000: 0x4000000,\n    0x900000: 0x4010100,\n    0xa00000: 0x10100,\n    0xb00000: 0x4010004,\n    0xc00000: 0x4000104,\n    0xd00000: 0x10000,\n    0xe00000: 0x4,\n    0xf00000: 0x100,\n    0x80000: 0x4010100,\n    0x180000: 0x4010004,\n    0x280000: 0x0,\n    0x380000: 0x4000100,\n    0x480000: 0x4000004,\n    0x580000: 0x10000,\n    0x680000: 0x10004,\n    0x780000: 0x104,\n    0x880000: 0x4,\n    0x980000: 0x100,\n    0xa80000: 0x4010000,\n    0xb80000: 0x10104,\n    0xc80000: 0x10100,\n    0xd80000: 0x4000104,\n    0xe80000: 0x4010104,\n    0xf80000: 0x4000000,\n    0x1000000: 0x4010100,\n    0x1100000: 0x10004,\n    0x1200000: 0x10000,\n    0x1300000: 0x4000100,\n    0x1400000: 0x100,\n    0x1500000: 0x4010104,\n    0x1600000: 0x4000004,\n    0x1700000: 0x0,\n    0x1800000: 0x4000104,\n    0x1900000: 0x4000000,\n    0x1a00000: 0x4,\n    0x1b00000: 0x10100,\n    0x1c00000: 0x4010000,\n    0x1d00000: 0x104,\n    0x1e00000: 0x10104,\n    0x1f00000: 0x4010004,\n    0x1080000: 0x4000000,\n    0x1180000: 0x104,\n    0x1280000: 0x4010100,\n    0x1380000: 0x0,\n    0x1480000: 0x10004,\n    0x1580000: 0x4000100,\n    0x1680000: 0x100,\n    0x1780000: 0x4010004,\n    0x1880000: 0x10000,\n    0x1980000: 0x4010104,\n    0x1a80000: 0x10104,\n    0x1b80000: 0x4000004,\n    0x1c80000: 0x4000104,\n    0x1d80000: 0x4010000,\n    0x1e80000: 0x4,\n    0x1f80000: 0x10100,\n  },\n  {\n    0x0: 0x80401000,\n    0x10000: 0x80001040,\n    0x20000: 0x401040,\n    0x30000: 0x80400000,\n    0x40000: 0x0,\n    0x50000: 0x401000,\n    0x60000: 0x80000040,\n    0x70000: 0x400040,\n    0x80000: 0x80000000,\n    0x90000: 0x400000,\n    0xa0000: 0x40,\n    0xb0000: 0x80001000,\n    0xc0000: 0x80400040,\n    0xd0000: 0x1040,\n    0xe0000: 0x1000,\n    0xf0000: 0x80401040,\n    0x8000: 0x80001040,\n    0x18000: 0x40,\n    0x28000: 0x80400040,\n    0x38000: 0x80001000,\n    0x48000: 0x401000,\n    0x58000: 0x80401040,\n    0x68000: 0x0,\n    0x78000: 0x80400000,\n    0x88000: 0x1000,\n    0x98000: 0x80401000,\n    0xa8000: 0x400000,\n    0xb8000: 0x1040,\n    0xc8000: 0x80000000,\n    0xd8000: 0x400040,\n    0xe8000: 0x401040,\n    0xf8000: 0x80000040,\n    0x100000: 0x400040,\n    0x110000: 0x401000,\n    0x120000: 0x80000040,\n    0x130000: 0x0,\n    0x140000: 0x1040,\n    0x150000: 0x80400040,\n    0x160000: 0x80401000,\n    0x170000: 0x80001040,\n    0x180000: 0x80401040,\n    0x190000: 0x80000000,\n    0x1a0000: 0x80400000,\n    0x1b0000: 0x401040,\n    0x1c0000: 0x80001000,\n    0x1d0000: 0x400000,\n    0x1e0000: 0x40,\n    0x1f0000: 0x1000,\n    0x108000: 0x80400000,\n    0x118000: 0x80401040,\n    0x128000: 0x0,\n    0x138000: 0x401000,\n    0x148000: 0x400040,\n    0x158000: 0x80000000,\n    0x168000: 0x80001040,\n    0x178000: 0x40,\n    0x188000: 0x80000040,\n    0x198000: 0x1000,\n    0x1a8000: 0x80001000,\n    0x1b8000: 0x80400040,\n    0x1c8000: 0x1040,\n    0x1d8000: 0x80401000,\n    0x1e8000: 0x400000,\n    0x1f8000: 0x401040,\n  },\n  {\n    0x0: 0x80,\n    0x1000: 0x1040000,\n    0x2000: 0x40000,\n    0x3000: 0x20000000,\n    0x4000: 0x20040080,\n    0x5000: 0x1000080,\n    0x6000: 0x21000080,\n    0x7000: 0x40080,\n    0x8000: 0x1000000,\n    0x9000: 0x20040000,\n    0xa000: 0x20000080,\n    0xb000: 0x21040080,\n    0xc000: 0x21040000,\n    0xd000: 0x0,\n    0xe000: 0x1040080,\n    0xf000: 0x21000000,\n    0x800: 0x1040080,\n    0x1800: 0x21000080,\n    0x2800: 0x80,\n    0x3800: 0x1040000,\n    0x4800: 0x40000,\n    0x5800: 0x20040080,\n    0x6800: 0x21040000,\n    0x7800: 0x20000000,\n    0x8800: 0x20040000,\n    0x9800: 0x0,\n    0xa800: 0x21040080,\n    0xb800: 0x1000080,\n    0xc800: 0x20000080,\n    0xd800: 0x21000000,\n    0xe800: 0x1000000,\n    0xf800: 0x40080,\n    0x10000: 0x40000,\n    0x11000: 0x80,\n    0x12000: 0x20000000,\n    0x13000: 0x21000080,\n    0x14000: 0x1000080,\n    0x15000: 0x21040000,\n    0x16000: 0x20040080,\n    0x17000: 0x1000000,\n    0x18000: 0x21040080,\n    0x19000: 0x21000000,\n    0x1a000: 0x1040000,\n    0x1b000: 0x20040000,\n    0x1c000: 0x40080,\n    0x1d000: 0x20000080,\n    0x1e000: 0x0,\n    0x1f000: 0x1040080,\n    0x10800: 0x21000080,\n    0x11800: 0x1000000,\n    0x12800: 0x1040000,\n    0x13800: 0x20040080,\n    0x14800: 0x20000000,\n    0x15800: 0x1040080,\n    0x16800: 0x80,\n    0x17800: 0x21040000,\n    0x18800: 0x40080,\n    0x19800: 0x21040080,\n    0x1a800: 0x0,\n    0x1b800: 0x21000000,\n    0x1c800: 0x1000080,\n    0x1d800: 0x40000,\n    0x1e800: 0x20040000,\n    0x1f800: 0x20000080,\n  },\n  {\n    0x0: 0x10000008,\n    0x100: 0x2000,\n    0x200: 0x10200000,\n    0x300: 0x10202008,\n    0x400: 0x10002000,\n    0x500: 0x200000,\n    0x600: 0x200008,\n    0x700: 0x10000000,\n    0x800: 0x0,\n    0x900: 0x10002008,\n    0xa00: 0x202000,\n    0xb00: 0x8,\n    0xc00: 0x10200008,\n    0xd00: 0x202008,\n    0xe00: 0x2008,\n    0xf00: 0x10202000,\n    0x80: 0x10200000,\n    0x180: 0x10202008,\n    0x280: 0x8,\n    0x380: 0x200000,\n    0x480: 0x202008,\n    0x580: 0x10000008,\n    0x680: 0x10002000,\n    0x780: 0x2008,\n    0x880: 0x200008,\n    0x980: 0x2000,\n    0xa80: 0x10002008,\n    0xb80: 0x10200008,\n    0xc80: 0x0,\n    0xd80: 0x10202000,\n    0xe80: 0x202000,\n    0xf80: 0x10000000,\n    0x1000: 0x10002000,\n    0x1100: 0x10200008,\n    0x1200: 0x10202008,\n    0x1300: 0x2008,\n    0x1400: 0x200000,\n    0x1500: 0x10000000,\n    0x1600: 0x10000008,\n    0x1700: 0x202000,\n    0x1800: 0x202008,\n    0x1900: 0x0,\n    0x1a00: 0x8,\n    0x1b00: 0x10200000,\n    0x1c00: 0x2000,\n    0x1d00: 0x10002008,\n    0x1e00: 0x10202000,\n    0x1f00: 0x200008,\n    0x1080: 0x8,\n    0x1180: 0x202000,\n    0x1280: 0x200000,\n    0x1380: 0x10000008,\n    0x1480: 0x10002000,\n    0x1580: 0x2008,\n    0x1680: 0x10202008,\n    0x1780: 0x10200000,\n    0x1880: 0x10202000,\n    0x1980: 0x10200008,\n    0x1a80: 0x2000,\n    0x1b80: 0x202008,\n    0x1c80: 0x200008,\n    0x1d80: 0x0,\n    0x1e80: 0x10000000,\n    0x1f80: 0x10002008,\n  },\n  {\n    0x0: 0x100000,\n    0x10: 0x2000401,\n    0x20: 0x400,\n    0x30: 0x100401,\n    0x40: 0x2100401,\n    0x50: 0x0,\n    0x60: 0x1,\n    0x70: 0x2100001,\n    0x80: 0x2000400,\n    0x90: 0x100001,\n    0xa0: 0x2000001,\n    0xb0: 0x2100400,\n    0xc0: 0x2100000,\n    0xd0: 0x401,\n    0xe0: 0x100400,\n    0xf0: 0x2000000,\n    0x8: 0x2100001,\n    0x18: 0x0,\n    0x28: 0x2000401,\n    0x38: 0x2100400,\n    0x48: 0x100000,\n    0x58: 0x2000001,\n    0x68: 0x2000000,\n    0x78: 0x401,\n    0x88: 0x100401,\n    0x98: 0x2000400,\n    0xa8: 0x2100000,\n    0xb8: 0x100001,\n    0xc8: 0x400,\n    0xd8: 0x2100401,\n    0xe8: 0x1,\n    0xf8: 0x100400,\n    0x100: 0x2000000,\n    0x110: 0x100000,\n    0x120: 0x2000401,\n    0x130: 0x2100001,\n    0x140: 0x100001,\n    0x150: 0x2000400,\n    0x160: 0x2100400,\n    0x170: 0x100401,\n    0x180: 0x401,\n    0x190: 0x2100401,\n    0x1a0: 0x100400,\n    0x1b0: 0x1,\n    0x1c0: 0x0,\n    0x1d0: 0x2100000,\n    0x1e0: 0x2000001,\n    0x1f0: 0x400,\n    0x108: 0x100400,\n    0x118: 0x2000401,\n    0x128: 0x2100001,\n    0x138: 0x1,\n    0x148: 0x2000000,\n    0x158: 0x100000,\n    0x168: 0x401,\n    0x178: 0x2100400,\n    0x188: 0x2000001,\n    0x198: 0x2100000,\n    0x1a8: 0x0,\n    0x1b8: 0x2100401,\n    0x1c8: 0x100401,\n    0x1d8: 0x400,\n    0x1e8: 0x2000400,\n    0x1f8: 0x100001,\n  },\n  {\n    0x0: 0x8000820,\n    0x1: 0x20000,\n    0x2: 0x8000000,\n    0x3: 0x20,\n    0x4: 0x20020,\n    0x5: 0x8020820,\n    0x6: 0x8020800,\n    0x7: 0x800,\n    0x8: 0x8020000,\n    0x9: 0x8000800,\n    0xa: 0x20800,\n    0xb: 0x8020020,\n    0xc: 0x820,\n    0xd: 0x0,\n    0xe: 0x8000020,\n    0xf: 0x20820,\n    0x80000000: 0x800,\n    0x80000001: 0x8020820,\n    0x80000002: 0x8000820,\n    0x80000003: 0x8000000,\n    0x80000004: 0x8020000,\n    0x80000005: 0x20800,\n    0x80000006: 0x20820,\n    0x80000007: 0x20,\n    0x80000008: 0x8000020,\n    0x80000009: 0x820,\n    0x8000000a: 0x20020,\n    0x8000000b: 0x8020800,\n    0x8000000c: 0x0,\n    0x8000000d: 0x8020020,\n    0x8000000e: 0x8000800,\n    0x8000000f: 0x20000,\n    0x10: 0x20820,\n    0x11: 0x8020800,\n    0x12: 0x20,\n    0x13: 0x800,\n    0x14: 0x8000800,\n    0x15: 0x8000020,\n    0x16: 0x8020020,\n    0x17: 0x20000,\n    0x18: 0x0,\n    0x19: 0x20020,\n    0x1a: 0x8020000,\n    0x1b: 0x8000820,\n    0x1c: 0x8020820,\n    0x1d: 0x20800,\n    0x1e: 0x820,\n    0x1f: 0x8000000,\n    0x80000010: 0x20000,\n    0x80000011: 0x800,\n    0x80000012: 0x8020020,\n    0x80000013: 0x20820,\n    0x80000014: 0x20,\n    0x80000015: 0x8020000,\n    0x80000016: 0x8000000,\n    0x80000017: 0x8000820,\n    0x80000018: 0x8020820,\n    0x80000019: 0x8000020,\n    0x8000001a: 0x8000800,\n    0x8000001b: 0x0,\n    0x8000001c: 0x20800,\n    0x8000001d: 0x820,\n    0x8000001e: 0x20020,\n    0x8000001f: 0x8020800,\n  },\n];\n\n// Masks that select the SBOX input\nconst SBOX_MASK = [\n  0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n  0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f,\n];\n\n// Swap bits across the left and right words\nfunction exchangeLR(offset, mask) {\n  const t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n  this._rBlock ^= t;\n  this._lBlock ^= t << offset;\n}\n\nfunction exchangeRL(offset, mask) {\n  const t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n  this._lBlock ^= t;\n  this._rBlock ^= t << offset;\n}\n\n/**\n * DES block cipher algorithm.\n */\nclass DESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__[\"BlockCipher\"] {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n\n    // Select 56 bits according to PC1\n    const keyBits = [];\n    for (let i = 0; i < 56; i += 1) {\n      const keyBitPos = PC1[i] - 1;\n      keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - (keyBitPos % 32))) & 1;\n    }\n\n    // Assemble 16 subkeys\n    this._subKeys = [];\n    const subKeys = this._subKeys;\n    for (let nSubKey = 0; nSubKey < 16; nSubKey += 1) {\n      // Create subkey\n      subKeys[nSubKey] = [];\n      const subKey = subKeys[nSubKey];\n\n      // Shortcut\n      const bitShift = BIT_SHIFTS[nSubKey];\n\n      // Select 48 bits according to PC2\n      for (let i = 0; i < 24; i += 1) {\n        // Select from the left 28 key bits\n        subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - (i % 6));\n\n        // Select from the right 28 key bits\n        subKey[4 + ((i / 6) | 0)]\n          |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)]\n          << (31 - (i % 6));\n      }\n\n      // Since each subkey is applied to an expanded 32-bit input,\n      // the subkey can be broken into 8 values scaled to 32-bits,\n      // which allows the key to be used without expansion\n      subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n      for (let i = 1; i < 7; i += 1) {\n        subKey[i] >>>= ((i - 1) * 4 + 3);\n      }\n      subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n    }\n\n    // Compute inverse subkeys\n    this._invSubKeys = [];\n    const invSubKeys = this._invSubKeys;\n    for (let i = 0; i < 16; i += 1) {\n      invSubKeys[i] = subKeys[15 - i];\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._subKeys);\n  }\n\n  decryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._invSubKeys);\n  }\n\n  _doCryptBlock(M, offset, subKeys) {\n    const _M = M;\n\n    // Get input\n    this._lBlock = M[offset];\n    this._rBlock = M[offset + 1];\n\n    // Initial permutation\n    exchangeLR.call(this, 4, 0x0f0f0f0f);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeLR.call(this, 1, 0x55555555);\n\n    // Rounds\n    for (let round = 0; round < 16; round += 1) {\n      // Shortcuts\n      const subKey = subKeys[round];\n      const lBlock = this._lBlock;\n      const rBlock = this._rBlock;\n\n      // Feistel function\n      let f = 0;\n      for (let i = 0; i < 8; i += 1) {\n        f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n      }\n      this._lBlock = rBlock;\n      this._rBlock = lBlock ^ f;\n    }\n\n    // Undo swap from last round\n    const t = this._lBlock;\n    this._lBlock = this._rBlock;\n    this._rBlock = t;\n\n    // Final permutation\n    exchangeLR.call(this, 1, 0x55555555);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeLR.call(this, 4, 0x0f0f0f0f);\n\n    // Set output\n    _M[offset] = this._lBlock;\n    _M[offset + 1] = this._rBlock;\n  }\n}\nDESAlgo.keySize = 64 / 32;\nDESAlgo.ivSize = 64 / 32;\nDESAlgo.blockSize = 64 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n */\nconst DES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__[\"BlockCipher\"]._createHelper(DESAlgo);\n\n/**\n * Triple-DES block cipher algorithm.\n */\nclass TripleDESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__[\"BlockCipher\"] {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n    // Make sure the key length is valid (64, 128 or >= 192 bit)\n    if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n      throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n    }\n\n    // Extend the key according to the keying options defined in 3DES standard\n    const key1 = keyWords.slice(0, 2);\n    const key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n    const key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n    // Create DES instances\n    this._des1 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(key1));\n    this._des2 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(key2));\n    this._des3 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"].create(key3));\n  }\n\n  encryptBlock(M, offset) {\n    this._des1.encryptBlock(M, offset);\n    this._des2.decryptBlock(M, offset);\n    this._des3.encryptBlock(M, offset);\n  }\n\n  decryptBlock(M, offset) {\n    this._des3.decryptBlock(M, offset);\n    this._des2.encryptBlock(M, offset);\n    this._des1.decryptBlock(M, offset);\n  }\n}\nTripleDESAlgo.keySize = 192 / 32;\nTripleDESAlgo.ivSize = 64 / 32;\nTripleDESAlgo.blockSize = 64 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n */\nconst TripleDES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__[\"BlockCipher\"]._createHelper(TripleDESAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvdHJpcGxlZGVzLmpzP2ZiMGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFbUI7QUFHTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IsMkRBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxZQUFZLDJEQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsMkRBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxrREFBUztBQUNsRCx5Q0FBeUMsa0RBQVM7QUFDbEQseUNBQXlDLGtEQUFTO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsMkRBQVciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi90cmlwbGVkZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBCbG9ja0NpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbi8vIFBlcm11dGVkIENob2ljZSAxIGNvbnN0YW50c1xuY29uc3QgUEMxID0gW1xuICA1NywgNDksIDQxLCAzMywgMjUsIDE3LCA5LCAxLFxuICA1OCwgNTAsIDQyLCAzNCwgMjYsIDE4LCAxMCwgMixcbiAgNTksIDUxLCA0MywgMzUsIDI3LCAxOSwgMTEsIDMsXG4gIDYwLCA1MiwgNDQsIDM2LCA2MywgNTUsIDQ3LCAzOSxcbiAgMzEsIDIzLCAxNSwgNywgNjIsIDU0LCA0NiwgMzgsXG4gIDMwLCAyMiwgMTQsIDYsIDYxLCA1MywgNDUsIDM3LFxuICAyOSwgMjEsIDEzLCA1LCAyOCwgMjAsIDEyLCA0LFxuXTtcblxuLy8gUGVybXV0ZWQgQ2hvaWNlIDIgY29uc3RhbnRzXG5jb25zdCBQQzIgPSBbXG4gIDE0LCAxNywgMTEsIDI0LCAxLCA1LFxuICAzLCAyOCwgMTUsIDYsIDIxLCAxMCxcbiAgMjMsIDE5LCAxMiwgNCwgMjYsIDgsXG4gIDE2LCA3LCAyNywgMjAsIDEzLCAyLFxuICA0MSwgNTIsIDMxLCAzNywgNDcsIDU1LFxuICAzMCwgNDAsIDUxLCA0NSwgMzMsIDQ4LFxuICA0NCwgNDksIDM5LCA1NiwgMzQsIDUzLFxuICA0NiwgNDIsIDUwLCAzNiwgMjksIDMyLFxuXTtcblxuLy8gQ3VtdWxhdGl2ZSBiaXQgc2hpZnQgY29uc3RhbnRzXG5jb25zdCBCSVRfU0hJRlRTID0gWzEsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE1LCAxNywgMTksIDIxLCAyMywgMjUsIDI3LCAyOF07XG5cbi8vIFNCT1hlcyBhbmQgcm91bmQgcGVybXV0YXRpb24gY29uc3RhbnRzXG5jb25zdCBTQk9YX1AgPSBbXG4gIHtcbiAgICAweDA6IDB4ODA4MjAwLFxuICAgIDB4MTAwMDAwMDA6IDB4ODAwMCxcbiAgICAweDIwMDAwMDAwOiAweDgwODAwMixcbiAgICAweDMwMDAwMDAwOiAweDIsXG4gICAgMHg0MDAwMDAwMDogMHgyMDAsXG4gICAgMHg1MDAwMDAwMDogMHg4MDgyMDIsXG4gICAgMHg2MDAwMDAwMDogMHg4MDAyMDIsXG4gICAgMHg3MDAwMDAwMDogMHg4MDAwMDAsXG4gICAgMHg4MDAwMDAwMDogMHgyMDIsXG4gICAgMHg5MDAwMDAwMDogMHg4MDAyMDAsXG4gICAgMHhhMDAwMDAwMDogMHg4MjAwLFxuICAgIDB4YjAwMDAwMDA6IDB4ODA4MDAwLFxuICAgIDB4YzAwMDAwMDA6IDB4ODAwMixcbiAgICAweGQwMDAwMDAwOiAweDgwMDAwMixcbiAgICAweGUwMDAwMDAwOiAweDAsXG4gICAgMHhmMDAwMDAwMDogMHg4MjAyLFxuICAgIDB4ODAwMDAwMDogMHgwLFxuICAgIDB4MTgwMDAwMDA6IDB4ODA4MjAyLFxuICAgIDB4MjgwMDAwMDA6IDB4ODIwMixcbiAgICAweDM4MDAwMDAwOiAweDgwMDAsXG4gICAgMHg0ODAwMDAwMDogMHg4MDgyMDAsXG4gICAgMHg1ODAwMDAwMDogMHgyMDAsXG4gICAgMHg2ODAwMDAwMDogMHg4MDgwMDIsXG4gICAgMHg3ODAwMDAwMDogMHgyLFxuICAgIDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxuICAgIDB4OTgwMDAwMDA6IDB4ODIwMCxcbiAgICAweGE4MDAwMDAwOiAweDgwODAwMCxcbiAgICAweGI4MDAwMDAwOiAweDgwMDIwMixcbiAgICAweGM4MDAwMDAwOiAweDgwMDAwMixcbiAgICAweGQ4MDAwMDAwOiAweDgwMDIsXG4gICAgMHhlODAwMDAwMDogMHgyMDIsXG4gICAgMHhmODAwMDAwMDogMHg4MDAwMDAsXG4gICAgMHgxOiAweDgwMDAsXG4gICAgMHgxMDAwMDAwMTogMHgyLFxuICAgIDB4MjAwMDAwMDE6IDB4ODA4MjAwLFxuICAgIDB4MzAwMDAwMDE6IDB4ODAwMDAwLFxuICAgIDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxuICAgIDB4NTAwMDAwMDE6IDB4ODIwMCxcbiAgICAweDYwMDAwMDAxOiAweDIwMCxcbiAgICAweDcwMDAwMDAxOiAweDgwMDIwMixcbiAgICAweDgwMDAwMDAxOiAweDgwODIwMixcbiAgICAweDkwMDAwMDAxOiAweDgwODAwMCxcbiAgICAweGEwMDAwMDAxOiAweDgwMDAwMixcbiAgICAweGIwMDAwMDAxOiAweDgyMDIsXG4gICAgMHhjMDAwMDAwMTogMHgyMDIsXG4gICAgMHhkMDAwMDAwMTogMHg4MDAyMDAsXG4gICAgMHhlMDAwMDAwMTogMHg4MDAyLFxuICAgIDB4ZjAwMDAwMDE6IDB4MCxcbiAgICAweDgwMDAwMDE6IDB4ODA4MjAyLFxuICAgIDB4MTgwMDAwMDE6IDB4ODA4MDAwLFxuICAgIDB4MjgwMDAwMDE6IDB4ODAwMDAwLFxuICAgIDB4MzgwMDAwMDE6IDB4MjAwLFxuICAgIDB4NDgwMDAwMDE6IDB4ODAwMCxcbiAgICAweDU4MDAwMDAxOiAweDgwMDAwMixcbiAgICAweDY4MDAwMDAxOiAweDIsXG4gICAgMHg3ODAwMDAwMTogMHg4MjAyLFxuICAgIDB4ODgwMDAwMDE6IDB4ODAwMixcbiAgICAweDk4MDAwMDAxOiAweDgwMDIwMixcbiAgICAweGE4MDAwMDAxOiAweDIwMixcbiAgICAweGI4MDAwMDAxOiAweDgwODIwMCxcbiAgICAweGM4MDAwMDAxOiAweDgwMDIwMCxcbiAgICAweGQ4MDAwMDAxOiAweDAsXG4gICAgMHhlODAwMDAwMTogMHg4MjAwLFxuICAgIDB4ZjgwMDAwMDE6IDB4ODA4MDAyLFxuICB9LFxuICB7XG4gICAgMHgwOiAweDQwMDg0MDEwLFxuICAgIDB4MTAwMDAwMDogMHg0MDAwLFxuICAgIDB4MjAwMDAwMDogMHg4MDAwMCxcbiAgICAweDMwMDAwMDA6IDB4NDAwODAwMTAsXG4gICAgMHg0MDAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4NTAwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDYwMDAwMDA6IDB4NDAwMDQwMDAsXG4gICAgMHg3MDAwMDAwOiAweDEwLFxuICAgIDB4ODAwMDAwMDogMHg4NDAwMCxcbiAgICAweDkwMDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHhhMDAwMDAwOiAweDQwMDAwMDAwLFxuICAgIDB4YjAwMDAwMDogMHg4NDAxMCxcbiAgICAweGMwMDAwMDA6IDB4ODAwMTAsXG4gICAgMHhkMDAwMDAwOiAweDAsXG4gICAgMHhlMDAwMDAwOiAweDQwMTAsXG4gICAgMHhmMDAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4ODAwMDAwOiAweDQwMDA0MDAwLFxuICAgIDB4MTgwMDAwMDogMHg4NDAxMCxcbiAgICAweDI4MDAwMDA6IDB4MTAsXG4gICAgMHgzODAwMDAwOiAweDQwMDA0MDEwLFxuICAgIDB4NDgwMDAwMDogMHg0MDA4NDAxMCxcbiAgICAweDU4MDAwMDA6IDB4NDAwMDAwMDAsXG4gICAgMHg2ODAwMDAwOiAweDgwMDAwLFxuICAgIDB4NzgwMDAwMDogMHg0MDA4MDAxMCxcbiAgICAweDg4MDAwMDA6IDB4ODAwMTAsXG4gICAgMHg5ODAwMDAwOiAweDAsXG4gICAgMHhhODAwMDAwOiAweDQwMDAsXG4gICAgMHhiODAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4YzgwMDAwMDogMHg0MDAwMDAxMCxcbiAgICAweGQ4MDAwMDA6IDB4ODQwMDAsXG4gICAgMHhlODAwMDAwOiAweDQwMDg0MDAwLFxuICAgIDB4ZjgwMDAwMDogMHg0MDEwLFxuICAgIDB4MTAwMDAwMDA6IDB4MCxcbiAgICAweDExMDAwMDAwOiAweDQwMDgwMDEwLFxuICAgIDB4MTIwMDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHgxMzAwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDE0MDAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4MTUwMDAwMDA6IDB4MTAsXG4gICAgMHgxNjAwMDAwMDogMHg4NDAxMCxcbiAgICAweDE3MDAwMDAwOiAweDQwMDAsXG4gICAgMHgxODAwMDAwMDogMHg0MDEwLFxuICAgIDB4MTkwMDAwMDA6IDB4ODAwMDAsXG4gICAgMHgxYTAwMDAwMDogMHg4MDAxMCxcbiAgICAweDFiMDAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4MWMwMDAwMDA6IDB4ODQwMDAsXG4gICAgMHgxZDAwMDAwMDogMHg0MDAwNDAwMCxcbiAgICAweDFlMDAwMDAwOiAweDQwMDAwMDAwLFxuICAgIDB4MWYwMDAwMDA6IDB4NDAwODQwMTAsXG4gICAgMHgxMDgwMDAwMDogMHg4NDAxMCxcbiAgICAweDExODAwMDAwOiAweDgwMDAwLFxuICAgIDB4MTI4MDAwMDA6IDB4NDAwODAwMDAsXG4gICAgMHgxMzgwMDAwMDogMHg0MDAwLFxuICAgIDB4MTQ4MDAwMDA6IDB4NDAwMDQwMDAsXG4gICAgMHgxNTgwMDAwMDogMHg0MDA4NDAxMCxcbiAgICAweDE2ODAwMDAwOiAweDEwLFxuICAgIDB4MTc4MDAwMDA6IDB4NDAwMDAwMDAsXG4gICAgMHgxODgwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDE5ODAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4MWE4MDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHgxYjgwMDAwMDogMHg4MDAxMCxcbiAgICAweDFjODAwMDAwOiAweDAsXG4gICAgMHgxZDgwMDAwMDogMHg0MDEwLFxuICAgIDB4MWU4MDAwMDA6IDB4NDAwODAwMTAsXG4gICAgMHgxZjgwMDAwMDogMHg4NDAwMCxcbiAgfSxcbiAge1xuICAgIDB4MDogMHgxMDQsXG4gICAgMHgxMDAwMDA6IDB4MCxcbiAgICAweDIwMDAwMDogMHg0MDAwMTAwLFxuICAgIDB4MzAwMDAwOiAweDEwMTA0LFxuICAgIDB4NDAwMDAwOiAweDEwMDA0LFxuICAgIDB4NTAwMDAwOiAweDQwMDAwMDQsXG4gICAgMHg2MDAwMDA6IDB4NDAxMDEwNCxcbiAgICAweDcwMDAwMDogMHg0MDEwMDAwLFxuICAgIDB4ODAwMDAwOiAweDQwMDAwMDAsXG4gICAgMHg5MDAwMDA6IDB4NDAxMDEwMCxcbiAgICAweGEwMDAwMDogMHgxMDEwMCxcbiAgICAweGIwMDAwMDogMHg0MDEwMDA0LFxuICAgIDB4YzAwMDAwOiAweDQwMDAxMDQsXG4gICAgMHhkMDAwMDA6IDB4MTAwMDAsXG4gICAgMHhlMDAwMDA6IDB4NCxcbiAgICAweGYwMDAwMDogMHgxMDAsXG4gICAgMHg4MDAwMDogMHg0MDEwMTAwLFxuICAgIDB4MTgwMDAwOiAweDQwMTAwMDQsXG4gICAgMHgyODAwMDA6IDB4MCxcbiAgICAweDM4MDAwMDogMHg0MDAwMTAwLFxuICAgIDB4NDgwMDAwOiAweDQwMDAwMDQsXG4gICAgMHg1ODAwMDA6IDB4MTAwMDAsXG4gICAgMHg2ODAwMDA6IDB4MTAwMDQsXG4gICAgMHg3ODAwMDA6IDB4MTA0LFxuICAgIDB4ODgwMDAwOiAweDQsXG4gICAgMHg5ODAwMDA6IDB4MTAwLFxuICAgIDB4YTgwMDAwOiAweDQwMTAwMDAsXG4gICAgMHhiODAwMDA6IDB4MTAxMDQsXG4gICAgMHhjODAwMDA6IDB4MTAxMDAsXG4gICAgMHhkODAwMDA6IDB4NDAwMDEwNCxcbiAgICAweGU4MDAwMDogMHg0MDEwMTA0LFxuICAgIDB4ZjgwMDAwOiAweDQwMDAwMDAsXG4gICAgMHgxMDAwMDAwOiAweDQwMTAxMDAsXG4gICAgMHgxMTAwMDAwOiAweDEwMDA0LFxuICAgIDB4MTIwMDAwMDogMHgxMDAwMCxcbiAgICAweDEzMDAwMDA6IDB4NDAwMDEwMCxcbiAgICAweDE0MDAwMDA6IDB4MTAwLFxuICAgIDB4MTUwMDAwMDogMHg0MDEwMTA0LFxuICAgIDB4MTYwMDAwMDogMHg0MDAwMDA0LFxuICAgIDB4MTcwMDAwMDogMHgwLFxuICAgIDB4MTgwMDAwMDogMHg0MDAwMTA0LFxuICAgIDB4MTkwMDAwMDogMHg0MDAwMDAwLFxuICAgIDB4MWEwMDAwMDogMHg0LFxuICAgIDB4MWIwMDAwMDogMHgxMDEwMCxcbiAgICAweDFjMDAwMDA6IDB4NDAxMDAwMCxcbiAgICAweDFkMDAwMDA6IDB4MTA0LFxuICAgIDB4MWUwMDAwMDogMHgxMDEwNCxcbiAgICAweDFmMDAwMDA6IDB4NDAxMDAwNCxcbiAgICAweDEwODAwMDA6IDB4NDAwMDAwMCxcbiAgICAweDExODAwMDA6IDB4MTA0LFxuICAgIDB4MTI4MDAwMDogMHg0MDEwMTAwLFxuICAgIDB4MTM4MDAwMDogMHgwLFxuICAgIDB4MTQ4MDAwMDogMHgxMDAwNCxcbiAgICAweDE1ODAwMDA6IDB4NDAwMDEwMCxcbiAgICAweDE2ODAwMDA6IDB4MTAwLFxuICAgIDB4MTc4MDAwMDogMHg0MDEwMDA0LFxuICAgIDB4MTg4MDAwMDogMHgxMDAwMCxcbiAgICAweDE5ODAwMDA6IDB4NDAxMDEwNCxcbiAgICAweDFhODAwMDA6IDB4MTAxMDQsXG4gICAgMHgxYjgwMDAwOiAweDQwMDAwMDQsXG4gICAgMHgxYzgwMDAwOiAweDQwMDAxMDQsXG4gICAgMHgxZDgwMDAwOiAweDQwMTAwMDAsXG4gICAgMHgxZTgwMDAwOiAweDQsXG4gICAgMHgxZjgwMDAwOiAweDEwMTAwLFxuICB9LFxuICB7XG4gICAgMHgwOiAweDgwNDAxMDAwLFxuICAgIDB4MTAwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgyMDAwMDogMHg0MDEwNDAsXG4gICAgMHgzMDAwMDogMHg4MDQwMDAwMCxcbiAgICAweDQwMDAwOiAweDAsXG4gICAgMHg1MDAwMDogMHg0MDEwMDAsXG4gICAgMHg2MDAwMDogMHg4MDAwMDA0MCxcbiAgICAweDcwMDAwOiAweDQwMDA0MCxcbiAgICAweDgwMDAwOiAweDgwMDAwMDAwLFxuICAgIDB4OTAwMDA6IDB4NDAwMDAwLFxuICAgIDB4YTAwMDA6IDB4NDAsXG4gICAgMHhiMDAwMDogMHg4MDAwMTAwMCxcbiAgICAweGMwMDAwOiAweDgwNDAwMDQwLFxuICAgIDB4ZDAwMDA6IDB4MTA0MCxcbiAgICAweGUwMDAwOiAweDEwMDAsXG4gICAgMHhmMDAwMDogMHg4MDQwMTA0MCxcbiAgICAweDgwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgxODAwMDogMHg0MCxcbiAgICAweDI4MDAwOiAweDgwNDAwMDQwLFxuICAgIDB4MzgwMDA6IDB4ODAwMDEwMDAsXG4gICAgMHg0ODAwMDogMHg0MDEwMDAsXG4gICAgMHg1ODAwMDogMHg4MDQwMTA0MCxcbiAgICAweDY4MDAwOiAweDAsXG4gICAgMHg3ODAwMDogMHg4MDQwMDAwMCxcbiAgICAweDg4MDAwOiAweDEwMDAsXG4gICAgMHg5ODAwMDogMHg4MDQwMTAwMCxcbiAgICAweGE4MDAwOiAweDQwMDAwMCxcbiAgICAweGI4MDAwOiAweDEwNDAsXG4gICAgMHhjODAwMDogMHg4MDAwMDAwMCxcbiAgICAweGQ4MDAwOiAweDQwMDA0MCxcbiAgICAweGU4MDAwOiAweDQwMTA0MCxcbiAgICAweGY4MDAwOiAweDgwMDAwMDQwLFxuICAgIDB4MTAwMDAwOiAweDQwMDA0MCxcbiAgICAweDExMDAwMDogMHg0MDEwMDAsXG4gICAgMHgxMjAwMDA6IDB4ODAwMDAwNDAsXG4gICAgMHgxMzAwMDA6IDB4MCxcbiAgICAweDE0MDAwMDogMHgxMDQwLFxuICAgIDB4MTUwMDAwOiAweDgwNDAwMDQwLFxuICAgIDB4MTYwMDAwOiAweDgwNDAxMDAwLFxuICAgIDB4MTcwMDAwOiAweDgwMDAxMDQwLFxuICAgIDB4MTgwMDAwOiAweDgwNDAxMDQwLFxuICAgIDB4MTkwMDAwOiAweDgwMDAwMDAwLFxuICAgIDB4MWEwMDAwOiAweDgwNDAwMDAwLFxuICAgIDB4MWIwMDAwOiAweDQwMTA0MCxcbiAgICAweDFjMDAwMDogMHg4MDAwMTAwMCxcbiAgICAweDFkMDAwMDogMHg0MDAwMDAsXG4gICAgMHgxZTAwMDA6IDB4NDAsXG4gICAgMHgxZjAwMDA6IDB4MTAwMCxcbiAgICAweDEwODAwMDogMHg4MDQwMDAwMCxcbiAgICAweDExODAwMDogMHg4MDQwMTA0MCxcbiAgICAweDEyODAwMDogMHgwLFxuICAgIDB4MTM4MDAwOiAweDQwMTAwMCxcbiAgICAweDE0ODAwMDogMHg0MDAwNDAsXG4gICAgMHgxNTgwMDA6IDB4ODAwMDAwMDAsXG4gICAgMHgxNjgwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgxNzgwMDA6IDB4NDAsXG4gICAgMHgxODgwMDA6IDB4ODAwMDAwNDAsXG4gICAgMHgxOTgwMDA6IDB4MTAwMCxcbiAgICAweDFhODAwMDogMHg4MDAwMTAwMCxcbiAgICAweDFiODAwMDogMHg4MDQwMDA0MCxcbiAgICAweDFjODAwMDogMHgxMDQwLFxuICAgIDB4MWQ4MDAwOiAweDgwNDAxMDAwLFxuICAgIDB4MWU4MDAwOiAweDQwMDAwMCxcbiAgICAweDFmODAwMDogMHg0MDEwNDAsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4ODAsXG4gICAgMHgxMDAwOiAweDEwNDAwMDAsXG4gICAgMHgyMDAwOiAweDQwMDAwLFxuICAgIDB4MzAwMDogMHgyMDAwMDAwMCxcbiAgICAweDQwMDA6IDB4MjAwNDAwODAsXG4gICAgMHg1MDAwOiAweDEwMDAwODAsXG4gICAgMHg2MDAwOiAweDIxMDAwMDgwLFxuICAgIDB4NzAwMDogMHg0MDA4MCxcbiAgICAweDgwMDA6IDB4MTAwMDAwMCxcbiAgICAweDkwMDA6IDB4MjAwNDAwMDAsXG4gICAgMHhhMDAwOiAweDIwMDAwMDgwLFxuICAgIDB4YjAwMDogMHgyMTA0MDA4MCxcbiAgICAweGMwMDA6IDB4MjEwNDAwMDAsXG4gICAgMHhkMDAwOiAweDAsXG4gICAgMHhlMDAwOiAweDEwNDAwODAsXG4gICAgMHhmMDAwOiAweDIxMDAwMDAwLFxuICAgIDB4ODAwOiAweDEwNDAwODAsXG4gICAgMHgxODAwOiAweDIxMDAwMDgwLFxuICAgIDB4MjgwMDogMHg4MCxcbiAgICAweDM4MDA6IDB4MTA0MDAwMCxcbiAgICAweDQ4MDA6IDB4NDAwMDAsXG4gICAgMHg1ODAwOiAweDIwMDQwMDgwLFxuICAgIDB4NjgwMDogMHgyMTA0MDAwMCxcbiAgICAweDc4MDA6IDB4MjAwMDAwMDAsXG4gICAgMHg4ODAwOiAweDIwMDQwMDAwLFxuICAgIDB4OTgwMDogMHgwLFxuICAgIDB4YTgwMDogMHgyMTA0MDA4MCxcbiAgICAweGI4MDA6IDB4MTAwMDA4MCxcbiAgICAweGM4MDA6IDB4MjAwMDAwODAsXG4gICAgMHhkODAwOiAweDIxMDAwMDAwLFxuICAgIDB4ZTgwMDogMHgxMDAwMDAwLFxuICAgIDB4ZjgwMDogMHg0MDA4MCxcbiAgICAweDEwMDAwOiAweDQwMDAwLFxuICAgIDB4MTEwMDA6IDB4ODAsXG4gICAgMHgxMjAwMDogMHgyMDAwMDAwMCxcbiAgICAweDEzMDAwOiAweDIxMDAwMDgwLFxuICAgIDB4MTQwMDA6IDB4MTAwMDA4MCxcbiAgICAweDE1MDAwOiAweDIxMDQwMDAwLFxuICAgIDB4MTYwMDA6IDB4MjAwNDAwODAsXG4gICAgMHgxNzAwMDogMHgxMDAwMDAwLFxuICAgIDB4MTgwMDA6IDB4MjEwNDAwODAsXG4gICAgMHgxOTAwMDogMHgyMTAwMDAwMCxcbiAgICAweDFhMDAwOiAweDEwNDAwMDAsXG4gICAgMHgxYjAwMDogMHgyMDA0MDAwMCxcbiAgICAweDFjMDAwOiAweDQwMDgwLFxuICAgIDB4MWQwMDA6IDB4MjAwMDAwODAsXG4gICAgMHgxZTAwMDogMHgwLFxuICAgIDB4MWYwMDA6IDB4MTA0MDA4MCxcbiAgICAweDEwODAwOiAweDIxMDAwMDgwLFxuICAgIDB4MTE4MDA6IDB4MTAwMDAwMCxcbiAgICAweDEyODAwOiAweDEwNDAwMDAsXG4gICAgMHgxMzgwMDogMHgyMDA0MDA4MCxcbiAgICAweDE0ODAwOiAweDIwMDAwMDAwLFxuICAgIDB4MTU4MDA6IDB4MTA0MDA4MCxcbiAgICAweDE2ODAwOiAweDgwLFxuICAgIDB4MTc4MDA6IDB4MjEwNDAwMDAsXG4gICAgMHgxODgwMDogMHg0MDA4MCxcbiAgICAweDE5ODAwOiAweDIxMDQwMDgwLFxuICAgIDB4MWE4MDA6IDB4MCxcbiAgICAweDFiODAwOiAweDIxMDAwMDAwLFxuICAgIDB4MWM4MDA6IDB4MTAwMDA4MCxcbiAgICAweDFkODAwOiAweDQwMDAwLFxuICAgIDB4MWU4MDA6IDB4MjAwNDAwMDAsXG4gICAgMHgxZjgwMDogMHgyMDAwMDA4MCxcbiAgfSxcbiAge1xuICAgIDB4MDogMHgxMDAwMDAwOCxcbiAgICAweDEwMDogMHgyMDAwLFxuICAgIDB4MjAwOiAweDEwMjAwMDAwLFxuICAgIDB4MzAwOiAweDEwMjAyMDA4LFxuICAgIDB4NDAwOiAweDEwMDAyMDAwLFxuICAgIDB4NTAwOiAweDIwMDAwMCxcbiAgICAweDYwMDogMHgyMDAwMDgsXG4gICAgMHg3MDA6IDB4MTAwMDAwMDAsXG4gICAgMHg4MDA6IDB4MCxcbiAgICAweDkwMDogMHgxMDAwMjAwOCxcbiAgICAweGEwMDogMHgyMDIwMDAsXG4gICAgMHhiMDA6IDB4OCxcbiAgICAweGMwMDogMHgxMDIwMDAwOCxcbiAgICAweGQwMDogMHgyMDIwMDgsXG4gICAgMHhlMDA6IDB4MjAwOCxcbiAgICAweGYwMDogMHgxMDIwMjAwMCxcbiAgICAweDgwOiAweDEwMjAwMDAwLFxuICAgIDB4MTgwOiAweDEwMjAyMDA4LFxuICAgIDB4MjgwOiAweDgsXG4gICAgMHgzODA6IDB4MjAwMDAwLFxuICAgIDB4NDgwOiAweDIwMjAwOCxcbiAgICAweDU4MDogMHgxMDAwMDAwOCxcbiAgICAweDY4MDogMHgxMDAwMjAwMCxcbiAgICAweDc4MDogMHgyMDA4LFxuICAgIDB4ODgwOiAweDIwMDAwOCxcbiAgICAweDk4MDogMHgyMDAwLFxuICAgIDB4YTgwOiAweDEwMDAyMDA4LFxuICAgIDB4YjgwOiAweDEwMjAwMDA4LFxuICAgIDB4YzgwOiAweDAsXG4gICAgMHhkODA6IDB4MTAyMDIwMDAsXG4gICAgMHhlODA6IDB4MjAyMDAwLFxuICAgIDB4ZjgwOiAweDEwMDAwMDAwLFxuICAgIDB4MTAwMDogMHgxMDAwMjAwMCxcbiAgICAweDExMDA6IDB4MTAyMDAwMDgsXG4gICAgMHgxMjAwOiAweDEwMjAyMDA4LFxuICAgIDB4MTMwMDogMHgyMDA4LFxuICAgIDB4MTQwMDogMHgyMDAwMDAsXG4gICAgMHgxNTAwOiAweDEwMDAwMDAwLFxuICAgIDB4MTYwMDogMHgxMDAwMDAwOCxcbiAgICAweDE3MDA6IDB4MjAyMDAwLFxuICAgIDB4MTgwMDogMHgyMDIwMDgsXG4gICAgMHgxOTAwOiAweDAsXG4gICAgMHgxYTAwOiAweDgsXG4gICAgMHgxYjAwOiAweDEwMjAwMDAwLFxuICAgIDB4MWMwMDogMHgyMDAwLFxuICAgIDB4MWQwMDogMHgxMDAwMjAwOCxcbiAgICAweDFlMDA6IDB4MTAyMDIwMDAsXG4gICAgMHgxZjAwOiAweDIwMDAwOCxcbiAgICAweDEwODA6IDB4OCxcbiAgICAweDExODA6IDB4MjAyMDAwLFxuICAgIDB4MTI4MDogMHgyMDAwMDAsXG4gICAgMHgxMzgwOiAweDEwMDAwMDA4LFxuICAgIDB4MTQ4MDogMHgxMDAwMjAwMCxcbiAgICAweDE1ODA6IDB4MjAwOCxcbiAgICAweDE2ODA6IDB4MTAyMDIwMDgsXG4gICAgMHgxNzgwOiAweDEwMjAwMDAwLFxuICAgIDB4MTg4MDogMHgxMDIwMjAwMCxcbiAgICAweDE5ODA6IDB4MTAyMDAwMDgsXG4gICAgMHgxYTgwOiAweDIwMDAsXG4gICAgMHgxYjgwOiAweDIwMjAwOCxcbiAgICAweDFjODA6IDB4MjAwMDA4LFxuICAgIDB4MWQ4MDogMHgwLFxuICAgIDB4MWU4MDogMHgxMDAwMDAwMCxcbiAgICAweDFmODA6IDB4MTAwMDIwMDgsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4MTAwMDAwLFxuICAgIDB4MTA6IDB4MjAwMDQwMSxcbiAgICAweDIwOiAweDQwMCxcbiAgICAweDMwOiAweDEwMDQwMSxcbiAgICAweDQwOiAweDIxMDA0MDEsXG4gICAgMHg1MDogMHgwLFxuICAgIDB4NjA6IDB4MSxcbiAgICAweDcwOiAweDIxMDAwMDEsXG4gICAgMHg4MDogMHgyMDAwNDAwLFxuICAgIDB4OTA6IDB4MTAwMDAxLFxuICAgIDB4YTA6IDB4MjAwMDAwMSxcbiAgICAweGIwOiAweDIxMDA0MDAsXG4gICAgMHhjMDogMHgyMTAwMDAwLFxuICAgIDB4ZDA6IDB4NDAxLFxuICAgIDB4ZTA6IDB4MTAwNDAwLFxuICAgIDB4ZjA6IDB4MjAwMDAwMCxcbiAgICAweDg6IDB4MjEwMDAwMSxcbiAgICAweDE4OiAweDAsXG4gICAgMHgyODogMHgyMDAwNDAxLFxuICAgIDB4Mzg6IDB4MjEwMDQwMCxcbiAgICAweDQ4OiAweDEwMDAwMCxcbiAgICAweDU4OiAweDIwMDAwMDEsXG4gICAgMHg2ODogMHgyMDAwMDAwLFxuICAgIDB4Nzg6IDB4NDAxLFxuICAgIDB4ODg6IDB4MTAwNDAxLFxuICAgIDB4OTg6IDB4MjAwMDQwMCxcbiAgICAweGE4OiAweDIxMDAwMDAsXG4gICAgMHhiODogMHgxMDAwMDEsXG4gICAgMHhjODogMHg0MDAsXG4gICAgMHhkODogMHgyMTAwNDAxLFxuICAgIDB4ZTg6IDB4MSxcbiAgICAweGY4OiAweDEwMDQwMCxcbiAgICAweDEwMDogMHgyMDAwMDAwLFxuICAgIDB4MTEwOiAweDEwMDAwMCxcbiAgICAweDEyMDogMHgyMDAwNDAxLFxuICAgIDB4MTMwOiAweDIxMDAwMDEsXG4gICAgMHgxNDA6IDB4MTAwMDAxLFxuICAgIDB4MTUwOiAweDIwMDA0MDAsXG4gICAgMHgxNjA6IDB4MjEwMDQwMCxcbiAgICAweDE3MDogMHgxMDA0MDEsXG4gICAgMHgxODA6IDB4NDAxLFxuICAgIDB4MTkwOiAweDIxMDA0MDEsXG4gICAgMHgxYTA6IDB4MTAwNDAwLFxuICAgIDB4MWIwOiAweDEsXG4gICAgMHgxYzA6IDB4MCxcbiAgICAweDFkMDogMHgyMTAwMDAwLFxuICAgIDB4MWUwOiAweDIwMDAwMDEsXG4gICAgMHgxZjA6IDB4NDAwLFxuICAgIDB4MTA4OiAweDEwMDQwMCxcbiAgICAweDExODogMHgyMDAwNDAxLFxuICAgIDB4MTI4OiAweDIxMDAwMDEsXG4gICAgMHgxMzg6IDB4MSxcbiAgICAweDE0ODogMHgyMDAwMDAwLFxuICAgIDB4MTU4OiAweDEwMDAwMCxcbiAgICAweDE2ODogMHg0MDEsXG4gICAgMHgxNzg6IDB4MjEwMDQwMCxcbiAgICAweDE4ODogMHgyMDAwMDAxLFxuICAgIDB4MTk4OiAweDIxMDAwMDAsXG4gICAgMHgxYTg6IDB4MCxcbiAgICAweDFiODogMHgyMTAwNDAxLFxuICAgIDB4MWM4OiAweDEwMDQwMSxcbiAgICAweDFkODogMHg0MDAsXG4gICAgMHgxZTg6IDB4MjAwMDQwMCxcbiAgICAweDFmODogMHgxMDAwMDEsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4ODAwMDgyMCxcbiAgICAweDE6IDB4MjAwMDAsXG4gICAgMHgyOiAweDgwMDAwMDAsXG4gICAgMHgzOiAweDIwLFxuICAgIDB4NDogMHgyMDAyMCxcbiAgICAweDU6IDB4ODAyMDgyMCxcbiAgICAweDY6IDB4ODAyMDgwMCxcbiAgICAweDc6IDB4ODAwLFxuICAgIDB4ODogMHg4MDIwMDAwLFxuICAgIDB4OTogMHg4MDAwODAwLFxuICAgIDB4YTogMHgyMDgwMCxcbiAgICAweGI6IDB4ODAyMDAyMCxcbiAgICAweGM6IDB4ODIwLFxuICAgIDB4ZDogMHgwLFxuICAgIDB4ZTogMHg4MDAwMDIwLFxuICAgIDB4ZjogMHgyMDgyMCxcbiAgICAweDgwMDAwMDAwOiAweDgwMCxcbiAgICAweDgwMDAwMDAxOiAweDgwMjA4MjAsXG4gICAgMHg4MDAwMDAwMjogMHg4MDAwODIwLFxuICAgIDB4ODAwMDAwMDM6IDB4ODAwMDAwMCxcbiAgICAweDgwMDAwMDA0OiAweDgwMjAwMDAsXG4gICAgMHg4MDAwMDAwNTogMHgyMDgwMCxcbiAgICAweDgwMDAwMDA2OiAweDIwODIwLFxuICAgIDB4ODAwMDAwMDc6IDB4MjAsXG4gICAgMHg4MDAwMDAwODogMHg4MDAwMDIwLFxuICAgIDB4ODAwMDAwMDk6IDB4ODIwLFxuICAgIDB4ODAwMDAwMGE6IDB4MjAwMjAsXG4gICAgMHg4MDAwMDAwYjogMHg4MDIwODAwLFxuICAgIDB4ODAwMDAwMGM6IDB4MCxcbiAgICAweDgwMDAwMDBkOiAweDgwMjAwMjAsXG4gICAgMHg4MDAwMDAwZTogMHg4MDAwODAwLFxuICAgIDB4ODAwMDAwMGY6IDB4MjAwMDAsXG4gICAgMHgxMDogMHgyMDgyMCxcbiAgICAweDExOiAweDgwMjA4MDAsXG4gICAgMHgxMjogMHgyMCxcbiAgICAweDEzOiAweDgwMCxcbiAgICAweDE0OiAweDgwMDA4MDAsXG4gICAgMHgxNTogMHg4MDAwMDIwLFxuICAgIDB4MTY6IDB4ODAyMDAyMCxcbiAgICAweDE3OiAweDIwMDAwLFxuICAgIDB4MTg6IDB4MCxcbiAgICAweDE5OiAweDIwMDIwLFxuICAgIDB4MWE6IDB4ODAyMDAwMCxcbiAgICAweDFiOiAweDgwMDA4MjAsXG4gICAgMHgxYzogMHg4MDIwODIwLFxuICAgIDB4MWQ6IDB4MjA4MDAsXG4gICAgMHgxZTogMHg4MjAsXG4gICAgMHgxZjogMHg4MDAwMDAwLFxuICAgIDB4ODAwMDAwMTA6IDB4MjAwMDAsXG4gICAgMHg4MDAwMDAxMTogMHg4MDAsXG4gICAgMHg4MDAwMDAxMjogMHg4MDIwMDIwLFxuICAgIDB4ODAwMDAwMTM6IDB4MjA4MjAsXG4gICAgMHg4MDAwMDAxNDogMHgyMCxcbiAgICAweDgwMDAwMDE1OiAweDgwMjAwMDAsXG4gICAgMHg4MDAwMDAxNjogMHg4MDAwMDAwLFxuICAgIDB4ODAwMDAwMTc6IDB4ODAwMDgyMCxcbiAgICAweDgwMDAwMDE4OiAweDgwMjA4MjAsXG4gICAgMHg4MDAwMDAxOTogMHg4MDAwMDIwLFxuICAgIDB4ODAwMDAwMWE6IDB4ODAwMDgwMCxcbiAgICAweDgwMDAwMDFiOiAweDAsXG4gICAgMHg4MDAwMDAxYzogMHgyMDgwMCxcbiAgICAweDgwMDAwMDFkOiAweDgyMCxcbiAgICAweDgwMDAwMDFlOiAweDIwMDIwLFxuICAgIDB4ODAwMDAwMWY6IDB4ODAyMDgwMCxcbiAgfSxcbl07XG5cbi8vIE1hc2tzIHRoYXQgc2VsZWN0IHRoZSBTQk9YIGlucHV0XG5jb25zdCBTQk9YX01BU0sgPSBbXG4gIDB4ZjgwMDAwMDEsIDB4MWY4MDAwMDAsIDB4MDFmODAwMDAsIDB4MDAxZjgwMDAsXG4gIDB4MDAwMWY4MDAsIDB4MDAwMDFmODAsIDB4MDAwMDAxZjgsIDB4ODAwMDAwMWYsXG5dO1xuXG4vLyBTd2FwIGJpdHMgYWNyb3NzIHRoZSBsZWZ0IGFuZCByaWdodCB3b3Jkc1xuZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsIG1hc2spIHtcbiAgY29uc3QgdCA9ICgodGhpcy5fbEJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fckJsb2NrKSAmIG1hc2s7XG4gIHRoaXMuX3JCbG9jayBePSB0O1xuICB0aGlzLl9sQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGV4Y2hhbmdlUkwob2Zmc2V0LCBtYXNrKSB7XG4gIGNvbnN0IHQgPSAoKHRoaXMuX3JCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xuICB0aGlzLl9sQmxvY2sgXj0gdDtcbiAgdGhpcy5fckJsb2NrIF49IHQgPDwgb2Zmc2V0O1xufVxuXG4vKipcbiAqIERFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgREVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG4gICAgLy8gU2VsZWN0IDU2IGJpdHMgYWNjb3JkaW5nIHRvIFBDMVxuICAgIGNvbnN0IGtleUJpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU2OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGtleUJpdFBvcyA9IFBDMVtpXSAtIDE7XG4gICAgICBrZXlCaXRzW2ldID0gKGtleVdvcmRzW2tleUJpdFBvcyA+Pj4gNV0gPj4+ICgzMSAtIChrZXlCaXRQb3MgJSAzMikpKSAmIDE7XG4gICAgfVxuXG4gICAgLy8gQXNzZW1ibGUgMTYgc3Via2V5c1xuICAgIHRoaXMuX3N1YktleXMgPSBbXTtcbiAgICBjb25zdCBzdWJLZXlzID0gdGhpcy5fc3ViS2V5cztcbiAgICBmb3IgKGxldCBuU3ViS2V5ID0gMDsgblN1YktleSA8IDE2OyBuU3ViS2V5ICs9IDEpIHtcbiAgICAgIC8vIENyZWF0ZSBzdWJrZXlcbiAgICAgIHN1YktleXNbblN1YktleV0gPSBbXTtcbiAgICAgIGNvbnN0IHN1YktleSA9IHN1YktleXNbblN1YktleV07XG5cbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBiaXRTaGlmdCA9IEJJVF9TSElGVFNbblN1YktleV07XG5cbiAgICAgIC8vIFNlbGVjdCA0OCBiaXRzIGFjY29yZGluZyB0byBQQzJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkgKz0gMSkge1xuICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgbGVmdCAyOCBrZXkgYml0c1xuICAgICAgICBzdWJLZXlbKGkgLyA2KSB8IDBdIHw9IGtleUJpdHNbKChQQzJbaV0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4XSA8PCAoMzEgLSAoaSAlIDYpKTtcblxuICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgcmlnaHQgMjgga2V5IGJpdHNcbiAgICAgICAgc3ViS2V5WzQgKyAoKGkgLyA2KSB8IDApXVxuICAgICAgICAgIHw9IGtleUJpdHNbMjggKyAoKChQQzJbaSArIDI0XSAtIDEpICsgYml0U2hpZnQpICUgMjgpXVxuICAgICAgICAgIDw8ICgzMSAtIChpICUgNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSBlYWNoIHN1YmtleSBpcyBhcHBsaWVkIHRvIGFuIGV4cGFuZGVkIDMyLWJpdCBpbnB1dCxcbiAgICAgIC8vIHRoZSBzdWJrZXkgY2FuIGJlIGJyb2tlbiBpbnRvIDggdmFsdWVzIHNjYWxlZCB0byAzMi1iaXRzLFxuICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBrZXkgdG8gYmUgdXNlZCB3aXRob3V0IGV4cGFuc2lvblxuICAgICAgc3ViS2V5WzBdID0gKHN1YktleVswXSA8PCAxKSB8IChzdWJLZXlbMF0gPj4+IDMxKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgIHN1YktleVtpXSA+Pj49ICgoaSAtIDEpICogNCArIDMpO1xuICAgICAgfVxuICAgICAgc3ViS2V5WzddID0gKHN1YktleVs3XSA8PCA1KSB8IChzdWJLZXlbN10gPj4+IDI3KTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGludmVyc2Ugc3Via2V5c1xuICAgIHRoaXMuX2ludlN1YktleXMgPSBbXTtcbiAgICBjb25zdCBpbnZTdWJLZXlzID0gdGhpcy5faW52U3ViS2V5cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGludlN1YktleXNbaV0gPSBzdWJLZXlzWzE1IC0gaV07XG4gICAgfVxuICB9XG5cbiAgZW5jcnlwdEJsb2NrKE0sIG9mZnNldCkge1xuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX3N1YktleXMpO1xuICB9XG5cbiAgZGVjcnlwdEJsb2NrKE0sIG9mZnNldCkge1xuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludlN1YktleXMpO1xuICB9XG5cbiAgX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHN1YktleXMpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICAvLyBHZXQgaW5wdXRcbiAgICB0aGlzLl9sQmxvY2sgPSBNW29mZnNldF07XG4gICAgdGhpcy5fckJsb2NrID0gTVtvZmZzZXQgKyAxXTtcblxuICAgIC8vIEluaXRpYWwgcGVybXV0YXRpb25cbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgMHgwZjBmMGYwZik7XG4gICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcbiAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgMHgzMzMzMzMzMyk7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTtcblxuICAgIC8vIFJvdW5kc1xuICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAxNjsgcm91bmQgKz0gMSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBzdWJLZXkgPSBzdWJLZXlzW3JvdW5kXTtcbiAgICAgIGNvbnN0IGxCbG9jayA9IHRoaXMuX2xCbG9jaztcbiAgICAgIGNvbnN0IHJCbG9jayA9IHRoaXMuX3JCbG9jaztcblxuICAgICAgLy8gRmVpc3RlbCBmdW5jdGlvblxuICAgICAgbGV0IGYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgICAgZiB8PSBTQk9YX1BbaV1bKChyQmxvY2sgXiBzdWJLZXlbaV0pICYgU0JPWF9NQVNLW2ldKSA+Pj4gMF07XG4gICAgICB9XG4gICAgICB0aGlzLl9sQmxvY2sgPSByQmxvY2s7XG4gICAgICB0aGlzLl9yQmxvY2sgPSBsQmxvY2sgXiBmO1xuICAgIH1cblxuICAgIC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcbiAgICBjb25zdCB0ID0gdGhpcy5fbEJsb2NrO1xuICAgIHRoaXMuX2xCbG9jayA9IHRoaXMuX3JCbG9jaztcbiAgICB0aGlzLl9yQmxvY2sgPSB0O1xuXG4gICAgLy8gRmluYWwgcGVybXV0YXRpb25cbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgMHg1NTU1NTU1NSk7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xuICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAweDMzMzMzMzMzKTtcbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAweDBmMGYwZjBmKTtcblxuICAgIC8vIFNldCBvdXRwdXRcbiAgICBfTVtvZmZzZXRdID0gdGhpcy5fbEJsb2NrO1xuICAgIF9NW29mZnNldCArIDFdID0gdGhpcy5fckJsb2NrO1xuICB9XG59XG5ERVNBbGdvLmtleVNpemUgPSA2NCAvIDMyO1xuREVTQWxnby5pdlNpemUgPSA2NCAvIDMyO1xuREVTQWxnby5ibG9ja1NpemUgPSA2NCAvIDMyO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkRFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkRFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IERFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTQWxnbyk7XG5cbi8qKlxuICogVHJpcGxlLURFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgVHJpcGxlREVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUga2V5IGxlbmd0aCBpcyB2YWxpZCAoNjQsIDEyOCBvciA+PSAxOTIgYml0KVxuICAgIGlmIChrZXlXb3Jkcy5sZW5ndGggIT09IDIgJiYga2V5V29yZHMubGVuZ3RoICE9PSA0ICYmIGtleVdvcmRzLmxlbmd0aCA8IDYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgbGVuZ3RoIC0gM0RFUyByZXF1aXJlcyB0aGUga2V5IGxlbmd0aCB0byBiZSA2NCwgMTI4LCAxOTIgb3IgPjE5Mi4nKTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgdGhlIGtleSBhY2NvcmRpbmcgdG8gdGhlIGtleWluZyBvcHRpb25zIGRlZmluZWQgaW4gM0RFUyBzdGFuZGFyZFxuICAgIGNvbnN0IGtleTEgPSBrZXlXb3Jkcy5zbGljZSgwLCAyKTtcbiAgICBjb25zdCBrZXkyID0ga2V5V29yZHMubGVuZ3RoIDwgNCA/IGtleVdvcmRzLnNsaWNlKDAsIDIpIDoga2V5V29yZHMuc2xpY2UoMiwgNCk7XG4gICAgY29uc3Qga2V5MyA9IGtleVdvcmRzLmxlbmd0aCA8IDYgPyBrZXlXb3Jkcy5zbGljZSgwLCAyKSA6IGtleVdvcmRzLnNsaWNlKDQsIDYpO1xuXG4gICAgLy8gQ3JlYXRlIERFUyBpbnN0YW5jZXNcbiAgICB0aGlzLl9kZXMxID0gREVTQWxnby5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXkxKSk7XG4gICAgdGhpcy5fZGVzMiA9IERFU0FsZ28uY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5MikpO1xuICAgIHRoaXMuX2RlczMgPSBERVNBbGdvLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleTMpKTtcbiAgfVxuXG4gIGVuY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuICAgIHRoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG4gICAgdGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcbiAgfVxuXG4gIGRlY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuICAgIHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG4gICAgdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcbiAgfVxufVxuVHJpcGxlREVTQWxnby5rZXlTaXplID0gMTkyIC8gMzI7XG5UcmlwbGVERVNBbGdvLml2U2l6ZSA9IDY0IC8gMzI7XG5UcmlwbGVERVNBbGdvLmJsb2NrU2l6ZSA9IDY0IC8gMzI7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5leHBvcnQgY29uc3QgVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVNBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/tripledes.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/x64-core.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/x64-core.js ***!
  \************************************************/
/*! exports provided: X64Word, X64WordArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X64Word\", function() { return X64Word; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X64WordArray\", function() { return X64WordArray; });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst X32WordArray = _core_js__WEBPACK_IMPORTED_MODULE_0__[\"WordArray\"];\n\n/**\n * A 64-bit word.\n */\nclass X64Word extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created 64-bit word.\n   *\n   * @param {number} high The high 32 bits.\n   * @param {number} low The low 32 bits.\n   *\n   * @example\n   *\n   *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n   */\n  constructor(high, low) {\n    super();\n\n    this.high = high;\n    this.low = low;\n  }\n}\n\n/**\n * An array of 64-bit words.\n *\n * @property {Array} words The array of CryptoJS.x64.Word objects.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nclass X64WordArray extends _core_js__WEBPACK_IMPORTED_MODULE_0__[\"Base\"] {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create();\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ]);\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ], 10);\n   */\n  constructor(words = [], sigBytes = words.length * 8) {\n    super();\n\n    this.words = words;\n    this.sigBytes = sigBytes;\n  }\n\n  /**\n   * Converts this 64-bit word array to a 32-bit word array.\n   *\n   * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n   *\n   * @example\n   *\n   *     var x32WordArray = x64WordArray.toX32();\n   */\n  toX32() {\n    // Shortcuts\n    const x64Words = this.words;\n    const x64WordsLength = x64Words.length;\n\n    // Convert\n    const x32Words = [];\n    for (let i = 0; i < x64WordsLength; i += 1) {\n      const x64Word = x64Words[i];\n      x32Words.push(x64Word.high);\n      x32Words.push(x64Word.low);\n    }\n\n    return X32WordArray.create(x32Words, this.sigBytes);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {X64WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = x64WordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n\n    // Clone \"words\" array\n    clone.words = this.words.slice(0);\n    const { words } = clone;\n\n    // Clone each X64Word object\n    const wordsLength = words.length;\n    for (let i = 0; i < wordsLength; i += 1) {\n      words[i] = words[i].clone();\n    }\n\n    return clone;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIveDY0LWNvcmUuanM/NzY2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdtQjs7QUFFbkIscUJBQXFCLGtEQUFTOztBQUU5QjtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IsNkNBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ08sMkJBQTJCLDZDQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIveDY0LWNvcmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlLFxuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbmNvbnN0IFgzMldvcmRBcnJheSA9IFdvcmRBcnJheTtcblxuLyoqXG4gKiBBIDY0LWJpdCB3b3JkLlxuICovXG5leHBvcnQgY2xhc3MgWDY0V29yZCBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIDY0LWJpdCB3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAzMiBiaXRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgMzIgYml0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB4NjRXb3JkID0gQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpO1xuICAgKi9cbiAgY29uc3RydWN0b3IoaGlnaCwgbG93KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG4gICAgdGhpcy5sb3cgPSBsb3c7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBhcnJheSBvZiA2NC1iaXQgd29yZHMuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBYNjRXb3JkQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKCk7XG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcbiAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcbiAgICogICAgIF0pO1xuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcbiAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG4gICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG4gICAqICAgICBdLCAxMCk7XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3JkcyA9IFtdLCBzaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDgpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy53b3JkcyA9IHdvcmRzO1xuICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIDY0LWJpdCB3b3JkIGFycmF5IHRvIGEgMzItYml0IHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheSdzIGRhdGEgYXMgYSAzMi1iaXQgd29yZCBhcnJheS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB4MzJXb3JkQXJyYXkgPSB4NjRXb3JkQXJyYXkudG9YMzIoKTtcbiAgICovXG4gIHRvWDMyKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHg2NFdvcmRzID0gdGhpcy53b3JkcztcbiAgICBjb25zdCB4NjRXb3Jkc0xlbmd0aCA9IHg2NFdvcmRzLmxlbmd0aDtcblxuICAgIC8vIENvbnZlcnRcbiAgICBjb25zdCB4MzJXb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeDY0V29yZHNMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeDY0V29yZCA9IHg2NFdvcmRzW2ldO1xuICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmhpZ2gpO1xuICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmxvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFgzMldvcmRBcnJheS5jcmVhdGUoeDMyV29yZHMsIHRoaXMuc2lnQnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7WDY0V29yZEFycmF5fSBUaGUgY2xvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2xvbmUgPSB4NjRXb3JkQXJyYXkuY2xvbmUoKTtcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcblxuICAgIC8vIENsb25lIFwid29yZHNcIiBhcnJheVxuICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBjbG9uZTtcblxuICAgIC8vIENsb25lIGVhY2ggWDY0V29yZCBvYmplY3RcbiAgICBjb25zdCB3b3Jkc0xlbmd0aCA9IHdvcmRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHdvcmRzW2ldID0gd29yZHNbaV0uY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/x64-core.js\n");

/***/ }),

/***/ "./node_modules/lodash.defaults/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.defaults/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Used by `_.defaults` to customize its `_.assignIn` use.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to assign.\n * @param {Object} object The parent object of `objValue`.\n * @returns {*} Returns the value to assign.\n */\nfunction assignInDefaults(objValue, srcValue, key, object) {\n  if (objValue === undefined ||\n      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n    return srcValue;\n  }\n  return objValue;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * This method is like `_.assignIn` except that it accepts `customizer`\n * which is invoked to produce the assigned values. If `customizer` returns\n * `undefined`, assignment is handled by the method instead. The `customizer`\n * is invoked with five arguments: (objValue, srcValue, key, object, source).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extendWith\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @see _.assignWith\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   return _.isUndefined(objValue) ? srcValue : objValue;\n * }\n *\n * var defaults = _.partialRight(_.assignInWith, customizer);\n *\n * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n  copyObject(source, keysIn(source), object, customizer);\n});\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(args) {\n  args.push(undefined, assignInDefaults);\n  return apply(assignInWith, undefined, args);\n});\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWZhdWx0cy9pbmRleC5qcz8xM2NhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQzlDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ2hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlZmF1bHRzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25JbkRlZmF1bHRzKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBhc3NpZ25JbkRlZmF1bHRzKTtcbiAgcmV0dXJuIGFwcGx5KGFzc2lnbkluV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.defaults/index.js\n");

/***/ }),

/***/ "./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"./node_modules/lodash.defaults/index.js\");\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            ws.close();\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.ws = undefined;\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reconnect();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        this.dispatchEventOfType(\"close\", event);\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0dXJkeS13ZWJzb2NrZXQvZGlzdC9pbmRleC5qcz8xYTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsZUFBZSxtQkFBTyxDQUFDLGdFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsdUJBQXVCLEVBQUU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFLHVDQUF1QyxpQ0FBaUM7QUFDeEUseUNBQXlDLG1DQUFtQztBQUM1RSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0QkFBNEIsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUMsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNENBQTRDLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHVyZHktd2Vic29ja2V0L2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoXCJsb2Rhc2guZGVmYXVsdHNcIik7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbm90IHByZXNlbnQgaW4gZ2xvYmFsIHNjb3BlIGFuZCBubyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwid3NDb25zdHJ1Y3RvciBvcHRpb24gd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYmluYXJ5VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5VHlwZUludGVybmFsIHx8IFwiYmxvYlwiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaW5hcnlUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gdGhpcy53cyA/IHRoaXMud3MuYnVmZmVyZWRBbW91bnQgOiAwO1xuICAgICAgICAgICAgdmFyIGhhc1Vua25vd25BbW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93bkFtb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzVW5rbm93bkFtb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coXCJTb21lIGJ1ZmZlcmVkIGRhdGEgaGFkIHVua25vd24gbGVuZ3RoLiBidWZmZXJlZEFtb3VudCgpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiByZXR1cm4gdmFsdWUgbWF5IGJlIGJlbG93IHRoZSBjb3JyZWN0IGFtb3VudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJleHRlbnNpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MuZXh0ZW5zaW9ucyA6IHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5wcm90b2NvbCA6IHRoaXMubGFzdEtub3duUHJvdG9jb2w7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQ2xvc2VkID8gU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA6IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShldmVudC50eXBlLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLm9wZW5OZXdXZWJTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjb25uZWN0VGltZW91dCA9IF9hLmNvbm5lY3RUaW1lb3V0LCB3c0NvbnN0cnVjdG9yID0gX2Eud3NDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIk9wZW5pbmcgbmV3IFdlYlNvY2tldCB0byBcIiArIHRoaXMudXJsICsgXCIuXCIpO1xuICAgICAgICB2YXIgd3MgPSBuZXcgd3NDb25zdHJ1Y3Rvcih0aGlzLnVybCwgdGhpcy5wcm90b2NvbHMpO1xuICAgICAgICB3cy5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVDbG9zZShldmVudCk7IH07XG4gICAgICAgIHdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUVycm9yKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVNZXNzYWdlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVPcGVuKGV2ZW50KTsgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHJ1bm5pbmcsIHdlIHN0aWxsIGhhdmVuJ3Qgb3BlbmVkIHRoZSB3ZWJzb2NrZXQuXG4gICAgICAgICAgICAvLyBLaWxsIGl0IHNvIHdlIGNhbiB0cnkgYWdhaW4uXG4gICAgICAgICAgICBfdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICB9LCBjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMud3MgPSB3cztcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlT3BlbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxDbGVhclJlc2V0VGltZSA9IHRoaXMub3B0aW9ucy5hbGxDbGVhclJlc2V0VGltZTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBvcGVuZWQuXCIpO1xuICAgICAgICBpZiAodGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IHRoaXMud3MuYmluYXJ5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQmVlbk9wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwicmVvcGVuXCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm9wZW5cIiwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX3RoaXMuc2VuZChtZXNzYWdlKTsgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgb3BlblRpbWUgPSAoYWxsQ2xlYXJSZXNldFRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgICAgICBfdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCByZW1haW5lZCBvcGVuIGZvciBcIiArIG9wZW5UaW1lICsgXCIgc2Vjb25kcy4gUmVzZXR0aW5nXCIgK1xuICAgICAgICAgICAgICAgIFwiIHJldHJ5IHRpbWUgYW5kIGNvdW50LlwiKTtcbiAgICAgICAgfSwgYWxsQ2xlYXJSZXNldFRpbWUpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwibWVzc2FnZVwiLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IF9hLm1heFJlY29ubmVjdEF0dGVtcHRzLCBzaG91bGRSZWNvbm5lY3QgPSBfYS5zaG91bGRSZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSB0aGlzLndzLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gdGhpcy53cy5wcm90b2NvbDtcbiAgICAgICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gc2hvdWxkUmVjb25uZWN0KGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsUmVjb25uZWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbFJlY29ubmVjdC50aGVuKGZ1bmN0aW9uICh3aWxsUmVjb25uZWN0UmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3RSZXNvbHZlZCwgZXZlbnQsIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImVycm9yXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBlbmNvdW50ZXJlZCBhbiBlcnJvci5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZVdpbGxSZWNvbm5lY3QgPSBmdW5jdGlvbiAod2lsbFJlY29ubmVjdCwgZXZlbnQsIGRlbmlhbFJlYXNvbikge1xuICAgICAgICBpZiAod2lsbFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgZGVuaWFsUmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWluUmVjb25uZWN0RGVsYXkgPSBfYS5taW5SZWNvbm5lY3REZWxheSwgbWF4UmVjb25uZWN0RGVsYXkgPSBfYS5tYXhSZWNvbm5lY3REZWxheSwgcmVjb25uZWN0QmFja29mZkZhY3RvciA9IF9hLnJlY29ubmVjdEJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQrKztcbiAgICAgICAgdmFyIHJldHJ5VGltZSA9IHRoaXMubmV4dFJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gTWF0aC5tYXgobWluUmVjb25uZWN0RGVsYXksIE1hdGgubWluKHRoaXMubmV4dFJldHJ5VGltZSAqIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IsIG1heFJlY29ubmVjdERlbGF5KSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3Blbk5ld1dlYlNvY2tldCgpOyB9LCByZXRyeVRpbWUpO1xuICAgICAgICB2YXIgcmV0cnlUaW1lU2Vjb25kcyA9IChyZXRyeVRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgd2FzIGNsb3NlZC4gUmUtb3BlbmluZyBpbiBcIiArIHJldHJ5VGltZVNlY29uZHMgKyBcIiBzZWNvbmRzLlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc3RvcFJlY29ubmVjdGluZyA9IGZ1bmN0aW9uIChldmVudCwgZGVidWdSZWFzb24pIHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhkZWJ1Z1JlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxUaW1lb3V0cygpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxUaW1lb3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJDb25uZWN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50T2ZUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25kb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25kb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVvcGVuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25yZW9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnJlb3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXVxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBfdGhpcy5jYWxsTGlzdGVuZXIobGlzdGVuZXIsIGV2ZW50KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFldmVudCB8fCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2FsbExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGVidWdMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSB0aGlzLm9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgXCIgKyBtYXhSZWNvbm5lY3RBdHRlbXB0cyArIFwiIFwiICsgcGx1cmFsaXplKFwiYXR0ZW1wdFwiLCBtYXhSZWNvbm5lY3RBdHRlbXB0cykgKyBcIi4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlMgPSB7XG4gICAgICAgIGFsbENsZWFyUmVzZXRUaW1lOiA1MDAwLFxuICAgICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBtaW5SZWNvbm5lY3REZWxheTogMTAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0RGVsYXk6IDMwMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yOiAxLjUsXG4gICAgICAgIHNob3VsZFJlY29ubmVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgd3NDb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkNPTk5FQ1RJTkcgPSAwO1xuICAgIFN0dXJkeVdlYlNvY2tldC5PUEVOID0gMTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0lORyA9IDI7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA9IDM7XG4gICAgcmV0dXJuIFN0dXJkeVdlYlNvY2tldDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHVyZHlXZWJTb2NrZXQ7XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sturdy-websocket/dist/index.js\n");

/***/ })

}]);